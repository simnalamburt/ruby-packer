diff -ruN ruby-2.4.1/Makefile.in ruby/Makefile.in
--- ruby-2.4.1/Makefile.in	2016-12-17 09:48:58.000000000 +0200
+++ ruby/Makefile.in	2018-03-16 15:30:55.000000000 +0200
@@ -218,12 +218,12 @@
 miniruby$(EXEEXT):
 		@-if test -f $@; then $(MV) -f $@ $@.old; $(RM) $@.old; fi
 		$(ECHO) linking $@
-		$(Q) $(PURIFY) $(CC) $(LDFLAGS) $(XLDFLAGS) $(NORMALMAINOBJ) $(MINIOBJS) $(COMMONOBJS) $(MAINLIBS) $(LIBS) $(OUTFLAG)$@
+		$(Q) $(PURIFY) $(CC) $(LDFLAGS) $(XLDFLAGS) $(NORMALMAINOBJ) $(MINIOBJS) $(COMMONOBJS) $(MAINLIBS) $(LIBS) $(RUBYC_FLAGS) $(OUTFLAG)$@ $(LDFLAGS)
 
 $(PROGRAM):
 		@$(RM) $@
 		$(ECHO) linking $@
-		$(Q) $(PURIFY) $(CC) $(LDFLAGS) $(XLDFLAGS) $(MAINOBJ) $(EXTOBJS) $(LIBRUBYARG) $(MAINLIBS) $(LIBS) $(EXTLIBS) $(OUTFLAG)$@
+		$(Q) $(PURIFY) $(CC) $(LDFLAGS) $(XLDFLAGS) $(MAINOBJ) $(EXTOBJS) $(LIBRUBYARG) $(MAINLIBS) $(LIBS) $(EXTLIBS) $(RUBYC_FLAGS) $(OUTFLAG)$@ $(LDFLAGS)
 		$(Q) $(POSTLINK)
 
 # We must `rm' the library each time this rule is invoked because "updating" a
@@ -235,7 +235,7 @@
 		$(Q) $(AR) $(ARFLAGS) $@ $(LIBRUBY_A_OBJS) $(INITOBJS)
 		@-$(RANLIB) $@ 2> /dev/null || true
 		$(ECHO) verifying static-library $@
-		@$(PURIFY) $(CC) $(LDFLAGS) $(XLDFLAGS) $(MAINOBJ) $(LIBRUBY_A) $(MAINLIBS) $(EXTLIBS) $(LIBS) $(OUTFLAG)conftest$(EXEEXT)
+		@$(PURIFY) $(CC) $(LDFLAGS) $(XLDFLAGS) $(MAINOBJ) $(LIBRUBY_A) $(MAINLIBS) $(EXTLIBS) $(LIBS) $(RUBYC_FLAGS) $(OUTFLAG)conftest$(EXEEXT) $(LDFLAGS)
 		@$(RM) conftest$(EXEEXT) conftest.c
 
 $(LIBRUBY_SO):
diff -ruN ruby-2.4.1/autoupdate_autoupdate.c ruby/autoupdate_autoupdate.c
--- ruby-2.4.1/autoupdate_autoupdate.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/autoupdate_autoupdate.c	2018-03-16 15:30:55.000000000 +0200
@@ -0,0 +1,1105 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
+#include "zlib.h"
+
+#ifdef _WIN32
+
+#include <assert.h>
+#include <string.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <stdio.h>
+#include <conio.h>
+#include <stdint.h>
+#include <stdlib.h> /* exit */
+#include <wchar.h>
+
+int autoupdate(
+	int argc,
+	wchar_t *wargv[],
+	const char *host,
+	const char *port,
+	const char *path,
+	const char *current,
+	short force
+)
+{
+	WSADATA wsaData;
+
+	if (!force && !autoupdate_should_proceed()) {
+		return 1;
+	}
+
+	if (!force && !autoupdate_should_proceed_24_hours(argc, wargv, 0)) {
+		return 4;
+	}
+
+	// Initialize Winsock
+	int iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
+	if (iResult != 0) {
+		fprintf(stderr, "Auto-update Failed: WSAStartup failed with %d\n", iResult);
+		return 2;
+	}
+
+	struct addrinfo *result = NULL,
+		*ptr = NULL,
+		hints;
+
+	ZeroMemory(&hints, sizeof(hints));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_protocol = IPPROTO_TCP;
+
+	// Resolve the server address and port
+	iResult = getaddrinfo(host, port, &hints, &result);
+	if (iResult != 0) {
+		fprintf(stderr, "Auto-update Failed: getaddrinfo failed with %d\n", iResult);
+		WSACleanup();
+		return 2;
+	}
+
+	SOCKET ConnectSocket = INVALID_SOCKET;
+
+	// Attempt to connect to the first address returned by
+	// the call to getaddrinfo
+	ptr = result;
+
+	// Create a SOCKET for connecting to server
+	ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype,
+		ptr->ai_protocol);
+
+	if (ConnectSocket == INVALID_SOCKET) {
+		fprintf(stderr, "Auto-update Failed: Error at socket() with %d\n", WSAGetLastError());
+		freeaddrinfo(result);
+		WSACleanup();
+		return 2;
+	}
+
+	// Connect to server.
+	iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
+	if (iResult == SOCKET_ERROR) {
+		closesocket(ConnectSocket);
+		ConnectSocket = INVALID_SOCKET;
+	}
+	freeaddrinfo(result);
+	if (ConnectSocket == INVALID_SOCKET) {
+		fprintf(stderr, "Auto-update Failed: connect failed on %s and port %s\n", host, port);
+		WSACleanup();
+		return 2;
+	}
+	if (5 != send(ConnectSocket, "HEAD ", 5, 0) ||
+		strlen(path) != send(ConnectSocket, path, strlen(path), 0) ||
+		11 != send(ConnectSocket, " HTTP/1.0\r\n", 11, 0) ||
+		6 != send(ConnectSocket, "Host: ", 6, 0) ||
+		strlen(host) != send(ConnectSocket, host, strlen(host), 0) ||
+		4 != send(ConnectSocket, "\r\n\r\n", 4, 0)) {
+			fprintf(stderr, "Auto-update Failed: send failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+	}
+
+	char response[1024 * 10 + 1]; // 10KB
+	int bytes, total;
+	total = sizeof(response) - 2;
+	long long received = 0;
+	do {
+		bytes = recv(ConnectSocket, response + received, total - received, 0);
+		if (bytes < 0) {
+			fprintf(stderr, "Auto-update Failed: recv failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			*(response + received) = 0;
+			break;
+		}
+		received += bytes;
+	} while (received < total);
+	if (received == total) {
+		fprintf(stderr, "Auto-update Failed: read causes buffer full\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+
+	// shutdown the connection for sending since no more data will be sent
+	// the client can still use the ConnectSocket for receiving data
+	iResult = shutdown(ConnectSocket, SD_SEND);
+	if (iResult == SOCKET_ERROR) {
+		fprintf(stderr, "Auto-update Failed: shutdown failed with %d\n", WSAGetLastError());
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+
+	assert(received < total);
+	size_t len = strlen(response);
+	short again_302 = 0;
+parse_location_header:
+	assert(len <= total);
+	char *new_line = NULL;
+	char *found = NULL;
+	size_t i = 0;
+	response[sizeof(response) - 1] = 0;
+	while (i < len) {
+		new_line = strstr(response + i, "\r\n");
+		if (NULL == new_line) {
+			break;
+		}
+		*new_line = 0;
+		if (0 == strncmp(response + i, "Location: ", 10)) {
+			found = response + i + 10;
+			break;
+		}
+		*new_line = '\r';
+		i = new_line - response + 2;
+	}
+	if (!found) {
+		fprintf(stderr, "Auto-update Failed: failed to find a Location header\n");
+		return 2;
+	}
+	if (!again_302) {
+		if (strstr(found, current)) {
+			/* Latest version confirmed. No need to update */
+			autoupdate_should_proceed_24_hours(argc, wargv, 1);
+			return 0;
+		} else {
+			fprintf(stderr, "Hint: to disable auto-update, run with environment variable CI=true\n");
+			fflush(stderr);
+		}
+	}
+
+	char *url = found;
+	fprintf(stderr, "Downloading update from %s\n", url);
+	fflush(stderr);
+
+	char *host2;
+	char *port2 = "80";
+	if (strlen(url) >= 8 && 0 == strncmp("https://", url, 8)) {
+		host2 = url + 8;
+	} else if (strlen(url) >= 7 && 0 == strncmp("http://", url, 7)) {
+		host2 = url + 7;
+	} else {
+		fprintf(stderr, "Auto-update Failed: failed to find http:// or https:// at the beginning of URL %s\n", url);
+		return 2;
+	}
+	char *found_slash = strchr(host2, '/');
+	char *request_path;
+	if (NULL == found_slash) {
+		request_path = "/";
+	} else {
+		request_path = found_slash;
+		*found_slash = 0;
+	}
+
+	result = NULL;
+	ptr = NULL;
+	ZeroMemory(&hints, sizeof(hints));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_protocol = IPPROTO_TCP;
+
+	// Resolve the server address and port
+	iResult = getaddrinfo(host2, port2, &hints, &result);
+	if (iResult != 0) {
+		fprintf(stderr, "Auto-update Failed: getaddrinfo failed with %d\n", iResult);
+		WSACleanup();
+		return 2;
+	}
+
+	ConnectSocket = INVALID_SOCKET;
+
+	// Attempt to connect to the first address returned by
+	// the call to getaddrinfo
+	ptr = result;
+
+	// Create a SOCKET for connecting to server
+	ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
+
+	if (ConnectSocket == INVALID_SOCKET) {
+		fprintf(stderr, "Auto-update Failed: Error at socket() with %d\n", WSAGetLastError());
+		freeaddrinfo(result);
+		WSACleanup();
+		return 2;
+	}
+	// Connect to server.
+	iResult = connect(ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
+	if (iResult == SOCKET_ERROR) {
+		closesocket(ConnectSocket);
+		ConnectSocket = INVALID_SOCKET;
+	}
+	freeaddrinfo(result);
+	if (ConnectSocket == INVALID_SOCKET) {
+		fprintf(stderr, "Auto-update Failed: connect failed on %s and port %s\n", host2, port2);
+		WSACleanup();
+		return 2;
+	}
+	if (NULL != found_slash) {
+		*found_slash = '/';
+	}
+	if (4 != send(ConnectSocket, "GET ", 4, 0) ||
+		strlen(request_path) != send(ConnectSocket, request_path, strlen(request_path), 0) ||
+		11 != send(ConnectSocket, " HTTP/1.0\r\n", 11, 0)) {
+			fprintf(stderr, "Auto-update Failed: send failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+	}
+	if (NULL != found_slash) {
+		*found_slash = 0;
+	}
+	if (6 != send(ConnectSocket, "Host: ", 6, 0) ||
+		strlen(host2) != send(ConnectSocket, host2, strlen(host2), 0) ||
+		4 != send(ConnectSocket, "\r\n\r\n", 4, 0)) {
+			fprintf(stderr, "Auto-update Failed: send failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+	}
+
+	// Read the header
+	total = sizeof(response) - 2;
+	response[sizeof(response) - 1] = 0;
+	received = 0;
+	char *header_end = NULL;
+	do {
+		bytes = recv(ConnectSocket, response + received, total - received, 0);
+		if (bytes < 0) {
+			fprintf(stderr, "Auto-update Failed: recv failed with %d\n", WSAGetLastError());
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			*(response + received) = 0;
+			break;
+		}
+		*(response + received + bytes) = 0;
+		header_end = strstr(response + received, "\r\n\r\n");
+		received += bytes;
+		if (header_end) {
+			break;
+		}
+	} while (received < total);
+	if (NULL == header_end) {
+		fprintf(stderr, "Auto-update Failed: failed to find the end of the response header\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	assert(received <= total);
+
+	// Possible new 302
+	if (received > 13 && (
+		0 == strncmp(response, "HTTP/1.1 302 ", 13) ||
+		0 == strncmp(response, "HTTP/1.0 302 ", 13))) {
+			len = received;
+			again_302 = 1;
+			goto parse_location_header;
+	}
+
+	// Parse the header
+	len = received;
+	assert(len <= total);
+	new_line = NULL;
+	long long found_length = -1;
+	i = 0;
+	response[sizeof(response) - 1] = 0;
+	while (i < len) {
+		new_line = strstr(response + i, "\r\n");
+		if (NULL == new_line) {
+			break;
+		}
+		*new_line = 0;
+		if (0 == strncmp(response + i, "Content-Length: ", 16)) {
+			found_length = atoll(response + i + 16);
+			break;
+		}
+		*new_line = '\r';
+		i = new_line - response + 2;
+	}
+	if (-1 == found_length) {
+		fprintf(stderr, "Auto-update Failed: failed to find a Content-Length header\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	if (0 == found_length) {
+		fprintf(stderr, "Auto-update Failed: found a Content-Length header of zero\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	assert(found_length > 0);
+	// Read the body
+	// header_end -> \r\n\r\n
+	assert(header_end);
+	assert(header_end + 4 <= response + received);
+	// put the rest of over-read content when reading header
+	size_t the_rest = response + received - (header_end + 4);
+	char *body_buffer = (char *)(malloc(found_length));
+	if (NULL == body_buffer) {
+		fprintf(stderr, "Auto-update Failed: Insufficient memory\n");
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	memcpy(body_buffer, (header_end + 4), the_rest);
+	char *body_buffer_ptr = body_buffer + the_rest;
+	char *body_buffer_end = body_buffer + found_length;
+	// read the remaining body
+	received = the_rest;
+	fprintf(stderr, "\r%lld / %lld bytes finished (%lld%%)",  received, found_length, received*100LL/found_length);
+	fflush(stderr);
+	while (received < found_length) {
+		size_t space = 100 * 1024;
+		if (space > body_buffer_end - body_buffer_ptr) {
+			space = body_buffer_end - body_buffer_ptr;
+		}
+		bytes = recv(ConnectSocket, body_buffer_ptr, space, 0);
+		if (bytes < 0) {
+			fprintf(stderr, "Auto-update Failed: read failed\n");
+			free(body_buffer);
+			closesocket(ConnectSocket);
+			WSACleanup();
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			break;
+		}
+		received += bytes;
+		body_buffer_ptr += bytes;
+		fprintf(stderr, "\r%lld / %lld bytes finished (%lld%%)",  received, found_length, received*100LL/found_length);
+		fflush(stderr);
+	}
+	if (received != found_length) {
+		assert(received < found_length);
+		fprintf(stderr, "Auto-update Failed: prematurely reached EOF after reading %lld bytes\n", received);
+		closesocket(ConnectSocket);
+		WSACleanup();
+		free(body_buffer);
+		return 2;
+	}
+	fprintf(stderr, "\n");
+	fflush(stderr);
+	// shutdown the connection for sending since no more data will be sent
+	// the client can still use the ConnectSocket for receiving data
+	iResult = shutdown(ConnectSocket, SD_SEND);
+	if (iResult == SOCKET_ERROR) {
+		fprintf(stderr, "Auto-update Failed: shutdown failed with %d\n", WSAGetLastError());
+		closesocket(ConnectSocket);
+		WSACleanup();
+		return 2;
+	}
+	// Inflate to a file
+	fprintf(stderr, "Inflating");
+	fflush(stderr);
+	struct ZIPLocalFileHeader *h = (struct ZIPLocalFileHeader *)body_buffer;
+	if (!(0x04034b50 == h->signature && 8 == h->compressionMethod)) {
+		fprintf(stderr, "Auto-update Failed: We only support a zip file containing "
+			"one Deflate compressed file for the moment.\n"
+			"Pull requests are welcome on GitHub at "
+			"https://github.com/pmq20/libautoupdate\n");
+	}
+	// skip the Local File Header
+	unsigned full_length = found_length - sizeof(struct ZIPLocalFileHeader) - h->fileNameLength;
+	unsigned half_length = full_length / 2;
+	unsigned uncompLength = full_length;
+
+	/* windowBits is passed < 0 to tell that there is no zlib header.
+	* Note that in this case inflate *requires* an extra "dummy" byte
+	* after the compressed stream in order to complete decompression and
+	* return Z_STREAM_END.
+	*/
+	char* uncomp = (char*)calloc(sizeof(char), uncompLength + 1);
+	if (NULL == uncomp) {
+		fprintf(stderr, "Auto-update Failed: Insufficient memory\n");
+		free(body_buffer);
+		return 2;
+	}
+
+	z_stream strm;
+	strm.next_in = (Bytef *)(body_buffer + sizeof(struct ZIPLocalFileHeader) + h->fileNameLength);
+	strm.avail_in = found_length;
+	strm.total_out = 0;
+	strm.zalloc = Z_NULL;
+	strm.zfree = Z_NULL;
+
+	short done = 0;
+
+	if (inflateInit2(&strm, -MAX_WBITS) != Z_OK) {
+		free(uncomp);
+		free(body_buffer);
+		fprintf(stderr, "Auto-update Failed: inflateInit2 failed\n");
+		return 2;
+	}
+
+	while (!done) {
+		// If our output buffer is too small
+		if (strm.total_out >= uncompLength) {
+			// Increase size of output buffer
+			char* uncomp2 = (char*)calloc(sizeof(char), uncompLength + half_length + 1);
+			if (NULL == uncomp2) {
+				free(uncomp);
+				free(body_buffer);
+				fprintf(stderr, "Auto-update Failed: calloc failed\n");
+				return 2;
+			}
+			memcpy(uncomp2, uncomp, uncompLength);
+			uncompLength += half_length;
+			free(uncomp);
+			uncomp = uncomp2;
+		}
+
+		strm.next_out = (Bytef *)(uncomp + strm.total_out);
+		strm.avail_out = uncompLength - strm.total_out;
+
+		// Inflate another chunk.
+		int err = inflate(&strm, Z_SYNC_FLUSH);
+		if (err == Z_STREAM_END) {
+			done = 1;
+		}
+		else if (err != Z_OK) {
+			fprintf(stderr, "Auto-update Failed: inflate failed with %d\n", err);
+			free(uncomp);
+			free(body_buffer);
+			return 2;
+		}
+	}
+
+	if (inflateEnd(&strm) != Z_OK) {
+		fprintf(stderr, "Auto-update Failed: inflateInit2 failed\n");
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+
+	wchar_t *tmpdir = autoupdate_tmpdir();
+	if (NULL == tmpdir) {
+		fprintf(stderr, "Auto-update Failed: no temporary folder found\n");
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	/* Windows paths can never be longer than this. */
+	const size_t exec_path_len = 32768;
+	wchar_t exec_path[32768];
+	DWORD utf16_len = GetModuleFileNameW(NULL, exec_path, exec_path_len);
+	if (0 == utf16_len) {
+		fprintf(stderr, "Auto-update Failed: GetModuleFileNameW failed with GetLastError=%d\n", GetLastError());
+		free((void*)(tmpdir));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	if (tmpdir[0] != exec_path[0]) {
+		free((void*)(tmpdir));
+		tmpdir = wcsdup(exec_path);
+		wchar_t *backslash = wcsrchr(tmpdir, L'\\');
+		if (NULL == backslash) {
+			fprintf(stderr, "Auto-update Failed: Cannot find an approriate tmpdir with %S\n", tmpdir);
+			free((void*)(tmpdir));
+			free(uncomp);
+			free(body_buffer);
+			return 2;
+		}
+		*backslash = 0;
+	}
+	wchar_t *tmpf = autoupdate_tmpf(tmpdir, "exe");
+	if (NULL == tmpf) {
+		fprintf(stderr, "Auto-update Failed: no temporary file available\n");
+		free((void*)(tmpdir));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	FILE *fp = _wfopen(tmpf, L"wb");
+	if (NULL == fp) {
+		fprintf(stderr, "Auto-update Failed: cannot open temporary file %S\n", tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	fprintf(stderr, " to %S\n", tmpf);
+	size_t fwrite_ret = fwrite(uncomp, sizeof(char), strm.total_out, fp);
+	if (fwrite_ret != strm.total_out) {
+		fprintf(stderr, "Auto-update Failed: fwrite failed %S\n", tmpf);
+		fclose(fp);
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	fclose(fp);
+	free(uncomp);
+	free(body_buffer);
+	// Backup
+	wchar_t *selftmpf = autoupdate_tmpf(tmpdir, "exe");
+	if (NULL == selftmpf) {
+		fprintf(stderr, "Auto-update Failed: no temporary file available\n");
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		return 2;
+	}
+	fprintf(stderr, "Moving the old version from %S to %S\n", exec_path, selftmpf);
+	BOOL ret = MoveFileExW(exec_path, selftmpf, MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH);
+	if (!ret) {
+		fprintf(stderr, "Auto-update Failed: MoveFileW failed with GetLastError=%d\n", GetLastError());
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free((void*)(selftmpf));
+		return 2;
+	}
+	// Move the new version into the original place
+	fprintf(stderr, "Moving the new version from %S to %S \n", tmpf, exec_path);
+	ret = MoveFileExW(tmpf, exec_path, MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH);
+	if (!ret) {
+		fprintf(stderr, "Auto-update Failed: MoveFileW failed with GetLastError=%d\n", GetLastError());
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free((void*)(selftmpf));
+		return 2;
+	}
+	// Restarting
+	fprintf(stderr, "Restarting...\n");
+	fflush(stderr);
+	STARTUPINFO si;
+	PROCESS_INFORMATION pi;
+	ZeroMemory(&si, sizeof(si));
+	si.cb = sizeof(si);
+	ZeroMemory(&pi, sizeof(pi));
+	ret = CreateProcess(
+		NULL,	     // No module name (use command line)
+		GetCommandLine(), // Command line
+		NULL,	     // Process handle not inheritable
+		NULL,	     // Thread handle not inheritable
+		FALSE,	    // Set handle inheritance to FALSE
+		0,		// No creation flags
+		NULL,	     // Use parent's environment block
+		NULL,	     // Use parent's starting directory 
+		&si,	      // Pointer to STARTUPINFO structure
+		&pi	       // Pointer to PROCESS_INFORMATION structure
+	);
+	if (!ret) {
+		fprintf(stderr, "Auto-update Failed: CreateProcess failed with GetLastError=%d\n", GetLastError());
+		DeleteFileW(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free((void*)(selftmpf));
+		return 3;
+	}
+	// Wait until child process exits.
+	WaitForSingleObject(pi.hProcess, INFINITE);
+	// Close process and thread handles. 
+	CloseHandle(pi.hProcess);
+	CloseHandle(pi.hThread);
+	fprintf(stderr, "Deleting %S\n", selftmpf);
+	fflush(stderr);
+	_wexeclp(L"cmd", L"cmd", L"/c", L"ping", L"127.0.0.1", L"-n", L"3", L">nul", L"&", L"del", selftmpf, NULL);
+	// we should never reach here
+	assert(0);
+	return 3;
+}
+
+#else
+
+#include <assert.h>
+#include <stdio.h> /* printf, sprintf */
+#include <stdlib.h> /* exit */
+#include <unistd.h> /* read, write, close */
+#include <string.h> /* memcpy, memset */
+#include <sys/socket.h> /* socket, connect */
+#include <netinet/in.h> /* struct sockaddr_in, struct sockaddr */
+#include <netdb.h> /* struct hostent, gethostbyname */
+#include <unistd.h>
+#include <sys/select.h>
+#include <limits.h>  /* PATH_MAX */
+#include <sys/stat.h> /* struct stat */
+#include <errno.h>
+
+int autoupdate(
+	int argc,
+	char *argv[],
+	const char *host,
+	uint16_t port,
+	const char *path,
+	const char *current,
+	short force
+)
+{
+	struct hostent *server;
+	struct sockaddr_in serv_addr;
+	int sockfd, bytes, total;
+	char response[1024 * 10 + 1]; // 10KB
+
+	if (!force && !autoupdate_should_proceed()) {
+		return 1;
+	}
+
+	if (!force && !autoupdate_should_proceed_24_hours(argc, argv, 0)) {
+		return 4;
+	}
+
+	sockfd = socket(AF_INET, SOCK_STREAM, 0);
+	if (sockfd < 0) {
+		fprintf(stderr, "Auto-update Failed: socket creation failed\n");
+		return 2;
+	}
+	server = gethostbyname(host);
+	if (server == NULL) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: gethostbyname failed for %s\n", host);
+		return 2;
+	}
+	memset(&serv_addr, 0, sizeof(serv_addr));
+	serv_addr.sin_family = AF_INET;
+	serv_addr.sin_port = htons(port);
+	memcpy(&serv_addr.sin_addr.s_addr, server->h_addr, server->h_length);
+	if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: connect failed on %s and port %d\n", host, port);
+		return 2;
+	}
+	if (5 != write(sockfd, "HEAD ", 5) ||
+		strlen(path) != write(sockfd, path, strlen(path)) ||
+		11 != write(sockfd, " HTTP/1.0\r\n", 11) ||
+		6 != write(sockfd, "Host: ", 6) ||
+		strlen(host) != write(sockfd, host, strlen(host)) ||
+		4 != write(sockfd, "\r\n\r\n", 4)) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: write failed\n");
+			return 2;
+	}
+	total = sizeof(response) - 2;
+	long long received = 0;
+	do {
+		bytes = read(sockfd, response + received, total - received);
+		if (bytes < 0) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: read failed\n");
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			*(response + received) = 0;
+			break;
+		}
+		received += bytes;
+	} while (received < total);
+	if (received == total) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: read causes buffer full\n");
+		return 2;
+	}
+	close(sockfd);
+	assert(received < total);
+	size_t len = strlen(response);
+	short again_302 = 0;
+parse_location_header:
+	assert(len <= total);
+	char *new_line = NULL;
+	char *found = NULL;
+	size_t i = 0;
+	response[sizeof(response) - 1] = 0;
+	while (i < len) {
+		new_line = strstr(response + i, "\r\n");
+		if (NULL == new_line) {
+			break;
+		}
+		*new_line = 0;
+		if (0 == strncmp(response + i, "Location: ", 10)) {
+			found = response + i + 10;
+			break;
+		}
+		*new_line = '\r';
+		i = new_line - response + 2;
+	}
+	if (!found) {
+		fprintf(stderr, "Auto-update Failed: failed to find a Location header\n");
+		return 2;
+	}
+	if (!again_302) {
+		if (strstr(found, current)) {
+			/* Latest version confirmed. No need to update */
+			autoupdate_should_proceed_24_hours(argc, argv, 1);
+			return 0;
+		} else {
+			fprintf(stderr, "Hint: to disable auto-update, run with environment variable CI=true\n");
+			fflush(stderr);
+		}
+	}
+
+	char *url = found;
+	fprintf(stderr, "Downloading update from %s\n", url);
+	fflush(stderr);
+
+	char *host2;
+	uint16_t port2 = 80;
+	if (strlen(url) >= 8 && 0 == strncmp("https://", url, 8)) {
+		host2 = url + 8;
+	} else if (strlen(url) >= 7 && 0 == strncmp("http://", url, 7)) {
+		host2 = url + 7;
+	} else {
+		fprintf(stderr, "Auto-update Failed: failed to find http:// or https:// at the beginning of URL %s\n", url);
+		return 2;
+	}
+	char *found_slash = strchr(host2, '/');
+	char *request_path;
+	if (NULL == found_slash) {
+		request_path = "/";
+	} else {
+		request_path = found_slash;
+		*found_slash = 0;
+	}
+	sockfd = socket(AF_INET, SOCK_STREAM, 0);
+	if (sockfd < 0) {
+		fprintf(stderr, "Auto-update Failed: socket creation failed\n");
+		return 2;
+	}
+	server = gethostbyname(host2);
+	if (server == NULL) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: gethostbyname failed for %s\n", host2);
+		return 2;
+	}
+	memset(&serv_addr, 0, sizeof(serv_addr));
+	serv_addr.sin_family = AF_INET;
+	serv_addr.sin_port = htons(port2);
+	memcpy(&serv_addr.sin_addr.s_addr, server->h_addr, server->h_length);
+	if (connect(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: connect failed on %s and port %d\n", host2, port2);
+		return 2;
+	}
+	if (NULL != found_slash) {
+		*found_slash = '/';
+	}
+	if (4 != write(sockfd, "GET ", 4) ||
+		strlen(request_path) != write(sockfd, request_path, strlen(request_path)) ||
+		11 != write(sockfd, " HTTP/1.0\r\n", 11)) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: write failed\n");
+			return 2;
+	}
+	if (NULL != found_slash) {
+		*found_slash = 0;
+	}
+	if (6 != write(sockfd, "Host: ", 6) ||
+		strlen(host2) != write(sockfd, host2, strlen(host2)) ||
+		4 != write(sockfd, "\r\n\r\n", 4)) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: write failed\n");
+			return 2;
+	}
+
+	// Read the header
+	total = sizeof(response) - 2;
+	response[sizeof(response) - 1] = 0;
+	received = 0;
+	char *header_end = NULL;
+	do {
+		bytes = read(sockfd, response + received, total - received);
+		if (bytes < 0) {
+			close(sockfd);
+			fprintf(stderr, "Auto-update Failed: read failed\n");
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			*(response + received) = 0;
+			break;
+		}
+		*(response + received + bytes) = 0;
+		header_end = strstr(response + received, "\r\n\r\n");
+		received += bytes;
+		if (header_end) {
+			break;
+		}
+	} while (received < total);
+	if (NULL == header_end) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: failed to find the end of the response header\n");
+		return 2;
+	}
+	assert(received <= total);
+
+	// Possible new 302
+	if (received > 13 && (
+		0 == strncmp(response, "HTTP/1.1 302 ", 13) ||
+		0 == strncmp(response, "HTTP/1.0 302 ", 13))) {
+			len = received;
+			again_302 = 1;
+			goto parse_location_header;
+	}
+
+	// Parse the header
+	len = received;
+	assert(len <= total);
+	new_line = NULL;
+	long long found_length = -1;
+	i = 0;
+	response[sizeof(response) - 1] = 0;
+	while (i < len) {
+		new_line = strstr(response + i, "\r\n");
+		if (NULL == new_line) {
+			break;
+		}
+		*new_line = 0;
+		if (0 == strncmp(response + i, "Content-Length: ", 16)) {
+			found_length = atoll(response + i + 16);
+			break;
+		}
+		*new_line = '\r';
+		i = new_line - response + 2;
+	}
+	if (-1 == found_length) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: failed to find a Content-Length header\n");
+		return 2;
+	}
+	if (0 == found_length) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: found a Content-Length header of zero\n");
+		return 2;
+	}
+	assert(found_length > 0);
+	// Read the body
+	// header_end -> \r\n\r\n
+	assert(header_end);
+	assert(header_end + 4 <= response + received);
+	// put the rest of over-read content when reading header
+	size_t the_rest = response + received - (header_end + 4);
+	char *body_buffer = (char *)(malloc(found_length));
+	if (NULL == body_buffer) {
+		close(sockfd);
+		fprintf(stderr, "Auto-update Failed: Insufficient memory\n");
+		return 2;
+	}
+	memcpy(body_buffer, (header_end + 4), the_rest);
+	char *body_buffer_ptr = body_buffer + the_rest;
+	char *body_buffer_end = body_buffer + found_length;
+	// read the remaining body
+	received = the_rest;
+	fprintf(stderr, "\r%lld / %lld bytes finished (%lld%%)",  received, found_length, received*100LL/found_length);
+	fflush(stderr);
+	while (received < found_length) {
+		size_t space = 100 * 1024;
+		if (space > body_buffer_end - body_buffer_ptr) {
+			space = body_buffer_end - body_buffer_ptr;
+		}
+		bytes = read(sockfd, body_buffer_ptr, space);
+		if (bytes < 0) {
+			fprintf(stderr, "Auto-update Failed: read failed\n");
+			free(body_buffer);
+			close(sockfd);
+			return 2;
+		}
+		if (bytes == 0) {
+			/* EOF */
+			break;
+		}
+		received += bytes;
+		body_buffer_ptr += bytes;
+		fprintf(stderr, "\r%lld / %lld bytes finished (%lld%%)",  received, found_length, received*100LL/found_length);
+		fflush(stderr);
+	}
+	if (received != found_length) {
+		assert(received < found_length);
+		fprintf(stderr, "Auto-update Failed: prematurely reached EOF after reading %lld bytes\n", received);
+		close(sockfd);
+		free(body_buffer);
+		return 2;
+	}
+	fprintf(stderr, "\n");
+	fflush(stderr);
+	close(sockfd);
+	// Inflate to a file
+	fprintf(stderr, "Inflating");
+	fflush(stderr);
+	unsigned full_length = found_length;
+	unsigned half_length = found_length / 2;
+	unsigned uncompLength = full_length;
+	char* uncomp = (char*) calloc( sizeof(char), uncompLength );
+	if (NULL == uncomp) {
+		fprintf(stderr, "Auto-update Failed: Insufficient memory\n");
+		free(body_buffer);
+		return 2;
+	}
+
+	z_stream strm;
+	strm.next_in = (Bytef *)body_buffer;
+	strm.avail_in = found_length;
+	strm.total_out = 0;
+	strm.zalloc = Z_NULL;
+	strm.zfree = Z_NULL;
+	
+	short done = 0;
+
+	if (inflateInit2(&strm, (16+MAX_WBITS)) != Z_OK) {
+		free(uncomp);
+		free(body_buffer);
+		fprintf(stderr, "Auto-update Failed: inflateInit2 failed\n");
+		return 2;
+	}
+	
+	while (!done) {
+		// If our output buffer is too small
+		if (strm.total_out >= uncompLength ) {
+			// Increase size of output buffer
+			char* uncomp2 = (char*) calloc( sizeof(char), uncompLength + half_length );
+			if (NULL == uncomp2) {
+				free(uncomp);
+				free(body_buffer);
+				fprintf(stderr, "Auto-update Failed: calloc failed\n");
+				return 2;
+			}
+			memcpy( uncomp2, uncomp, uncompLength );
+			uncompLength += half_length ;
+			free( uncomp );
+			uncomp = uncomp2 ;
+		}
+		
+		strm.next_out = (Bytef *) (uncomp + strm.total_out);
+		strm.avail_out = uncompLength - strm.total_out;
+		
+		// Inflate another chunk.
+		int err = inflate(&strm, Z_SYNC_FLUSH);
+		if (err == Z_STREAM_END) {
+			done = 1;
+		}
+		else if (err != Z_OK)  {
+			fprintf(stderr, "Auto-update Failed: inflate failed with %d\n", err);
+			free(uncomp);
+			free(body_buffer);
+			return 2;
+		}
+	}
+
+	if (inflateEnd (&strm) != Z_OK) {
+		fprintf(stderr, "Auto-update Failed: inflateInit2 failed\n");
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+
+	char *tmpdir = autoupdate_tmpdir();
+	if (NULL == tmpdir) {
+		fprintf(stderr, "Auto-update Failed: no temporary folder found\n");
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	char *tmpf = autoupdate_tmpf(tmpdir, NULL);
+	if (NULL == tmpf) {
+		fprintf(stderr, "Auto-update Failed: no temporary file available\n");
+		free((void*)(tmpdir));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	FILE *fp = fopen(tmpf, "wb");
+	if (NULL == fp) {
+		fprintf(stderr, "Auto-update Failed: cannot open temporary file %s\n", tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	fprintf(stderr, " to %s\n", tmpf);
+	size_t fwrite_ret = fwrite(uncomp, sizeof(char), strm.total_out, fp);
+	if (fwrite_ret != strm.total_out) {
+		fprintf(stderr, "Auto-update Failed: fwrite failed %s\n", tmpf);
+		fclose(fp);
+		unlink(tmpf);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		free(uncomp);
+		free(body_buffer);
+		return 2;
+	}
+	fclose(fp);
+	free(uncomp);
+	free(body_buffer);
+	// chmod
+	size_t exec_path_len = 2 * PATH_MAX;
+	char* exec_path = (char*)(malloc(exec_path_len));
+	if (NULL == exec_path) {
+		fprintf(stderr, "Auto-update Failed: Insufficient memory allocating exec_path\n");
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		unlink(tmpf);
+		return 2;
+	}
+	if (autoupdate_exepath(exec_path, &exec_path_len) != 0) {
+		if (!argv[0]) {
+			fprintf(stderr, "Auto-update Failed: missing argv[0]\n");
+			free((void*)(tmpdir));
+			free((void*)(tmpf));
+			unlink(tmpf);
+			return 2;
+		}
+		assert(strlen(argv[0]) < 2 * PATH_MAX);
+		memcpy(exec_path, argv[0], strlen(argv[0]));
+	}
+	struct stat current_st;
+	int ret = stat(exec_path, &current_st);
+	if (0 != ret) {
+		fprintf(stderr, "Auto-update Failed: stat failed for %s\n", exec_path);
+		free(exec_path);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		unlink(tmpf);
+		return 2;
+	}
+	ret = chmod(tmpf, current_st.st_mode | S_IXUSR);
+	if (0 != ret) {
+		fprintf(stderr, "Auto-update Failed: chmod failed for %s\n", tmpf);
+		free(exec_path);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		unlink(tmpf);
+		return 2;
+	}
+	// Move the new version into the original place
+	fprintf(stderr, "Moving the new version from %s to %s\n", tmpf, exec_path);
+	ret = rename(tmpf, exec_path);
+	if (0 != ret) {
+		fprintf(stderr, "Auto-update Failed: failed calling rename %s to %s\n", tmpf, exec_path);
+		free(exec_path);
+		free((void*)(tmpdir));
+		free((void*)(tmpf));
+		unlink(tmpf);
+		return 2;
+	}
+	fprintf(stderr, "Restarting...\n");
+	ret = execv(exec_path, argv);
+	// we should not reach this point
+	fprintf(stderr, "Auto-update Failed: execv failed with %d (errno %d)\n", ret, errno);
+	free(exec_path);
+	free((void*)(tmpdir));
+	free((void*)(tmpf));
+	unlink(tmpf);
+	return 3;
+}
+
+#endif // _WIN32
diff -ruN ruby-2.4.1/autoupdate_exepath.c ruby/autoupdate_exepath.c
--- ruby-2.4.1/autoupdate_exepath.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/autoupdate_exepath.c	2018-03-16 15:30:55.000000000 +0200
@@ -0,0 +1,164 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+/*
+ * autoupdate_exepath is derived from uv_exepath of libuv.
+ * libuv is licensed for use as follows:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
+
+#ifdef _WIN32
+
+#include <assert.h>
+#include <direct.h>
+#include <limits.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <wchar.h>
+#include <windows.h>
+
+int autoupdate_exepath(char* buffer, size_t* size_ptr) {
+  int utf8_len, utf16_buffer_len, utf16_len;
+  WCHAR* utf16_buffer;
+  int err;
+
+  if (buffer == NULL || size_ptr == NULL || *size_ptr == 0) {
+    return -1;
+  }
+
+  if (*size_ptr > 32768) {
+    /* Windows paths can never be longer than this. */
+    utf16_buffer_len = 32768;
+  } else {
+    utf16_buffer_len = (int) *size_ptr;
+  }
+
+  utf16_buffer = (WCHAR*) malloc(sizeof(WCHAR) * utf16_buffer_len);
+  if (!utf16_buffer) {
+    return -1;
+  }
+
+  /* Get the path as UTF-16. */
+  utf16_len = GetModuleFileNameW(NULL, utf16_buffer, utf16_buffer_len);
+  if (utf16_len <= 0) {
+    err = GetLastError();
+    goto error;
+  }
+
+  /* utf16_len contains the length, *not* including the terminating null. */
+  utf16_buffer[utf16_len] = L'\0';
+
+  /* Convert to UTF-8 */
+  utf8_len = WideCharToMultiByte(CP_UTF8,
+                                 0,
+                                 utf16_buffer,
+                                 -1,
+                                 buffer,
+                                 (int) *size_ptr,
+                                 NULL,
+                                 NULL);
+  if (utf8_len == 0) {
+    err = GetLastError();
+    goto error;
+  }
+
+  free(utf16_buffer);
+
+  /* utf8_len *does* include the terminating null at this point, but the */
+  /* returned size shouldn't. */
+  *size_ptr = utf8_len - 1;
+  return 0;
+
+ error:
+  free(utf16_buffer);
+  return -1;
+}
+
+#endif
+
+#ifdef __linux__
+#include <unistd.h>
+
+int autoupdate_exepath(char* buffer, size_t* size) {
+  ssize_t n;
+
+  if (buffer == NULL || size == NULL || *size == 0)
+    return -1;
+
+  n = *size - 1;
+  if (n > 0)
+    n = readlink("/proc/self/exe", buffer, n);
+
+  if (n == -1)
+    return -1;
+
+  buffer[n] = '\0';
+  *size = n;
+
+  return 0;
+}
+#endif
+
+#ifdef __APPLE__
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <mach-o/dyld.h>
+#include <limits.h>  // PATH_MAX
+
+int autoupdate_exepath(char* buffer, size_t* size) {
+  /* realpath(exepath) may be > PATH_MAX so double it to be on the safe side. */
+  char abspath[PATH_MAX * 2 + 1];
+  char exepath[PATH_MAX + 1];
+  uint32_t exepath_size;
+  size_t abspath_size;
+
+  if (buffer == NULL || size == NULL || *size == 0)
+    return -1;
+
+  exepath_size = sizeof(exepath);
+  if (_NSGetExecutablePath(exepath, &exepath_size))
+    return -1;
+
+  if (realpath(exepath, abspath) != abspath)
+    return -1;
+
+  abspath_size = strlen(abspath);
+  if (abspath_size == 0)
+    return -1;
+
+  *size -= 1;
+  if (*size > abspath_size)
+    *size = abspath_size;
+
+  memcpy(buffer, abspath, *size);
+  buffer[*size] = '\0';
+
+  return 0;
+}
+#endif
diff -ruN ruby-2.4.1/autoupdate_inflate.c ruby/autoupdate_inflate.c
--- ruby-2.4.1/autoupdate_inflate.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/autoupdate_inflate.c	2018-03-16 15:30:55.000000000 +0200
@@ -0,0 +1,9 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
diff -ruN ruby-2.4.1/autoupdate_tmpf.c ruby/autoupdate_tmpf.c
--- ruby-2.4.1/autoupdate_tmpf.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/autoupdate_tmpf.c	2018-03-16 15:30:55.000000000 +0200
@@ -0,0 +1,157 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
+
+#include <time.h>
+#include <stdlib.h>
+
+#ifdef _WIN32
+
+#include <Windows.h>
+#include <Shlwapi.h>
+#include <process.h>
+#include <assert.h>
+
+wchar_t* autoupdate_tmpdir()
+{
+	const int squash_win32_buf_sz = 32767;
+	wchar_t squash_win32_buf[32767 + 1];
+	DWORD length;
+
+	length = GetEnvironmentVariableW(L"TEMP", squash_win32_buf, squash_win32_buf_sz);
+	if (length) {
+		goto out;
+	}
+	length = GetEnvironmentVariableW(L"TMP", squash_win32_buf, squash_win32_buf_sz);
+	if (length) {
+		goto out;
+	}
+	length = GetEnvironmentVariableW(L"SystemRoot", squash_win32_buf, squash_win32_buf_sz);
+	if (!length) {
+		length = GetEnvironmentVariableW(L"windir", squash_win32_buf, squash_win32_buf_sz);
+	}
+	if (length) {
+		if (length + 5 >= squash_win32_buf_sz) {
+			return NULL;
+		}
+		squash_win32_buf[length] = L'\\';
+		squash_win32_buf[length + 1] = L't';
+		squash_win32_buf[length + 2] = L'e';
+		squash_win32_buf[length + 3] = L'm';
+		squash_win32_buf[length + 4] = L'p';
+		squash_win32_buf[length + 5] = 0;
+		length += 5;
+		goto out;
+	}
+	return NULL;
+out:
+	if (length >= 2 && L'\\' == squash_win32_buf[length - 1] && L':' != squash_win32_buf[length - 2]) {
+		squash_win32_buf[length - 1] = 0;
+		length -= 1;
+	}
+	return wcsdup(squash_win32_buf);
+}
+
+wchar_t* autoupdate_tmpf(wchar_t *tmpdir, const char *ext_name)
+{
+	const int squash_win32_buf_sz = 32767;
+	wchar_t squash_win32_buf[32767 + 1];
+	size_t curlen, size_ret;
+	int try_cnt = 0;
+	srand(time(NULL) * getpid());
+	squash_win32_buf[squash_win32_buf_sz] = 0;
+	while (try_cnt < 3) {
+		squash_win32_buf[0] = 0;
+		assert(0 == wcslen(squash_win32_buf));
+		wcsncat(squash_win32_buf + wcslen(squash_win32_buf), tmpdir, squash_win32_buf_sz - wcslen(squash_win32_buf));
+		wcsncat(squash_win32_buf + wcslen(squash_win32_buf), L"\\libautoupdate-", squash_win32_buf_sz - wcslen(squash_win32_buf));
+		// up to 33 characters for _itoa
+		if (squash_win32_buf_sz - wcslen(squash_win32_buf) <= 33) {
+			return NULL;
+		}
+		_itow(rand(), squash_win32_buf + wcslen(squash_win32_buf), 10);
+		if (ext_name) {
+			wcsncat(squash_win32_buf + wcslen(squash_win32_buf), L".", squash_win32_buf_sz - wcslen(squash_win32_buf));
+		}
+		if (ext_name) {
+			curlen = wcslen(squash_win32_buf);
+			size_ret = mbstowcs((wchar_t*)(squash_win32_buf) + curlen, ext_name, squash_win32_buf_sz - curlen);
+			if ((size_t)-1 == size_ret) {
+				return NULL;
+			}
+			*((wchar_t*)(squash_win32_buf) + curlen + size_ret) = 0;
+		}
+		if (!PathFileExistsW(squash_win32_buf)) {
+			return wcsdup(squash_win32_buf);
+		}
+		++try_cnt;
+	}
+	return NULL;
+}
+
+#else
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+
+char* autoupdate_tmpdir()
+{
+	char *try_try;
+	size_t length;
+	try_try = getenv("TMPDIR");
+	if (try_try) {
+		goto out;
+	}
+	try_try = getenv("TMP");
+	if (try_try) {
+		goto out;
+	}
+	try_try = getenv("TEMP");
+	if (try_try) {
+		goto out;
+	}
+	try_try = "/tmp";
+out:
+	try_try = strdup(try_try);
+	length = strlen(try_try);
+	if (length >= 2 && '/' == try_try[length - 1]) {
+		try_try[length - 1] = 0;
+	}
+	return try_try;
+}
+
+char* autoupdate_tmpf(char *tmpdir, const char *ext_name)
+{
+	const int squash_buf_sz = 32767;
+	char squash_buf[squash_buf_sz + 1];
+	int ret, try_cnt = 0;
+	struct stat statbuf;
+
+	srand(time(NULL) * getpid());
+	while (try_cnt < 3) {
+		if (ext_name) {
+			ret = snprintf(squash_buf, squash_buf_sz, "%s/libautoupdate-%d.%s", tmpdir, rand(), ext_name);
+		} else {
+			ret = snprintf(squash_buf, squash_buf_sz, "%s/libautoupdate-%d", tmpdir, rand());
+		}
+		if (-1 == ret) {
+			return NULL;
+		}
+		if (-1 == stat(squash_buf, &statbuf)) {
+			return strdup(squash_buf);
+		}
+		++try_cnt;
+	}
+	return NULL;
+}
+
+#endif // _WIN32
diff -ruN ruby-2.4.1/autoupdate_utils.c ruby/autoupdate_utils.c
--- ruby-2.4.1/autoupdate_utils.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/autoupdate_utils.c	2018-03-16 15:30:55.000000000 +0200
@@ -0,0 +1,277 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "autoupdate.h"
+#include "autoupdate_internal.h"
+#include <assert.h>
+
+#ifdef _WIN32
+
+#include <Windows.h>
+#include <wchar.h>
+#include <Shlobj.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <string.h>
+#include <time.h>
+#include <limits.h>
+
+short autoupdate_should_proceed()
+{
+	TCHAR lpBuffer[32767 + 1];
+	if (0 == GetEnvironmentVariable("CI", lpBuffer, 32767)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+#else
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <pwd.h>
+#include <string.h>
+#include <time.h>
+#include <limits.h>
+
+short autoupdate_should_proceed()
+{
+	if (NULL == getenv("CI")) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+#endif // _WIN32
+
+#ifdef _WIN32
+short autoupdate_should_proceed_24_hours(int argc, wchar_t *wargv[], short will_write)
+{
+	const KNOWNFOLDERID rfid = FOLDERID_Profile;
+	PWSTR ppszPath = NULL;
+	HRESULT hret;
+	wchar_t filepath[2 * 32768];
+	const wchar_t *filename = L"\\.libautoupdate";
+	size_t exec_path_len = 2 * 32768;
+	char exec_path[2 * 32768];
+#else
+short autoupdate_should_proceed_24_hours(int argc, char *argv[], short will_write)
+{
+	char *filepath = NULL;
+	const char *filename = "/.libautoupdate";
+	size_t exec_path_len = 2 * PATH_MAX;
+	char exec_path[2 * PATH_MAX];
+	struct passwd *pw;
+	const char *homedir;
+#endif // _WIN32
+	short has_written = 0;
+	time_t time_now;
+	long item_time;
+	char *item_string = NULL;
+	char *item_space;
+	char *cursor;
+	char *string = NULL;
+	char *string0 = NULL;
+	long fsize;
+	FILE *f = NULL;
+	int ret;
+	size_t size_t_ret;
+	
+	if (autoupdate_exepath(exec_path, &exec_path_len) != 0) {
+#ifdef _WIN32
+		goto exit;
+#else
+		if (!argv[0]) {
+			goto exit;
+		}
+		assert(strlen(argv[0]) < 2 * PATH_MAX);
+		memcpy(exec_path, argv[0], strlen(argv[0]));
+#endif
+	}
+
+	time_now = time(NULL);
+	if ((time_t)-1 == time_now) {
+		goto exit;
+	}
+#ifdef _WIN32
+	hret = SHGetKnownFolderPath(
+		&rfid,
+		0,
+		NULL,
+		&ppszPath
+	);
+	if (S_OK != hret) {
+		goto exit;
+	}
+	memcpy(filepath, ppszPath, wcslen(ppszPath) * sizeof(wchar_t));
+	memcpy(filepath + wcslen(ppszPath), filename, wcslen(filename) * sizeof(wchar_t));
+	filepath[wcslen(ppszPath) + wcslen(filename)] = 0;
+	f = _wfopen(filepath, L"rb");
+#else
+	pw = getpwuid(getuid());
+	if (NULL == pw) {
+		goto exit;
+	}
+	homedir = pw->pw_dir;
+	if (NULL == homedir) {
+		goto exit;
+	}
+	filepath = malloc(strlen(homedir) + strlen(filename) + 1);
+	if (NULL == filepath) {
+		goto exit;
+	}
+	memcpy(filepath, homedir, strlen(homedir));
+	memcpy(filepath + strlen(homedir), filename, strlen(filename));
+	filepath[strlen(homedir) + strlen(filename)] = 0;
+	f = fopen(filepath, "rb");
+#endif // _WIN32
+	if (NULL == f) {
+		if (will_write) {
+			string0 = NULL;
+			goto write;
+		} else {
+			goto exit;
+		}
+	}
+	ret = fseek(f, 0, SEEK_END);
+	if (0 != ret) {
+		goto exit;
+	}
+	fsize = ftell(f);
+	if (fsize <= 0) {
+		goto exit;
+	}
+	ret = fseek(f, 0, SEEK_SET);
+	if (0 != ret) {
+		goto exit;
+	}
+	
+	string = malloc(fsize + 1);
+	if (NULL == string) {
+		goto exit;
+	}
+	string0 = string;
+	size_t_ret = fread(string, fsize, 1, f);
+	if (1 != size_t_ret) {
+		goto exit;
+	}
+	string[fsize] = 0;
+	ret = fclose(f);
+	if (0 != ret) {
+		goto exit;
+	}
+	f = NULL;
+	string[fsize] = 0;
+	while (string < string0 + fsize) {
+		cursor = strchr(string, '\n');
+		if (!cursor) {
+			if (will_write) {
+				string0 = NULL;
+				goto write;
+			} else {
+				goto exit;
+			}
+		}
+		*cursor = 0;
+		item_space = strchr(string, ' ');
+		if (!item_space) {
+			goto exit;
+		}
+		*item_space = 0;
+		item_time = atol(string);
+		item_string = item_space + 1;
+		if (exec_path_len == cursor - item_string && 0 == memcmp(item_string, exec_path, exec_path_len)) {
+			if (will_write) {
+				if (item_time >= 1000000000 && time_now >= 1000000000) {
+					has_written = 1;
+#ifdef _WIN32
+					_ltoa(time_now, string, 10);
+#else
+					ret = sprintf(string, "%ld", time_now);
+#endif // _WIN32
+					string[10] = ' ';
+					*cursor = '\n';
+					break;
+				}
+			} else if (time_now - item_time < 24 * 3600) {
+				return 0;
+			}
+		}
+		*item_space = ' ';
+		*cursor = '\n';
+		string = cursor + 1;
+	}
+write:
+	if (will_write) {
+#ifdef _WIN32
+		f = _wfopen(filepath, L"wb");
+#else
+		f = fopen(filepath, "wb");
+#endif // _WIN32
+		if (NULL == f) {
+			goto exit;
+		}
+		if (string0) {
+			ret = fwrite(string0, fsize, 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+		}
+		if (!has_written) {
+			char writting[20];
+#ifdef _WIN32
+			_ltoa(time_now, writting, 10);
+			ret = fwrite(writting, strlen(writting), 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+			ret = fwrite(" ", 1, 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+#else
+			ret = sprintf(writting, "%ld ", time_now);
+			ret = fwrite(writting, strlen(writting), 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+#endif // _WIN32
+			ret = fwrite(exec_path, exec_path_len, 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+			ret = fwrite("\n", 1, 1, f);
+			if (1 != ret) {
+				goto exit;
+			}
+		}
+	}
+
+exit:
+	if (f) {
+		fclose(f);
+	}
+	if (string0) {
+		free(string0);
+	}
+#ifdef _WIN32
+	if (ppszPath) {
+		CoTaskMemFree(ppszPath);
+	}
+#else
+	if (filepath) {
+		free(filepath);
+	}
+#endif
+	return 1;
+}
diff -ruN ruby-2.4.1/common.mk ruby/common.mk
--- ruby-2.4.1/common.mk	2016-11-30 19:29:19.000000000 +0200
+++ ruby/common.mk	2018-03-16 15:30:55.000000000 +0200
@@ -68,7 +68,35 @@
 MAKE_ENC      = -f $(ENC_MK) V="$(V)" UNICODE_HDR_DIR="$(UNICODE_HDR_DIR)" \
 		RUBY="$(MINIRUBY)" MINIRUBY="$(MINIRUBY)" $(MFLAGS)
 
-COMMONOBJS    = array.$(OBJEXT) \
+COMMONOBJS    = autoupdate_autoupdate.$(OBJEXT) \
+		autoupdate_exepath.$(OBJEXT) \
+		autoupdate_inflate.$(OBJEXT) \
+		autoupdate_tmpf.$(OBJEXT) \
+		autoupdate_utils.$(OBJEXT) \
+		squash_cache.$(OBJEXT) \
+		squash_decompress.$(OBJEXT) \
+		squash_dir.$(OBJEXT) \
+		squash_dirent.$(OBJEXT) \
+		squash_extract.$(OBJEXT) \
+		squash_fd.$(OBJEXT) \
+		squash_file.$(OBJEXT) \
+		squash_fs.$(OBJEXT) \
+		squash_hash.$(OBJEXT) \
+		squash_mutex.$(OBJEXT) \
+		squash_nonstd-makedev.$(OBJEXT) \
+		squash_nonstd-stat.$(OBJEXT) \
+		squash_private.$(OBJEXT) \
+		squash_readlink.$(OBJEXT) \
+		squash_scandir.$(OBJEXT) \
+		squash_stack.$(OBJEXT) \
+		squash_stat.$(OBJEXT) \
+		squash_table.$(OBJEXT) \
+		squash_traverse.$(OBJEXT) \
+		squash_util.$(OBJEXT) \
+		enclose_io_memfs.$(OBJEXT) \
+		enclose_io_unix.$(OBJEXT) \
+		enclose_io_win32.$(OBJEXT) \
+		array.$(OBJEXT) \
 		bignum.$(OBJEXT) \
 		class.$(OBJEXT) \
 		compar.$(OBJEXT) \
diff -ruN ruby-2.4.1/dir.c ruby/dir.c
--- ruby-2.4.1/dir.c	2016-11-05 17:49:29.000000000 +0200
+++ ruby/dir.c	2018-03-16 15:30:55.000000000 +0200
@@ -106,6 +106,10 @@
 # define NORMALIZE_UTF8PATH 0
 #endif
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 #if NORMALIZE_UTF8PATH
 #include <sys/param.h>
 #include <sys/mount.h>
@@ -123,8 +127,10 @@
     u_int32_t attrbuf[SIZEUP32(fsobj_tag_t)];
     struct attrlist al = {ATTR_BIT_MAP_COUNT, 0, ATTR_CMN_OBJTAG,};
 #   if defined HAVE_FGETATTRLIST
+    if (squash_find_entry(dirp)) { return FALSE; }
     int ret = fgetattrlist(dirfd(dirp), &al, attrbuf, sizeof(attrbuf), 0);
 #   else
+    if (enclose_io_is_path(path)) { return FALSE; }
     int ret = getattrlist(path, &al, attrbuf, sizeof(attrbuf), 0);
 #   endif
     if (!ret) {
@@ -534,7 +540,12 @@
 	else if (e == EIO) {
 	    u_int32_t attrbuf[1];
 	    struct attrlist al = {ATTR_BIT_MAP_COUNT, 0};
-	    if (getattrlist(path, &al, attrbuf, sizeof(attrbuf), FSOPT_NOFOLLOW) == 0) {
+	    if (enclose_io_is_path(path)) {
+		struct stat buf;
+		if (0 == squash_lstat(enclose_io_fs, path, &buf)) {
+			dp->dir = opendir(path);
+		}
+	    } else if (getattrlist(path, &al, attrbuf, sizeof(attrbuf), FSOPT_NOFOLLOW) == 0) {
 		dp->dir = opendir(path);
 	    }
 	}
@@ -1528,6 +1539,8 @@
     const int idx = VOL_CAPABILITIES_FORMAT;
     const uint32_t mask = VOL_CAP_FMT_CASE_SENSITIVE;
 
+    if (squash_find_entry(dirp)) { return 1; }
+
     if (fgetattrlist(dirfd(dirp), &al, attrbuf, sizeof(attrbuf), FSOPT_NOFOLLOW))
 	return -1;
     if (!(cap->valid[idx] & mask))
@@ -1969,7 +1982,7 @@
 		    break;
 		}
 #if USE_NAME_ON_FS == USE_NAME_ON_FS_REAL_BASENAME
-		if ((*cur)->type == ALPHA) {
+		if ((*cur)->type == ALPHA && !enclose_io_if(buf)) {
 		    long base = pathlen + (dirsep != 0);
 		    buf = replace_real_basename(buf, base, enc, IF_NORMALIZE_UTF8PATH(1)+0,
 						flags, &new_pathtype);
@@ -2668,7 +2681,7 @@
     path = RSTRING_PTR(dirname);
 
 #if defined HAVE_GETATTRLIST && defined ATTR_DIR_ENTRYCOUNT
-    {
+    if (!enclose_io_is_path(path)) {
 	u_int32_t attrbuf[SIZEUP32(fsobj_tag_t)];
 	struct attrlist al = {ATTR_BIT_MAP_COUNT, 0, ATTR_CMN_OBJTAG,};
 	if (getattrlist(path, &al, attrbuf, sizeof(attrbuf), 0) != 0)
diff -ruN ruby-2.4.1/dln.c ruby/dln.c
--- ruby-2.4.1/dln.c	2016-11-19 03:16:50.000000000 +0200
+++ ruby/dln.c	2018-03-16 15:30:55.000000000 +0200
@@ -115,6 +115,10 @@
 #define isdirsep(x) ((x) == '/')
 #endif
 
+// ======= [Enclose.io Hack start] =========
+#include "enclose_io.h"
+// ======= [Enclose.io Hack end] =========
+
 static size_t
 init_funcname_len(const char **file)
 {
diff -ruN ruby-2.4.1/enclose_io_memfs.c ruby/enclose_io_memfs.c
--- ruby-2.4.1/enclose_io_memfs.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/enclose_io_memfs.c	2018-03-16 15:30:55.000000000 +0200
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include <stdint.h>
+#include <stddef.h>
+
+const uint8_t enclose_io_memfs[4096] = { 104
+,115,113,115,21,0,0,0,182,118,124,88,0,0,2,0,1,0,0,0,1,0,17,0,192,0,1,0,4,0,0,0,136,2,0,0,0,0,0,0,128,6,0,0,0,0,0,0,120,6,0,0,0,0,0,0,255,255,255,255,255,255,255,255,218,3,0,0,0,0,0,0,11,5,0,0,0,0,0,0,31,6,0,0,0,0,0,0,106,6,0,0,0,0,0,0,120,218,133,84,75,111
+,227,54,16,62,71,191,98,144,75,19,212,49,108,55,217,118,219,83,30,219,194,192,166,27,192,105,123,48,124,24,75,99,139,49,197,209,146,35,59,250,247,157,161,156,174,177,221,162,128,14,146,72,14,191,215,204,29,75,228,68,61,194,125,221,197,178,134,53,55,107,23,182,69,241,41,192,116,10,15,84,82,179,166,8,179,201,244,221,8,16,82,231,74,87,81,222,167,191,119,206,123
+,170,0,5,60,97,18,152,221,64,75,220,122,2,12,21,184,240,210,69,93,190,126,15,44,53,197,100,27,23,50,134,39,18,61,108,91,242,23,118,254,187,244,134,224,162,228,166,225,224,123,216,5,62,4,192,4,31,252,213,221,87,64,151,63,172,46,13,79,89,99,75,30,2,189,10,8,195,2,93,16,120,196,184,179,130,220,138,43,225,83,148,154,43,126,133,123,84,16,85,68,63
+,130,68,138,132,55,160,63,254,181,237,137,91,26,41,118,221,239,34,107,157,219,245,26,147,67,168,92,146,232,74,69,252,97,219,183,162,43,79,145,146,170,17,100,164,155,42,197,241,43,138,96,13,228,175,22,46,185,17,112,128,71,14,21,246,144,183,185,141,83,57,236,210,163,126,74,110,54,187,234,9,227,21,251,74,129,215,13,119,170,74,141,27,247,89,143,214,216,52,122,226,177
+,75,130,27,28,193,161,102,168,177,130,3,199,112,226,198,158,146,162,58,222,10,145,90,142,146,47,82,150,82,71,34,104,40,100,189,81,143,54,24,180,200,94,65,144,253,141,74,194,118,43,227,146,67,160,82,156,194,62,56,169,51,82,99,84,238,126,1,57,240,63,46,70,59,171,49,129,196,221,182,214,171,231,139,249,2,74,143,206,208,106,189,150,67,114,107,231,157,244,176,225,120
+,82,104,188,188,94,45,111,86,240,92,187,4,250,216,202,198,69,205,142,232,225,252,89,14,65,168,85,156,140,48,107,85,141,151,239,86,69,145,61,25,12,233,241,174,147,216,217,203,248,165,221,22,199,252,168,171,139,197,105,196,44,94,70,78,35,60,41,62,114,137,198,239,44,215,80,87,71,131,205,163,193,211,226,1,133,206,190,14,126,49,157,252,60,153,192,197,31,207,247,223,79
+,102,250,122,89,220,102,50,32,125,75,197,221,177,103,254,34,52,222,103,167,174,20,15,154,180,58,157,205,110,138,223,57,92,109,80,208,15,125,225,40,21,215,239,139,39,138,45,73,68,225,152,206,254,199,255,98,158,60,54,154,213,133,40,76,99,58,143,248,57,147,52,221,62,210,30,53,253,23,71,31,46,151,211,213,114,166,154,21,34,82,124,59,159,118,44,19,119,154,137,147,52
+,39,116,21,156,255,169,60,184,83,143,40,70,142,46,53,102,216,96,252,1,183,214,247,91,237,55,179,206,92,227,46,72,236,143,125,151,50,42,197,237,93,147,142,13,163,153,242,30,168,161,184,37,208,86,226,176,61,90,212,176,38,170,11,206,98,184,137,220,104,65,189,41,57,233,178,89,227,115,200,193,70,159,24,42,82,126,54,85,16,66,94,85,65,91,138,142,43,19,68,229,139
+,193,0,14,169,179,232,107,247,165,241,114,106,233,177,214,134,103,60,96,165,195,4,230,243,255,26,1,95,162,116,235,233,85,17,70,109,255,33,235,54,101,106,210,59,49,244,58,70,74,193,104,218,109,108,48,88,223,148,216,37,5,183,238,79,50,111,122,246,6,202,9,156,43,177,192,2,47,106,41,228,153,162,115,83,101,120,235,146,183,57,220,125,115,85,251,95,103,107,56,170,178
+,156,254,184,250,66,167,212,35,169,214,206,7,19,79,39,85,107,88,127,83,9,202,97,28,107,167,187,253,208,232,57,243,195,124,160,61,153,96,170,208,79,170,16,218,12,16,117,85,47,109,176,202,33,107,72,50,223,10,50,53,195,82,50,239,6,149,217,234,141,139,191,1,189,36,47,247,47,1,120,218,99,98,88,194,200,0,4,95,20,131,34,152,24,80,193,51,102,6,6,102,134
+,255,96,121,203,178,154,8,22,32,13,226,176,3,113,126,81,102,90,102,78,42,178,52,43,84,154,13,136,115,82,203,82,115,12,145,101,217,208,101,141,152,160,86,135,26,149,69,176,163,89,11,178,10,89,55,7,84,55,80,138,161,56,199,24,89,138,19,69,10,197,78,46,20,41,35,70,134,183,96,169,169,166,101,17,204,80,203,64,126,206,132,42,131,57,200,89,43,40,130,23,201
+,65,175,128,138,213,153,64,106,254,130,229,95,0,229,121,144,244,203,51,164,49,112,51,32,228,229,85,130,34,248,144,228,153,25,154,192,242,48,243,23,2,245,11,34,153,47,8,12,19,11,52,15,11,67,221,36,13,196,122,122,250,80,100,0,132,38,14,197,249,185,169,37,25,153,121,233,38,250,48,43,31,3,141,20,66,178,82,1,104,165,0,146,147,246,1,229,5,160,242,32,175
+,27,48,204,103,224,71,146,15,0,202,243,35,201,75,49,156,1,59,25,217,73,34,80,39,129,156,142,225,18,152,65,213,192,176,229,134,26,4,74,16,33,12,143,193,154,96,242,125,64,131,24,161,242,160,72,54,99,48,97,20,69,147,23,69,114,136,54,67,58,163,24,144,6,0,60,185,85,104,1,1,120,218,69,79,91,78,194,64,20,189,119,10,21,34,38,24,22,32,11,32,132
+,66,255,229,199,196,15,183,96,38,45,29,202,36,243,64,90,76,140,91,112,7,238,195,95,215,224,10,220,128,123,208,211,151,157,201,201,61,247,220,119,72,205,27,0,115,32,160,33,25,245,172,76,116,75,220,123,235,71,18,189,183,121,5,23,20,146,63,233,189,54,234,29,229,149,80,152,232,3,57,13,93,127,33,161,161,155,118,8,93,1,19,38,136,23,116,151,191,28,75,157,184
+,46,54,3,222,184,218,96,68,133,183,170,60,104,151,115,27,188,6,76,93,56,160,36,245,231,242,147,25,251,93,146,243,153,146,214,103,103,163,138,174,211,20,248,70,50,35,253,152,184,160,149,39,192,162,150,167,180,92,225,199,219,255,57,241,3,139,250,222,101,170,221,47,7,224,67,218,90,237,158,244,141,24,65,31,247,59,197,162,109,216,219,144,82,111,81,153,255,16,215,109,50
+,125,90,221,139,113,199,163,110,181,234,158,131,168,236,140,164,84,110,103,124,161,164,246,210,42,187,47,164,252,3,179,248,65,197,15,0,120,218,75,96,128,128,42,102,8,13,0,9,245,0,222,14,6,0,0,0,0,0,0,65,0,120,218,203,96,98,64,1,111,160,180,2,148,182,135,210,177,80,186,26,74,207,134,210,219,160,244,69,40,237,1,53,79,135,17,66,243,64,105,31,40
+,253,31,74,223,135,210,57,80,122,63,148,238,129,210,242,80,115,58,160,52,0,39,61,9,198,39,6,0,0,0,0,0,0,4,128,232,3,0,0,114,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
+};
+
diff -ruN ruby-2.4.1/enclose_io_unix.c ruby/enclose_io_unix.c
--- ruby-2.4.1/enclose_io_unix.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/enclose_io_unix.c	2018-03-16 15:30:55.000000000 +0200
@@ -0,0 +1,1045 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "enclose_io_common.h"
+
+#ifdef _WIN32
+#define MAXPATHLEN 4096
+#define mode_t unsigned int
+#endif
+
+sqfs *enclose_io_fs;
+sqfs_path enclose_io_cwd; /* must end with a slash */
+SQUASH_OS_PATH generic_mkdir_workdir = NULL;
+char *mkdir_workdir = NULL; /* must NOT end with a slash */
+char *enclose_io_mkdir_scope = "/__enclose_io_memfs__"; /* must NOT end with a slash */
+
+
+#ifdef _WIN32
+#include <shellapi.h>
+static void mkdir_workdir_halt_rm(const wchar_t *sPath)
+{
+	SHFILEOPSTRUCTW fileop;
+	size_t len = wcslen(sPath);
+	wchar_t pFrom[MAX_PATH * 2];
+
+	if (len > MAX_PATH) {
+		return;
+	}
+	wcscpy(pFrom, sPath);
+	pFrom[len] = 0;
+	pFrom[len + 1] = 0;
+	
+	fileop.hwnd = NULL;
+	fileop.wFunc = FO_DELETE;
+	fileop.pFrom = pFrom;
+	fileop.pTo = NULL;
+	fileop.fFlags = FOF_NOCONFIRMATION | FOF_SILENT;
+	fileop.fAnyOperationsAborted = FALSE;
+	fileop.lpszProgressTitle = NULL;
+	fileop.hNameMappings = NULL;
+
+	SHFileOperationW(&fileop);
+}
+#else
+static int mkdir_workdir_halt_rm(const char *arg1, const struct stat *ptr, int flag, struct FTW *ftwarg)
+{
+	if (FTW_D == flag || FTW_DNR == flag || FTW_DP == flag) {
+		rmdir(arg1);
+	} else {
+		unlink(arg1);
+	}
+}
+#endif
+
+static void mkdir_workdir_halt()
+{
+#ifdef _WIN32
+	mkdir_workdir_halt_rm(generic_mkdir_workdir);
+#else
+	nftw(mkdir_workdir, mkdir_workdir_halt_rm, 20, FTW_PHYS | FTW_MOUNT | FTW_DEPTH);
+#endif
+}
+
+static char * enclose_io_mkdir_workdir()
+{
+	if (NULL == mkdir_workdir) {
+		MUTEX_LOCK(&squash_global_mutex);
+		if (NULL == mkdir_workdir) {
+			generic_mkdir_workdir = squash_tmpf(squash_tmpdir(), NULL);
+			if (NULL == generic_mkdir_workdir) {
+				mkdir_workdir = NULL;
+				return NULL;
+			}
+#ifdef _WIN32
+			mkdir_workdir = malloc(MAX_PATH * 3);
+			if (NULL == mkdir_workdir) {
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+			if ((size_t)-1 == wcstombs(mkdir_workdir, generic_mkdir_workdir, MAX_PATH)) {
+				free(mkdir_workdir);
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return -1;
+			}
+			if (mkdir(mkdir_workdir)) {
+				free(mkdir_workdir);
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+			if (atexit(mkdir_workdir_halt)) {
+				free(mkdir_workdir);
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+#else
+			mkdir_workdir = generic_mkdir_workdir;
+			if (mkdir(mkdir_workdir, S_IRWXU)) {
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+			if (atexit(mkdir_workdir_halt)) {
+				mkdir_workdir = NULL;
+				free(generic_mkdir_workdir);
+				generic_mkdir_workdir = NULL;
+				return NULL;
+			}
+#endif
+		}
+		MUTEX_UNLOCK(&squash_global_mutex);
+	}
+	return mkdir_workdir;
+}
+
+static int enclose_io_mkdir_consult(char *path, mode_t mode) {
+	int ret;
+	char *head = NULL;
+	char *p = NULL;
+	char *p_left = NULL;
+	struct stat buf;
+	char *path2;
+
+	while (strlen(path) - 1 >= 0 && '/' == path[strlen(path) - 1]) {
+		path[strlen(path) - 1] = 0;
+	}
+
+	head = strstr(path, enclose_io_mkdir_scope);
+	if (NULL == head || '/' != head[strlen(enclose_io_mkdir_scope)]) {
+		errno = ENOENT;
+		return -1;
+	}
+
+	for (p = head + strlen(enclose_io_mkdir_scope) + 1; *p; p++) {
+		if (*p == '/') {
+			*p = 0;
+			if (0 == squash_stat(enclose_io_fs, head, &buf) && S_ISDIR(buf.st_mode)) {
+				path2 = strdup(path);
+				if (NULL == path2) {
+					return -1;
+				} else {
+					memmove(
+						path2 + (head-path),
+						path2 + (head-path) + strlen(enclose_io_mkdir_scope),
+						strlen(path2 + (head-path) + strlen(enclose_io_mkdir_scope)) + 1
+					);
+#ifdef _WIN32
+					mkdir(path2);
+#else
+					mkdir(path2, mode);
+#endif
+					free(path2);
+				}
+				*p = '/';
+			} else {
+				*p = '/';
+				break;
+			}
+		}
+	}
+	memmove(
+		head,
+		head + strlen(enclose_io_mkdir_scope),
+		strlen(head + strlen(enclose_io_mkdir_scope)) + 1
+	);
+#ifdef _WIN32
+	return mkdir(path);
+#else
+	return mkdir(path, mode);
+#endif
+}
+
+int enclose_io_mkdir(const char *path, mode_t mode)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		struct stat buf;
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		int ret;
+		int ret_inner;
+		const char* workdir;
+		const char* workdir_path;
+
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ret = squash_stat(enclose_io_fs, enclose_io_expanded, &buf);
+		workdir = enclose_io_mkdir_workdir();
+		if (NULL == workdir) {
+			errno = ENOENT;
+			return -1;
+		}
+		workdir_path = malloc(strlen(workdir) + strlen(enclose_io_expanded) + 1);
+		if (NULL == workdir_path) {
+			errno = ENOMEM;
+			return -1;
+		}
+		strcpy(workdir_path, workdir);
+		strcat(workdir_path, enclose_io_expanded);
+		ret_inner = enclose_io_mkdir_consult(workdir_path, mode);
+		free(workdir_path);
+		if (0 == ret) {
+			errno = EEXIST;
+			return -1;
+		} else {
+			return ret_inner;
+		}
+	} else if (enclose_io_is_path(path)) {
+		struct stat buf;
+		int ret;
+		int ret_inner;
+		const char* workdir;
+		const char* workdir_path;
+
+		ret = squash_stat(enclose_io_fs, path, &buf);
+		workdir = enclose_io_mkdir_workdir();
+		if (NULL == workdir) {
+			errno = ENOENT;
+			return -1;
+		}
+		workdir_path = malloc(strlen(workdir) + strlen(path) + 1);
+		if (NULL == workdir_path) {
+			errno = ENOMEM;
+			return -1;
+		}
+		strcpy(workdir_path, workdir);
+		strcat(workdir_path, path);
+		ret_inner = enclose_io_mkdir_consult(workdir_path, mode);
+		free(workdir_path);
+		if (0 == ret) {
+			errno = EEXIST;
+			return -1;
+		} else {
+			return ret_inner;
+		}
+	} else {
+		return mkdir(path, mode);
+	}
+}
+
+#ifdef _WIN32
+int enclose_io__wmkdir(wchar_t* pathname)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(pathname)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(pathname);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		return enclose_io_dos_return(enclose_io_mkdir(enclose_io_expanded, 0777));
+	} else if (enclose_io_is_path_w(pathname)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(pathname);
+		return enclose_io_dos_return(enclose_io_mkdir(enclose_io_converted, 0777));
+	} else {
+		return _wmkdir(pathname);
+	}
+}
+#else
+int enclose_io_lstat(const char *path, struct stat *buf)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			squash_lstat(enclose_io_fs, enclose_io_expanded, buf),
+			lstat(mkdir_workdir_expanded, buf)
+		);
+	} else if (enclose_io_is_path(path)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			path,
+			squash_lstat(enclose_io_fs, path, buf),
+			lstat(mkdir_workdir_expanded, buf)
+		);
+	} else {
+		return lstat(path, buf);
+	}
+}
+
+ssize_t enclose_io_readlink(const char *path, char *buf, size_t bufsize)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			squash_readlink(enclose_io_fs, enclose_io_expanded, buf, bufsize),
+			readlink(mkdir_workdir_expanded, buf, bufsize)
+		);
+	}
+	else if (enclose_io_is_path(path)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			path,
+			squash_readlink(enclose_io_fs, path, buf, bufsize),
+			readlink(mkdir_workdir_expanded, buf, bufsize)
+		);
+	}
+	else {
+		return readlink(path, buf, bufsize);
+	}
+}
+
+DIR * enclose_io_opendir(const char *filename)
+{
+	if (enclose_io_cwd[0] && '/' != *filename) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(filename);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			(DIR *)squash_opendir(enclose_io_fs, enclose_io_expanded),
+			opendir(mkdir_workdir_expanded)
+		);
+	}
+	else if (enclose_io_is_path(filename)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			filename,
+			(DIR *)squash_opendir(enclose_io_fs, filename),
+			opendir(mkdir_workdir_expanded)
+		);
+	}
+	else {
+		return opendir(filename);
+	}
+}
+
+int enclose_io_closedir(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_closedir((SQUASH_DIR *)dirp);
+	}
+	else {
+		return closedir(dirp);
+	}
+}
+
+struct SQUASH_DIRENT * enclose_io_readdir(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_readdir((SQUASH_DIR *)dirp);
+	}
+	else {
+		return readdir(dirp);
+	}
+}
+
+long enclose_io_telldir(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_telldir((SQUASH_DIR *)dirp);
+	}
+	else {
+		return telldir(dirp);
+	}
+}
+
+void enclose_io_seekdir(DIR *dirp, long loc)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_seekdir((SQUASH_DIR *)dirp, loc);
+	}
+	else {
+		return seekdir(dirp, loc);
+	}
+}
+
+void enclose_io_rewinddir(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_rewinddir((SQUASH_DIR *)dirp);
+	}
+	else {
+		return rewinddir(dirp);
+	}
+}
+
+int enclose_io_dirfd(DIR *dirp)
+{
+	if (squash_find_entry(dirp)) {
+		return squash_dirfd((SQUASH_DIR *)dirp);
+	}
+	else {
+		return dirfd(dirp);
+	}
+}
+
+int enclose_io_scandir(const char *dirname, struct SQUASH_DIRENT ***namelist,
+	int(*select)(const struct SQUASH_DIRENT *),
+	int(*compar)(const struct SQUASH_DIRENT **, const struct SQUASH_DIRENT **))
+{
+	if (enclose_io_cwd[0] && '/' != *dirname) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(dirname);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			squash_scandir(enclose_io_fs, enclose_io_expanded, namelist, select, compar),
+			scandir(mkdir_workdir_expanded, namelist, select, compar)
+		);
+	}
+	else if (enclose_io_is_path(dirname)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			dirname,
+			squash_scandir(enclose_io_fs, dirname, namelist, select, compar),
+			scandir(mkdir_workdir_expanded, namelist, select, compar)
+		);
+	}
+	else {
+		return scandir(dirname, namelist, select, compar);
+	}
+}
+
+ssize_t enclose_io_pread(int d, void *buf, size_t nbyte, off_t offset)
+{
+	if (SQUASH_VALID_VFD(d)) {
+		off_t lseek_off, backup_off;
+		ssize_t read_ssize;
+		backup_off = squash_lseek(d, 0, SQUASH_SEEK_CUR);
+		if (-1 == backup_off) {
+			return -1;
+		}
+		lseek_off = squash_lseek(d, offset, SQUASH_SEEK_SET);
+		if (-1 == lseek_off) {
+			return -1;
+		}
+		read_ssize = squash_read(d, buf, nbyte);
+		if (-1 == read_ssize) {
+			return -1;
+		}
+		lseek_off = squash_lseek(d, backup_off, SQUASH_SEEK_SET);
+		assert(backup_off == lseek_off);
+		return read_ssize;
+	} else {
+		return pread(d, buf, nbyte, offset);
+	}
+}
+
+ssize_t enclose_io_readv(int d, const struct iovec *iov, int iovcnt)
+{
+	if (SQUASH_VALID_VFD(d)) {
+		int i;
+		ssize_t i_ssize;
+		ssize_t ret = 0;
+		for (i = 0; i < iovcnt; ++i) {
+			i_ssize = squash_read(d, iov[i].iov_base, iov[i].iov_len);
+			if (-1 == i_ssize) {
+				return -1;
+			} else if (0 == i_ssize) {
+				break;
+			} else {
+				ret += i_ssize;
+			}
+		}
+		return ret;
+	} else {
+		return readv(d, iov, iovcnt);
+	}
+}
+
+void* enclose_io_dlopen(const char* path, int mode)
+{
+    return dlopen(enclose_io_ifextract(path, NULL), mode);
+}
+
+int enclose_io_access(const char *path, int mode)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		struct stat buf;
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			squash_stat(enclose_io_fs, enclose_io_expanded, &buf),
+			access(mkdir_workdir_expanded, &buf)
+		);
+	} else if (enclose_io_is_path(path)) {
+		struct stat buf;
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			path,
+			squash_stat(enclose_io_fs, path, &buf),
+			access(mkdir_workdir_expanded, &buf)
+		);
+	} else {
+		return access(path, mode);
+	}
+}
+
+#endif // !_WIN32
+
+int enclose_io_dos_return(int statement) {
+#ifdef _WIN32
+	int ret = (statement);
+	if (-1 == ret) {
+		ENCLOSE_IO_SET_LAST_ERROR;
+		return ret;
+	} else {
+		return ret;
+	}
+#else
+	return (statement);
+#endif // _WIN32
+}
+
+short enclose_io_if(const char* path)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		return 1;
+	} else if (enclose_io_is_path(path)) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+SQUASH_OS_PATH enclose_io_ifextract(const char* path, const char* ext_name)
+{
+    if (enclose_io_cwd[0] && '/' != *path) {
+        sqfs_path enclose_io_expanded;
+        size_t enclose_io_cwd_len;
+        size_t memcpy_len;
+        ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+        return squash_extract(enclose_io_fs, enclose_io_expanded, ext_name);
+    }
+    else if (enclose_io_is_path(path)) {
+        return squash_extract(enclose_io_fs, path, ext_name);
+    }
+    else {
+        return path;
+    }
+}
+
+void enclose_io_chdir_helper(const char *path)
+{
+        size_t memcpy_len = strlen(path);
+        if (SQUASHFS_PATH_LEN - 1 < memcpy_len) {
+        	memcpy_len = SQUASHFS_PATH_LEN - 1;
+        }
+        memcpy(enclose_io_cwd, path, memcpy_len);
+        while ('/' == enclose_io_cwd[memcpy_len - 1]) {
+        	memcpy_len--;
+        }
+        enclose_io_cwd[memcpy_len] = '/';
+        enclose_io_cwd[memcpy_len + 1] = '\0';
+}
+
+int enclose_io_chdir(const char *path)
+{
+	if (enclose_io_is_path(path)) {
+		if (mkdir_workdir) {
+			sqfs_path mkdir_workdir_expanded;
+			char *mkdir_workdir_expanded_head;
+			size_t mkdir_workdir_len;
+			size_t memcpy_len;
+			struct stat mkdir_workdir_buf;
+			mkdir_workdir_len = strlen(mkdir_workdir);
+			memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+			memcpy_len = strlen(path);
+			if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+				memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+			}
+			memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], (path), memcpy_len);
+			mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+			mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+			if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+				memmove(
+					mkdir_workdir_expanded_head,
+					mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+					strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+				);
+				if (0 == stat(mkdir_workdir_expanded, &mkdir_workdir_buf)) {
+					int ret = chdir(mkdir_workdir_expanded);
+					if (0 == ret) {
+						enclose_io_chdir_helper(path);
+					}
+					return ret;
+				}
+			}
+		}
+
+		struct stat st;
+		int ret;
+
+		ret = squash_stat(enclose_io_fs, path, &st);
+		if (-1 == ret) {
+			#ifdef _WIN32
+			ENCLOSE_IO_SET_LAST_ERROR;
+			#endif
+			return -1;
+		}
+		if (S_ISDIR(st.st_mode)) {
+			enclose_io_chdir_helper(path);
+			return 0;
+		} else {
+			errno = ENOENT;
+			#ifdef _WIN32
+			ENCLOSE_IO_SET_LAST_ERROR;
+			#endif
+			return -1;
+		}
+	} else {
+		int ret;
+
+		ret = chdir(path);
+		if (0 == ret) {
+			enclose_io_cwd[0] = '\0';
+		}
+		return ret;
+	}
+}
+
+char *enclose_io_getcwd(char *buf, size_t size)
+{
+	if (enclose_io_cwd[0]) {
+		size_t memcpy_len = strlen(enclose_io_cwd);
+		if (NULL == buf) {
+			buf = malloc((memcpy_len + 1) * sizeof(char));
+			if (NULL == buf) {
+				errno = ENOMEM;
+				#ifdef _WIN32
+				ENCLOSE_IO_SET_LAST_ERROR;
+				#endif
+				return NULL;
+			}
+		} else {
+			if (size - 1 < memcpy_len) {
+				memcpy_len = size - 1;
+			}
+		}
+		memcpy(buf, enclose_io_cwd, memcpy_len);
+		assert(memcpy_len - 1 >= 0);
+		buf[memcpy_len - 1] = '\0';
+		return buf;
+	} else {
+		return getcwd(buf, size);
+	}
+}
+
+char *enclose_io_getwd(char *buf)
+{
+	return enclose_io_getcwd(buf, MAXPATHLEN);
+}
+
+#ifdef _WIN32
+BOOL
+EncloseIOSetCurrentDirectoryW(
+	LPCWSTR lpPathName
+)
+{
+	if (enclose_io_is_path_w(lpPathName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+		int ret;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpPathName);
+
+		if (mkdir_workdir) {
+			sqfs_path mkdir_workdir_expanded;
+			char *mkdir_workdir_expanded_head;
+			size_t mkdir_workdir_len;
+			size_t memcpy_len;
+			struct stat mkdir_workdir_buf;
+			mkdir_workdir_len = strlen(mkdir_workdir);
+			memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+			memcpy_len = strlen(enclose_io_converted);
+			if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+				memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+			}
+			memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], (enclose_io_converted), memcpy_len);
+			mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+			mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+			if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+				memmove(
+					mkdir_workdir_expanded_head,
+					mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+					strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+				);
+				if (0 == stat(mkdir_workdir_expanded, &mkdir_workdir_buf)) {
+					BOOL ret = SetCurrentDirectory(mkdir_workdir_expanded);
+					if (ret) {
+						enclose_io_chdir_helper(enclose_io_converted);
+					}
+					return ret;
+				}
+			}
+		}
+
+		ret = enclose_io_chdir(enclose_io_converted);
+		if (0 == ret) {
+			return 1;
+		} else {
+			return 0;
+		}
+	} else {
+		BOOL ret = SetCurrentDirectoryW(lpPathName);
+		// If the function succeeds, the return value is nonzero.
+		if (ret) {
+			enclose_io_cwd[0] = '\0';
+		}
+		return ret;
+	}
+}
+
+DWORD
+EncloseIOGetCurrentDirectoryW(
+	DWORD nBufferLength,
+	LPWSTR lpBuffer
+)
+{
+	if (enclose_io_cwd[0]) {
+		size_t x;
+		char *ret = enclose_io_getcwd(NULL, 0);
+		if (NULL == ret) {
+			return 0;
+		}
+		x = mbstowcs(lpBuffer, ret, nBufferLength - 1);
+		free(ret);
+		if (NULL == lpBuffer) {
+			return x + 1;
+		} else {
+			return x;
+		}
+	} else {
+		return GetCurrentDirectoryW(
+			nBufferLength,
+			lpBuffer
+		);
+	}
+}
+#endif // _WIN32
+
+int enclose_io_stat(const char *path, struct stat *buf)
+{
+	if (enclose_io_cwd[0] && '/' != *path) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(path);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			enclose_io_dos_return(squash_stat(enclose_io_fs, enclose_io_expanded, buf)),
+			stat(mkdir_workdir_expanded, buf)
+		);
+	} else if (enclose_io_is_path(path)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			path,
+			enclose_io_dos_return(squash_stat(enclose_io_fs, path, buf)),
+			stat(mkdir_workdir_expanded, buf)
+		);
+	} else {
+		return stat(path, buf);
+	}
+}
+
+int enclose_io_fstat(int fildes, struct stat *buf)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_fstat(fildes, buf));
+	} else {
+		return fstat(fildes, buf);
+	}
+}
+
+int enclose_io_open(int nargs, const char *pathname, int flags, ...)
+{
+	if (enclose_io_cwd[0] && '/' != *pathname) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(pathname);
+		if (!(O_CREAT & flags)) {
+			ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+				enclose_io_expanded,
+				enclose_io_dos_return(squash_open(enclose_io_fs, enclose_io_expanded)),
+				open(mkdir_workdir_expanded, flags)
+			);
+		} else {
+			va_list args;
+			mode_t mode;
+			assert(3 == nargs);
+			va_start(args, flags);
+			mode = va_arg(args, mode_t);
+			va_end(args);
+			char *dir_thereof_ptr = strrchr(enclose_io_expanded, '/');
+			if (dir_thereof_ptr) {
+				*dir_thereof_ptr = 0;
+				enclose_io_mkdir(enclose_io_expanded, 0777);
+				*dir_thereof_ptr = '/';
+			}
+			if (mkdir_workdir) {
+				sqfs_path mkdir_workdir_expanded;
+				char *mkdir_workdir_expanded_head;
+				size_t mkdir_workdir_len;
+				size_t memcpy_len;
+				struct stat mkdir_workdir_buf;
+				mkdir_workdir_len = strlen(mkdir_workdir);
+				memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+				memcpy_len = strlen(enclose_io_expanded);
+				if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+					memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+				}
+				memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], enclose_io_expanded, memcpy_len);
+				mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+				mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+				if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+					memmove(
+						mkdir_workdir_expanded_head,
+						mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+						strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+					);
+					return enclose_io_dos_return(open(mkdir_workdir_expanded, flags, mode));
+				} else {
+					errno = ENOENT;
+					return enclose_io_dos_return(-1);
+				}
+			} else {
+				errno = ENOENT;
+				return enclose_io_dos_return(-1);
+			}
+		}
+	} else if (enclose_io_is_path(pathname)) {
+		if (!(O_CREAT & flags)) {
+			ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+				pathname,
+				enclose_io_dos_return(squash_open(enclose_io_fs, pathname)),
+				open(mkdir_workdir_expanded, flags)
+			);
+		} else {
+			va_list args;
+			mode_t mode;
+			assert(3 == nargs);
+			va_start(args, flags);
+			mode = va_arg(args, mode_t);
+			va_end(args);
+			char *dir_thereof_ptr = strrchr(pathname, '/');
+			if (dir_thereof_ptr) {
+				*dir_thereof_ptr = 0;
+				enclose_io_mkdir(pathname, 0777);
+				*dir_thereof_ptr = '/';
+			}
+			if (mkdir_workdir) {
+				sqfs_path mkdir_workdir_expanded;
+				char *mkdir_workdir_expanded_head;
+				size_t mkdir_workdir_len;
+				size_t memcpy_len;
+				struct stat mkdir_workdir_buf;
+				mkdir_workdir_len = strlen(mkdir_workdir);
+				memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+				memcpy_len = strlen(pathname);
+				if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+					memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+				}
+				memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], pathname, memcpy_len);
+				mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+				mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+				if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+					memmove(
+						mkdir_workdir_expanded_head,
+						mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+						strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+					);
+					return enclose_io_dos_return(open(mkdir_workdir_expanded, flags, mode));
+				} else {
+					errno = ENOENT;
+					return enclose_io_dos_return(-1);
+				}
+			} else {
+				errno = ENOENT;
+				return enclose_io_dos_return(-1);
+			}
+		}
+	} else {
+		if (2 == nargs) {
+			return open(pathname, flags);
+		} else {
+			va_list args;
+			mode_t mode;
+			va_start(args, flags);
+			mode = va_arg(args, mode_t);
+			va_end(args);
+			return open(pathname, flags, mode);
+		}
+	}
+}
+
+int enclose_io_close(int fildes)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_close(fildes));
+	} else {
+		return close(fildes);
+	}
+}
+
+ssize_t enclose_io_read(int fildes, void *buf, size_t nbyte)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_read(fildes, buf, nbyte));
+	} else {
+		return read(fildes, buf, nbyte);
+	}
+}
+
+off_t enclose_io_lseek(int fildes, off_t offset, int whence)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_lseek(fildes, offset, whence));
+	} else {
+		return lseek(fildes, offset, whence);
+	}
+}
+
+short enclose_io_is_path(char *pathname)
+{
+	if (strnlen((pathname), 21) >= 21) {
+		if (0 == strncmp((pathname), "/__enclose_io_memfs__", 21)
+#ifdef _WIN32
+			|| 0 == strncmp((pathname), "\\__enclose_io_memfs__", 21)
+#endif
+			) {
+				return 1;
+			}
+	}
+#ifdef _WIN32
+	if (strnlen((pathname), 23) >= 23) {
+		if (0 == strncmp((pathname) + 1, ":/__enclose_io_memfs__", 22)
+			|| 0 == strncmp((pathname) + 1, ":\\__enclose_io_memfs__", 22)
+			) {
+				return 1;
+			}
+	}
+	if (strnlen((pathname), 24) >= 24) {
+		if (0 == strncmp((pathname), "\\\\?\\__enclose_io_memfs__", 24) ||
+			0 == strncmp((pathname), "//?/__enclose_io_memfs__", 24)) {
+				return 1;
+			}
+	}
+	if (strnlen((pathname), 27) >= 27) {
+		if (0 == strncmp((pathname), "\\\\?\\", 4) ||
+			0 == strncmp((pathname), "//?/", 4)) {
+			if (0 == strncmp((pathname) + 5, ":\\__enclose_io_memfs__", 22) ||
+				0 == strncmp((pathname) + 5, ":/__enclose_io_memfs__", 22)) {
+					return 1;
+				}
+		}
+	}
+#endif
+	return 0;
+}
+
+#ifdef _WIN32
+short enclose_io_is_path_w(wchar_t *pathname)
+{
+	if (wcsnlen((pathname), 21) >= 21) {
+		if (0 == wcsncmp((pathname), L"/__enclose_io_memfs__", 21)
+			|| 0 == wcsncmp((pathname), L"\\__enclose_io_memfs__", 21)
+			) {
+				return 1;
+			}
+	}
+	if (wcsnlen((pathname), 23) >= 23) {
+		if (0 == wcsncmp((pathname) + 1, L":/__enclose_io_memfs__", 22)
+			|| 0 == wcsncmp((pathname) + 1, L":\\__enclose_io_memfs__", 22)
+			) {
+				return 1;
+			}
+	}
+	if (wcsnlen((pathname), 24) >= 24) {
+		if (0 == wcsncmp((pathname), L"\\\\?\\__enclose_io_memfs__", 24) ||
+			0 == wcsncmp((pathname), L"//?/__enclose_io_memfs__", 24)) {
+				return 1;
+			}
+	}
+	if (wcsnlen((pathname), 27) >= 27) {
+		if (0 == wcsncmp((pathname), L"\\\\?\\", 4) ||
+			0 == wcsncmp((pathname), L"//?/", 4)) {
+			if (0 == wcsncmp((pathname) + 5, L":\\__enclose_io_memfs__", 22) ||
+				0 == wcsncmp((pathname) + 5, L":/__enclose_io_memfs__", 22)) {
+					return 1;
+				}
+		}
+	}
+	return 0;
+}
+
+short enclose_io_is_relative_w(wchar_t *pathname)
+{
+	if (L'\\' == (pathname)[0] ||
+		L'/' == (pathname)[0]) {
+		return 0;
+	}
+	if (wcsnlen(pathname, 3) >= 3) {
+		if (0 == wcsncmp((pathname) + 1, L":\\", 2) ||
+			0 == wcsncmp((pathname) + 1, L":/", 2)) {
+			return 0;
+		}
+	}
+	if (wcsnlen(pathname, 4) >= 4) {
+		if (0 == wcsncmp((pathname), L"\\\\?\\", 4) ||
+			0 == wcsncmp((pathname), L"//?/", 4)) {
+			return 0;
+		}
+	}
+	if (wcsnlen(pathname, 7) >= 7) {
+		if (0 == wcsncmp((pathname), L"\\\\?\\", 4) && 0 == wcsncmp((pathname) + 5, L":\\", 2) ) {
+				return 0;
+			}
+		if (0 == wcsncmp((pathname), L"//?/", 4) && 0 == wcsncmp((pathname) + 5, L":/", 2) ) {
+				return 0;
+			}
+	}
+	return 1;
+}
+#endif
diff -ruN ruby-2.4.1/enclose_io_win32.c ruby/enclose_io_win32.c
--- ruby-2.4.1/enclose_io_win32.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/enclose_io_win32.c	2018-03-16 15:30:55.000000000 +0200
@@ -0,0 +1,1276 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "enclose_io_common.h"
+
+#ifdef _WIN32
+
+extern char *mkdir_workdir;
+extern char *enclose_io_mkdir_scope;
+
+int enclose_io__open(const char *pathname, int flags)
+{
+	if (enclose_io_cwd[0] && '/' != *pathname) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		ENCLOSE_IO_GEN_EXPANDED_NAME(pathname);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			enclose_io_dos_return(squash_open(enclose_io_fs, enclose_io_expanded)),
+			_open(mkdir_workdir_expanded, flags)
+		);
+	} else if (enclose_io_is_path(pathname)) {
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			pathname,
+			enclose_io_dos_return(squash_open(enclose_io_fs, pathname)),
+			_open(mkdir_workdir_expanded, flags)
+		);
+	} else {
+                return _open(pathname, flags);
+	}
+}
+
+int enclose_io__wopen(const wchar_t *pathname, int flags, int mode)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(pathname)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(pathname);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			enclose_io_dos_return(squash_open(enclose_io_fs, enclose_io_expanded)),
+			_open(mkdir_workdir_expanded, flags, mode)
+		);
+	} else if (enclose_io_is_path_w(pathname)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(pathname);
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			enclose_io_dos_return(squash_open(enclose_io_fs, enclose_io_converted)),
+			_open(mkdir_workdir_expanded, flags, mode)
+		);
+	} else {
+		return _wopen(pathname, flags, mode);
+	}
+}
+
+int enclose_io_open_osfhandle(intptr_t osfhandle, int flags)
+{
+	struct squash_file *entry = squash_find_entry((void *)osfhandle);
+	if (entry) {
+		return entry->fd;
+	} else {
+		return _open_osfhandle(osfhandle, flags);
+	}
+}
+
+intptr_t enclose_io_get_osfhandle(int fd)
+{
+	if (SQUASH_VALID_VFD(fd)) {
+		assert(!(S_ISDIR(squash_global_fdtable.fds[fd]->st.st_mode)));
+		return (intptr_t)(squash_global_fdtable.fds[fd]->payload);
+	}
+	else {
+		return _get_osfhandle(fd);
+	}
+}
+
+int enclose_io_wchdir(const wchar_t *path)
+{
+	if (enclose_io_is_path_w(path)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+		struct stat st;
+		int ret;
+
+		W_ENCLOSE_IO_PATH_CONVERT(path);
+
+		if (mkdir_workdir) {
+			sqfs_path mkdir_workdir_expanded;
+			char *mkdir_workdir_expanded_head;
+			size_t mkdir_workdir_len;
+			size_t memcpy_len;
+			struct stat mkdir_workdir_buf;
+			mkdir_workdir_len = strlen(mkdir_workdir);
+			memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+			memcpy_len = strlen(enclose_io_converted);
+			if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+				memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+			}
+			memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], (enclose_io_converted), memcpy_len);
+			mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+			mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+			if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+				memmove(
+					mkdir_workdir_expanded_head,
+					mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+					strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+				);
+				if (0 == stat(mkdir_workdir_expanded, &mkdir_workdir_buf)) {
+					int ret = _chdir(mkdir_workdir_expanded);
+					if (0 == ret) {
+						enclose_io_chdir_helper(enclose_io_converted);
+					}
+					return ret;
+				}
+			}
+		}
+
+		ret = squash_stat(enclose_io_fs, enclose_io_converted, &st);
+		if (-1 == ret) {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return -1;
+		}
+		if (S_ISDIR(st.st_mode)) {
+			enclose_io_chdir_helper(enclose_io_converted);
+			return 0;
+		} else {
+			errno = ENOENT;
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return -1;
+		}
+	} else {
+		int ret = _wchdir(path);
+		if (0 == ret) {
+			enclose_io_cwd[0] = '\0';
+		}
+		return ret;
+	}
+}
+
+wchar_t *enclose_io_wgetcwd(wchar_t *buf, size_t size)
+{
+        wchar_t tempbuf[SQUASHFS_PATH_LEN + 1];
+        size_t retlen;
+	if (enclose_io_cwd[0]) {
+		retlen = mbstowcs(tempbuf, enclose_io_cwd, SQUASHFS_PATH_LEN);
+		if ((size_t)-1 == retlen) {
+                        errno = ERANGE;
+                        ENCLOSE_IO_SET_LAST_ERROR;
+			return NULL;
+		}
+                tempbuf[retlen] = L'\0';
+		if (NULL == buf) {
+			buf = malloc((retlen + 1) * sizeof(wchar_t));
+			if (NULL == buf) {
+				errno = ENOMEM;
+				return NULL;
+			}
+		} else {
+			if (size - 1 < retlen) {
+				retlen = size - 1;
+			}
+		}
+		memcpy(buf, tempbuf, retlen * sizeof(wchar_t));
+		buf[retlen] = L'\0';
+		return buf;
+	} else {
+		return _wgetcwd(buf, size);
+	}
+}
+
+int enclose_io_fstati64(int fildes, struct _stati64 *buf)
+{
+        struct stat st;
+	if (SQUASH_VALID_VFD(fildes)) {
+		if (NULL == buf) {
+                        errno = EINVAL;
+                        ENCLOSE_IO_SET_LAST_ERROR;
+			return -1;
+		}
+		st = SQUASH_VFD_FILE(fildes)->st;
+		buf->st_dev = st.st_dev;
+		buf->st_ino = st.st_ino;
+		buf->st_mode = st.st_mode;
+		buf->st_nlink = st.st_nlink;
+		buf->st_uid = st.st_uid;
+		buf->st_gid = st.st_gid;
+		buf->st_rdev = st.st_rdev;
+		buf->st_size = st.st_size;
+		buf->st_atime = st.st_atime;
+		buf->st_mtime = st.st_mtime;
+		buf->st_ctime = st.st_ctime;
+		return 0;
+	} else {
+		return _fstati64(fildes, buf);
+	}
+}
+
+__int64 enclose_io_lseeki64(int fildes, __int64 offset, int whence)
+{
+	if (SQUASH_VALID_VFD(fildes)) {
+		return enclose_io_dos_return(squash_lseek(fildes, offset, whence));
+	} else {
+		return _lseeki64(fildes, offset, whence);
+	}
+}
+
+static HANDLE EncloseIOCreateFileWHelper(
+	char * incoming,
+	DWORD dwFlagsAndAttributes)
+{
+	int ret;
+	struct stat buf;
+	SQUASH_DIR *dirp;
+	int follow_link;
+
+	if (dwFlagsAndAttributes & FILE_FLAG_OPEN_REPARSE_POINT) {
+		ret = squash_lstat(enclose_io_fs, incoming, &buf);
+		follow_link = 0;
+	} else {
+		ret = squash_stat(enclose_io_fs, incoming, &buf);
+		follow_link = 1;
+	}
+
+	if (-1 == ret) {
+		ENCLOSE_IO_SET_LAST_ERROR;
+		return INVALID_HANDLE_VALUE;
+	}
+	if (S_ISDIR(buf.st_mode)) {
+		dirp = squash_opendir_inner(enclose_io_fs, incoming, follow_link);
+		if (NULL != dirp) {
+			return (HANDLE)(dirp);
+		} else {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return INVALID_HANDLE_VALUE;
+		}
+	} else {
+		ret = squash_open_inner(enclose_io_fs, incoming, follow_link);
+		if (ret >= 0) {
+			return (HANDLE)(squash_global_fdtable.fds[ret]->payload);
+		} else {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return INVALID_HANDLE_VALUE;
+		}
+	}
+}
+
+HANDLE
+EncloseIOCreateFileW(
+	LPCWSTR lpFileName,
+	DWORD dwDesiredAccess,
+	DWORD dwShareMode,
+	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
+	DWORD dwCreationDisposition,
+	DWORD dwFlagsAndAttributes,
+	HANDLE hTemplateFile
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		if (OPEN_EXISTING == dwCreationDisposition) {
+			ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+				enclose_io_expanded,
+				EncloseIOCreateFileWHelper(
+					enclose_io_expanded,
+					dwFlagsAndAttributes
+				),
+				CreateFile(
+					mkdir_workdir_expanded,
+					dwDesiredAccess,
+					dwShareMode,
+					lpSecurityAttributes,
+					dwCreationDisposition,
+					dwFlagsAndAttributes,
+					hTemplateFile
+				)
+			);
+		} else {
+			char *dir_thereof_ptr = strrchr(enclose_io_expanded, '/');
+			if (dir_thereof_ptr) {
+				*dir_thereof_ptr = 0;
+				enclose_io_mkdir(enclose_io_expanded, 0777);
+				*dir_thereof_ptr = '/';
+			}
+			if (mkdir_workdir) {
+				sqfs_path mkdir_workdir_expanded;
+				char *mkdir_workdir_expanded_head;
+				size_t mkdir_workdir_len;
+				size_t memcpy_len;
+				struct stat mkdir_workdir_buf;
+				mkdir_workdir_len = strlen(mkdir_workdir);
+				memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+				memcpy_len = strlen(enclose_io_expanded);
+				if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+					memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+				}
+				memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], enclose_io_expanded, memcpy_len);
+				mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+				mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+				if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+					memmove(
+						mkdir_workdir_expanded_head,
+						mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+						strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+					);
+					return CreateFile(
+						mkdir_workdir_expanded,
+						dwDesiredAccess,
+						dwShareMode,
+						lpSecurityAttributes,
+						dwCreationDisposition,
+						dwFlagsAndAttributes,
+						hTemplateFile
+					);
+				} else {
+					errno = ENOENT;
+					return enclose_io_dos_return(-1);
+				}
+			} else {
+				errno = ENOENT;
+				return enclose_io_dos_return(-1);
+			}
+		}
+	} else if (enclose_io_is_path_w(lpFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		
+		if (OPEN_EXISTING == dwCreationDisposition) {
+			ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+				enclose_io_converted,
+				EncloseIOCreateFileWHelper(
+					enclose_io_converted,
+					dwFlagsAndAttributes
+				),
+				CreateFile(
+					mkdir_workdir_expanded,
+					dwDesiredAccess,
+					dwShareMode,
+					lpSecurityAttributes,
+					dwCreationDisposition,
+					dwFlagsAndAttributes,
+					hTemplateFile
+				)
+			);
+		} else {
+			char *dir_thereof_ptr = strrchr(enclose_io_converted, '/');
+			if (dir_thereof_ptr) {
+				*dir_thereof_ptr = 0;
+				enclose_io_mkdir(enclose_io_converted, 0777);
+				*dir_thereof_ptr = '/';
+			}
+			if (mkdir_workdir) {
+				sqfs_path mkdir_workdir_expanded;
+				char *mkdir_workdir_expanded_head;
+				size_t mkdir_workdir_len;
+				size_t memcpy_len;
+				struct stat mkdir_workdir_buf;
+				mkdir_workdir_len = strlen(mkdir_workdir);
+				memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len);
+				memcpy_len = strlen(enclose_io_converted);
+				if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) {
+					memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len;
+				}
+				memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], enclose_io_converted, memcpy_len);
+				mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0';
+				mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope);
+				if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) {
+					memmove(
+						mkdir_workdir_expanded_head,
+						mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope),
+						strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1
+					);
+					return CreateFile(
+						mkdir_workdir_expanded,
+						dwDesiredAccess,
+						dwShareMode,
+						lpSecurityAttributes,
+						dwCreationDisposition,
+						dwFlagsAndAttributes,
+						hTemplateFile
+					);
+				} else {
+					errno = ENOENT;
+					return enclose_io_dos_return(-1);
+				}
+			} else {
+				errno = ENOENT;
+				return enclose_io_dos_return(-1);
+			}
+		}
+	} else {
+		return CreateFileW(
+			lpFileName,
+			dwDesiredAccess,
+			dwShareMode,
+			lpSecurityAttributes,
+			dwCreationDisposition,
+			dwFlagsAndAttributes,
+			hTemplateFile
+		);
+	}
+}
+
+BOOL
+EncloseIOCloseHandle(
+	HANDLE hObject
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hObject);
+	if (sqf) {
+                int ret;
+		if (S_ISDIR(sqf->st.st_mode)) {
+			ret = squash_closedir((SQUASH_DIR *)hObject);
+                        if (-1 == ret) {
+                                ENCLOSE_IO_SET_LAST_ERROR;
+                                return FALSE;
+                        }
+			return TRUE;
+		} else {
+			ret = squash_close(*((int *)hObject));
+                        if (-1 == ret) {
+                                ENCLOSE_IO_SET_LAST_ERROR;
+                                return FALSE;
+                        }
+			return TRUE;
+		}
+	} else {
+		return CloseHandle(
+			hObject
+		);
+	}
+}
+
+BOOL
+EncloseIOReadFile(
+	HANDLE       hFile,
+	LPVOID       lpBuffer,
+	DWORD        nNumberOfBytesToRead,
+	LPDWORD      lpNumberOfBytesRead,
+	LPOVERLAPPED lpOverlapped
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFile);
+        int ret;
+
+	if (sqf) {
+		if (NULL != lpOverlapped) {
+                        squash_lseek(sqf->fd, lpOverlapped->Offset, SQUASH_SEEK_SET);
+                        assert(0 == lpOverlapped->OffsetHigh); // TODO support OffsetHigh
+                }
+		ret = squash_read(sqf->fd, lpBuffer, nNumberOfBytesToRead);
+		if (-1 == ret) {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return FALSE;
+		}
+		*lpNumberOfBytesRead = ret;
+		return TRUE;
+	} else {
+		return ReadFile(
+			hFile,
+			lpBuffer,
+			nNumberOfBytesToRead,
+			lpNumberOfBytesRead,
+			lpOverlapped
+		);
+	}
+}
+
+static DWORD EncloseIOGetFileAttributesHelper(struct stat *st)
+{
+	DWORD fa = 0; //FILE_ATTRIBUTE_READONLY;
+	if (S_ISCHR(st->st_mode)) {
+		fa |= FILE_ATTRIBUTE_DEVICE;
+	} else if (S_ISLNK(st->st_mode)) {
+		fa |= FILE_ATTRIBUTE_REPARSE_POINT;
+	} else if (S_ISDIR(st->st_mode)) {
+		fa |= FILE_ATTRIBUTE_DIRECTORY;
+	} else {
+		fa |= FILE_ATTRIBUTE_NORMAL;
+	}
+	return fa;
+}
+
+DWORD
+EncloseIOGetFileAttributesWHelper(
+	const char *path
+)
+{
+	int ret;
+	struct stat buf;
+	ret = squash_stat(enclose_io_fs, path, &buf);
+	if (-1 == ret) {
+		ENCLOSE_IO_SET_LAST_ERROR;
+		return INVALID_FILE_ATTRIBUTES;
+	}
+	return EncloseIOGetFileAttributesHelper(&buf);
+}
+
+DWORD
+EncloseIOGetFileAttributesW(
+    LPCWSTR lpFileName
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			EncloseIOGetFileAttributesWHelper(enclose_io_expanded),
+			GetFileAttributes(
+				mkdir_workdir_expanded
+			)
+		);
+	} else if (enclose_io_is_path_w(lpFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			EncloseIOGetFileAttributesWHelper(enclose_io_converted),
+			GetFileAttributes(
+				mkdir_workdir_expanded
+			)
+		);
+	} else {
+		return GetFileAttributesW(
+			lpFileName
+		);
+	}
+}
+
+static void EncloseIOUnixtimeToFiletime(time_t time, FILETIME *ft)
+{
+    ULARGE_INTEGER tmp;
+    tmp.QuadPart = ((long long)time + (long long)((1970-1601)*365.2425) * 24 * 60 * 60) * 10 * 1000 * 1000;
+    ft->dwLowDateTime = tmp.LowPart;
+    ft->dwHighDateTime = tmp.HighPart;
+}
+
+static void EncloseIOFillWin32FileAttributeDataHelper(WIN32_FILE_ATTRIBUTE_DATA *fa, struct stat *st)
+{
+        fa->dwFileAttributes = EncloseIOGetFileAttributesHelper(st);
+        EncloseIOUnixtimeToFiletime(st->st_atime, &fa->ftLastAccessTime);
+        EncloseIOUnixtimeToFiletime(st->st_mtime, &fa->ftLastWriteTime);
+        EncloseIOUnixtimeToFiletime(st->st_ctime, &fa->ftCreationTime);
+        // TODO somehow support large files?
+        fa->nFileSizeHigh = 0;
+        fa->nFileSizeLow = st->st_size;
+}
+
+BOOL
+EncloseIOGetFileAttributesExWHelper(
+	const char *path,
+	LPVOID lpFileInformation
+)
+{
+	int ret;
+	struct stat buf;
+	WIN32_FILE_ATTRIBUTE_DATA *fa;
+
+	ret = squash_stat(enclose_io_fs, path, &buf);
+	if (-1 == ret) {
+		ENCLOSE_IO_SET_LAST_ERROR;
+		return 0;
+	}
+	fa = (WIN32_FILE_ATTRIBUTE_DATA *)lpFileInformation;
+	EncloseIOFillWin32FileAttributeDataHelper(fa, &buf);
+	return 1;
+}
+
+BOOL
+EncloseIOGetFileAttributesExW(
+    LPCWSTR lpFileName,
+    GET_FILEEX_INFO_LEVELS fInfoLevelId,
+    LPVOID lpFileInformation
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		assert(GetFileExInfoStandard == fInfoLevelId);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			EncloseIOGetFileAttributesExWHelper(enclose_io_expanded, lpFileInformation),
+			GetFileAttributesEx(
+				mkdir_workdir_expanded,
+				fInfoLevelId,
+				lpFileInformation
+			),
+		);
+	} else if (enclose_io_is_path_w(lpFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		assert(GetFileExInfoStandard == fInfoLevelId);
+
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			EncloseIOGetFileAttributesExWHelper(enclose_io_converted, lpFileInformation),
+			GetFileAttributesEx(
+				mkdir_workdir_expanded,
+				fInfoLevelId,
+				lpFileInformation
+			)
+		);
+	} else {
+		return GetFileAttributesExW(
+			lpFileName,
+			fInfoLevelId,
+			lpFileInformation
+		);
+	}
+}
+
+BOOL
+EncloseIOGetHandleInformation(
+    HANDLE hObject,
+    LPDWORD lpdwFlags
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hObject);
+        if (sqf) {
+                *lpdwFlags = 0;
+                return 1;
+        } else {
+                return GetHandleInformation(
+                        hObject,
+                        lpdwFlags
+                );
+        }
+}
+
+DWORD
+EncloseIOGetFileType(
+        HANDLE hFile
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFile);
+        if (sqf) {
+                struct stat st;
+		st = sqf->st;
+                if (S_ISCHR(st.st_mode)) {
+                        return FILE_TYPE_CHAR;
+                } else if (S_ISREG(st.st_mode)) {
+                        return FILE_TYPE_DISK;
+                } else if (S_ISFIFO(st.st_mode)) {
+                        return FILE_TYPE_PIPE;
+                } else {
+                        return FILE_TYPE_UNKNOWN;
+                }
+        } else {
+                return GetFileType(
+                        hFile
+                );
+        }
+}
+
+DWORD EncloseIODType2FileAttributes(int d_type)
+{
+        DWORD x = 0; //FILE_ATTRIBUTE_READONLY;
+        if (DT_CHR == d_type) {
+                x |= FILE_ATTRIBUTE_DEVICE;
+        } else if (DT_LNK == d_type) {
+                x |= FILE_ATTRIBUTE_REPARSE_POINT;
+        } else if (DT_DIR == d_type) {
+                x |= FILE_ATTRIBUTE_DIRECTORY;
+        } else {
+                x |= FILE_ATTRIBUTE_NORMAL;
+        }
+        return x;
+}
+
+HANDLE
+EncloseIOFindFirstFileHelper(
+        char *incoming,
+        LPWIN32_FIND_DATAW lpFindFileData
+)
+{
+        char *dup_incoming = strdup(incoming);
+        char *parent = incoming + strlen(incoming);
+        SQUASH_DIR *dirp;
+        struct SQUASH_DIRENT *mydirent;
+        char *current_path_tail;
+        char *current_path;
+        size_t mbstowcs_size;
+
+        while (parent >= incoming) {
+                if ('/' == *parent) {
+                        break;
+                }
+                parent -= 1;
+        }
+        *parent = '\0';
+        dirp = squash_opendir(enclose_io_fs, incoming);
+        if (NULL == dirp) {
+                ENCLOSE_IO_SET_LAST_ERROR;
+                return INVALID_HANDLE_VALUE;
+        }
+        dirp->payload = dup_incoming;
+        current_path = (char *)malloc(strlen(dup_incoming) + SQUASHFS_PATH_LEN + 1);
+        if (NULL == current_path) {
+                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+                return INVALID_HANDLE_VALUE;
+        }
+        memcpy(current_path, incoming, strlen(incoming) + 1);
+        strcat(current_path, "/");
+        current_path_tail = current_path + strlen(current_path);
+        do {
+        	mydirent = squash_readdir(dirp);
+                if (NULL == mydirent) {
+                        break;
+                }
+                memcpy(current_path_tail, mydirent->d_name, strlen(mydirent->d_name) + 1);
+        } while (!PathMatchSpecA(current_path, dup_incoming));
+        free(current_path);
+        if (NULL == mydirent) {
+                int ret = squash_closedir(dirp);
+                assert(0 == ret);
+                ENCLOSE_IO_SET_LAST_ERROR;
+                return INVALID_HANDLE_VALUE;
+        }
+        mbstowcs_size = mbstowcs(lpFindFileData->cFileName, mydirent->d_name, sizeof(lpFindFileData->cFileName) / sizeof(lpFindFileData->cFileName[0]) - 1);
+        if ((size_t)-1 == mbstowcs_size) {
+                errno = EIO;
+                ENCLOSE_IO_SET_LAST_ERROR;
+                return 0;
+        }
+        lpFindFileData->cFileName[mbstowcs_size] = 0;
+        lpFindFileData->cAlternateFileName[0] = 0;
+        lpFindFileData->dwFileAttributes = EncloseIODType2FileAttributes(mydirent->d_type);
+        return (HANDLE)(dirp);
+}
+
+HANDLE
+EncloseIOFindFirstFileW(
+        LPCWSTR lpFileName,
+        LPWIN32_FIND_DATAW lpFindFileData
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			EncloseIOFindFirstFileHelper(enclose_io_expanded, lpFindFileData),
+			FindFirstFile(
+				mkdir_workdir_expanded,
+				lpFindFileData
+			)
+		);
+	} else if (enclose_io_is_path_w(lpFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpFileName);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			EncloseIOFindFirstFileHelper(enclose_io_converted, lpFindFileData),
+			FindFirstFile(
+				mkdir_workdir_expanded,
+				lpFindFileData
+			)
+		);
+	} else {
+		return FindFirstFileW(
+			lpFileName,
+			lpFindFileData
+		);
+	}
+}
+
+BOOL
+EncloseIOFindNextFileW(
+        HANDLE hFindFile,
+        LPWIN32_FIND_DATAW lpFindFileData
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFindFile);
+
+	if (sqf) {
+                SQUASH_DIR *dirp;
+                struct SQUASH_DIRENT *mydirent;
+                char *current_path;
+                char *current_path_tail;
+                size_t mbstowcs_size;
+
+                dirp = (SQUASH_DIR*)hFindFile;
+                current_path = (char *)malloc(strlen((char *)(dirp->payload)) + SQUASHFS_PATH_LEN + 1);
+                if (NULL == current_path) {
+                        errno = ENOMEM;
+                        ENCLOSE_IO_SET_LAST_ERROR;
+                        return 0;
+                }
+                memcpy(current_path, dirp->filename, strlen(dirp->filename) + 1);
+                strcat(current_path, "/");
+                current_path_tail = current_path + strlen(current_path);
+                do {
+                        mydirent = squash_readdir(dirp);
+                        if (NULL == mydirent) {
+                                break;
+                        }
+                        memcpy(current_path_tail, mydirent->d_name, strlen(mydirent->d_name) + 1);
+                } while (!PathMatchSpecA(current_path, (char *)(dirp->payload)));
+                free(current_path);
+                if (NULL == mydirent) {
+                        errno = ENOENT;
+                        SetLastError(ERROR_NO_MORE_FILES);
+                        _doserrno = ERROR_NO_MORE_FILES;
+                        return 0;
+                }
+                mbstowcs_size = mbstowcs(lpFindFileData->cFileName, mydirent->d_name, sizeof(lpFindFileData->cFileName) / sizeof(lpFindFileData->cFileName[0]) - 1);
+                if ((size_t)-1 == mbstowcs_size) {
+                        errno = EIO;
+                        ENCLOSE_IO_SET_LAST_ERROR;
+                        return 0;
+                }
+                lpFindFileData->cFileName[mbstowcs_size] = 0;
+                lpFindFileData->cAlternateFileName[0] = 0;
+                lpFindFileData->dwFileAttributes = EncloseIODType2FileAttributes(mydirent->d_type);
+                return 1;
+        } else {
+                return FindNextFileW(
+                        hFindFile,
+                        lpFindFileData
+                );
+        }
+}
+
+BOOL
+EncloseIOFindClose(
+        HANDLE hFindFile
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hFindFile);
+        int ret;
+
+	if (sqf) {
+                ret = squash_closedir((SQUASH_DIR *)hFindFile);
+                if (0 == ret) {
+                        return 1;
+                } else {
+                        ENCLOSE_IO_SET_LAST_ERROR;
+                        return 0;
+                }
+        } else {
+                return FindClose(
+                        hFindFile
+                );
+        }
+}
+
+BOOL
+EncloseIODeviceIoControl(
+        HANDLE hDevice,
+        DWORD dwIoControlCode,
+        LPVOID lpInBuffer,
+        DWORD nInBufferSize,
+        LPVOID lpOutBuffer,
+        DWORD nOutBufferSize,
+        LPDWORD lpBytesReturned,
+        LPOVERLAPPED lpOverlapped
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hDevice);
+	int ret;
+
+	if (sqf) {
+		char the_path[SQUASHFS_PATH_LEN + 1];
+		wchar_t the_wpath[SQUASHFS_PATH_LEN + 1];
+		struct stat st;
+		size_t retlen;
+		REPARSE_DATA_BUFFER* reparse_data = (REPARSE_DATA_BUFFER*)lpOutBuffer;
+
+		// TODO handle the overlapped
+		assert(NULL == lpOverlapped);
+
+		// TODO support more than FSCTL_GET_REPARSE_POINT
+		assert(0 == nInBufferSize);
+
+		// FSCTL_GET_REPARSE_POINT
+		// https://msdn.microsoft.com/en-us/library/windows/desktop/aa364571(v=vs.85).aspx
+		assert(dwIoControlCode == FSCTL_GET_REPARSE_POINT);
+		assert(NULL == lpInBuffer);
+		st = sqf->st;
+		if (!S_ISLNK(st.st_mode)) {
+			errno = EINVAL;
+			SetLastError(ERROR_NOT_A_REPARSE_POINT);
+			_doserrno = ERROR_NOT_A_REPARSE_POINT;
+			return FALSE;
+		}
+		ret = squash_readlink_inode(
+			enclose_io_fs,
+			&sqf->node,
+			the_path,
+			SQUASHFS_PATH_LEN
+		);
+		if (-1 == ret) {
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return FALSE;
+		}
+                
+		retlen = mbstowcs(the_wpath, the_path, SQUASHFS_PATH_LEN);
+		if ((size_t)-1 == retlen) {
+			errno = ENAMETOOLONG;
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return FALSE;
+		}
+		the_wpath[retlen] = L'\0';
+		*lpBytesReturned = sizeof(REPARSE_DATA_BUFFER) + retlen * sizeof(wchar_t);
+		if (*lpBytesReturned > nOutBufferSize) {
+			*lpBytesReturned = 0;
+			errno = ENAMETOOLONG;
+			ENCLOSE_IO_SET_LAST_ERROR;
+			return FALSE;
+		}
+		reparse_data->ReparseTag = IO_REPARSE_TAG_SYMLINK;
+		memcpy(reparse_data->SymbolicLinkReparseBuffer.PathBuffer, the_wpath, (retlen + 1) * sizeof(wchar_t));
+		reparse_data->SymbolicLinkReparseBuffer.SubstituteNameLength = retlen * sizeof(wchar_t);
+		reparse_data->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
+		return TRUE;
+	} else {
+		return DeviceIoControl(
+			hDevice,
+			dwIoControlCode,
+			lpInBuffer,
+			nInBufferSize,
+			lpOutBuffer,
+			nOutBufferSize,
+			lpBytesReturned,
+			lpOverlapped
+		);
+	}
+}
+
+HANDLE
+EncloseIOCreateIoCompletionPort(
+        HANDLE FileHandle,
+        HANDLE ExistingCompletionPort,
+        ULONG_PTR CompletionKey,
+        DWORD NumberOfConcurrentThreads
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)FileHandle);
+
+	if (sqf) {
+		// do nothing
+		assert(NULL != ExistingCompletionPort);
+		return ExistingCompletionPort;
+	} else {
+		return CreateIoCompletionPort(
+			FileHandle,
+			ExistingCompletionPort,
+			CompletionKey,
+			NumberOfConcurrentThreads
+		);
+	}
+}
+
+BOOL
+EncloseIOReadDirectoryChangesW(
+        HANDLE hDirectory,
+        LPVOID lpBuffer,
+        DWORD nBufferLength,
+        BOOL bWatchSubtree,
+        DWORD dwNotifyFilter,
+        LPDWORD lpBytesReturned,
+        LPOVERLAPPED lpOverlapped,
+        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
+)
+{
+	struct squash_file *sqf = squash_find_entry((void *)hDirectory);
+
+	if (sqf) {
+		// do nothing
+		assert(lpOverlapped);
+		return TRUE;
+	} else {
+		return ReadDirectoryChangesW(
+			hDirectory,
+			lpBuffer,
+			nBufferLength,
+			bWatchSubtree,
+			dwNotifyFilter,
+			lpBytesReturned,
+			lpOverlapped,
+			lpCompletionRoutine
+		);
+	}
+}
+
+HMODULE
+EncloseIOLoadLibraryExW(
+	LPCWSTR lpLibFileName,
+	HANDLE hFile,
+	DWORD dwFlags
+)
+{
+	if (enclose_io_cwd[0] && enclose_io_is_relative_w(lpLibFileName)) {
+		sqfs_path enclose_io_expanded;
+		size_t enclose_io_cwd_len;
+		size_t memcpy_len;
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpLibFileName);
+		ENCLOSE_IO_GEN_EXPANDED_NAME(enclose_io_converted);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_expanded,
+			LoadLibraryExW(
+				squash_extract(enclose_io_fs, enclose_io_expanded, "dll"),
+				hFile,
+				dwFlags
+			),
+			LoadLibraryEx(
+				mkdir_workdir_expanded,
+				hFile,
+				dwFlags
+			)
+		);
+	}
+	else if (enclose_io_is_path_w(lpLibFileName)) {
+		sqfs_path enclose_io_converted_storage;
+		char *enclose_io_converted;
+		char *enclose_io_i;
+		size_t enclose_io_converted_length;
+
+		W_ENCLOSE_IO_PATH_CONVERT(lpLibFileName);
+		
+		ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(
+			enclose_io_converted,
+			LoadLibraryExW(
+				squash_extract(enclose_io_fs, enclose_io_converted, "dll"),
+				hFile,
+				dwFlags
+			),
+			LoadLibraryEx(
+				mkdir_workdir_expanded,
+				hFile,
+				dwFlags
+			)
+		);
+	}
+	else {
+		return LoadLibraryExW(
+			lpLibFileName,
+			hFile,
+			dwFlags
+		);
+	}
+}
+
+BOOL
+EncloseIOCreateProcessW(
+	LPCWSTR lpApplicationName,
+	LPWSTR lpCommandLine,
+	LPSECURITY_ATTRIBUTES lpProcessAttributes,
+	LPSECURITY_ATTRIBUTES lpThreadAttributes,
+	BOOL bInheritHandles,
+	DWORD dwCreationFlags,
+	LPVOID lpEnvironment,
+	LPCWSTR lpCurrentDirectory,
+	LPSTARTUPINFOW lpStartupInfo,
+	LPPROCESS_INFORMATION lpProcessInformation
+)
+{
+	if (NULL != lpCurrentDirectory && enclose_io_is_path_w(lpCurrentDirectory)) {
+		lpCurrentDirectory = NULL;
+	}
+	return CreateProcessW(
+		lpApplicationName,
+		lpCommandLine,
+		lpProcessAttributes,
+		lpThreadAttributes,
+		bInheritHandles,
+		dwCreationFlags,
+		lpEnvironment,
+		lpCurrentDirectory,
+		lpStartupInfo,
+		lpProcessInformation
+	);
+}
+
+#ifndef RUBY_EXPORT
+NTSTATUS
+EncloseIOpNtQueryInformationFile(
+	HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass)
+{
+	struct squash_file *sqf = squash_find_entry((void *)FileHandle);
+        struct stat st;
+	if (sqf) {
+		st = sqf->st;
+		IoStatusBlock->Status = STATUS_NOT_IMPLEMENTED;
+		FILE_ALL_INFORMATION *file_info = (FILE_ALL_INFORMATION *)FileInformation;
+		file_info->BasicInformation.FileAttributes = EncloseIOGetFileAttributesHelper(&st);
+		file_info->StandardInformation.EndOfFile.QuadPart = st.st_size;
+
+		file_info->BasicInformation.LastAccessTime.QuadPart = st.st_atime * 10000000ULL + 116444736000000000ULL;
+		file_info->BasicInformation.ChangeTime.QuadPart = st.st_mtime * 10000000ULL + 116444736000000000ULL;
+		file_info->BasicInformation.LastWriteTime.QuadPart = st.st_mtime * 10000000ULL + 116444736000000000ULL;
+		file_info->BasicInformation.CreationTime.QuadPart = st.st_ctime * 10000000ULL + 116444736000000000ULL;
+		file_info->InternalInformation.IndexNumber.QuadPart = st.st_ino;
+		file_info->StandardInformation.AllocationSize.QuadPart = st.st_size;
+		file_info->StandardInformation.NumberOfLinks = st.st_nlink;
+
+		return STATUS_SUCCESS;
+	} else {
+		return pNtQueryInformationFile(
+			FileHandle,
+			IoStatusBlock,
+			FileInformation,
+			Length,
+			FileInformationClass
+		);
+	}
+}
+
+NTSTATUS
+EncloseIOpNtQueryVolumeInformationFile(
+	HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FsInformation,
+	ULONG Length,
+	FS_INFORMATION_CLASS FsInformationClass)
+{
+	if (squash_find_entry((void *)FileHandle)) {
+		IoStatusBlock->Status = STATUS_NOT_IMPLEMENTED;
+		return STATUS_SUCCESS;
+	} else {
+		return pNtQueryVolumeInformationFile(
+			FileHandle,
+			IoStatusBlock,
+			FsInformation,
+			Length,
+			FsInformationClass);
+	}
+}
+
+NTSTATUS
+EncloseIOpNtQueryDirectoryFile(
+	HANDLE FileHandle,
+	HANDLE Event,
+	PIO_APC_ROUTINE ApcRoutine,
+	PVOID ApcContext,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass,
+	BOOLEAN ReturnSingleEntry,
+	PUNICODE_STRING FileName,
+	BOOLEAN RestartScan
+)
+{
+        SQUASH_DIR *handle;
+        struct SQUASH_DIRENT *mydirent;
+        size_t retlen;
+
+	if (squash_find_entry((void *)FileHandle)) {
+		handle = (SQUASH_DIR *)FileHandle;
+		mydirent = squash_readdir(handle);
+		if (NULL == mydirent) {
+			return STATUS_NO_MORE_FILES;
+		} else {
+                        /* FileInformation points to a buffer to hold directory entries.
+                         * It's important that this buffer can hold at least one entry, regardless
+                         * of the length of the file names present in the enumerated directory.
+                         * A file name is at most 256 WCHARs long.
+                         * According to MSDN, the buffer must be aligned at an 8-byte boundary.
+                         */
+                        assert(Length > 256 * sizeof(wchar_t));
+			FILE_DIRECTORY_INFORMATION *ret = (FILE_DIRECTORY_INFORMATION *)FileInformation;
+			ret->NextEntryOffset = 0;
+			retlen = mbstowcs(ret->FileName, mydirent->d_name, 255);
+			if ((size_t)-1 == retlen) {
+				return -1;
+                        }
+                        ret->FileName[retlen] = 0;
+                        ret->FileNameLength = sizeof(ret->FileName[0]) * retlen;
+			ret->FileAttributes = EncloseIODType2FileAttributes(mydirent->d_type);
+                        IoStatusBlock->Information = (char*)(&ret->FileName[retlen]) - (char*)FileInformation + 1;
+			return STATUS_SUCCESS;
+		}
+	} else {
+		return pNtQueryDirectoryFile(
+			FileHandle,
+			Event,
+			ApcRoutine,
+			ApcContext,
+			IoStatusBlock,
+			FileInformation,
+			Length,
+			FileInformationClass,
+			ReturnSingleEntry,
+			FileName,
+			RestartScan
+		);
+	}
+}
+
+#endif // !RUBY_EXPORT
+#endif
diff -ruN ruby-2.4.1/ext/dbm/extconf.rb ruby/ext/dbm/extconf.rb
--- ruby-2.4.1/ext/dbm/extconf.rb	2015-12-16 07:31:54.000000000 +0200
+++ ruby/ext/dbm/extconf.rb	2018-03-16 15:30:55.000000000 +0200
@@ -25,6 +25,9 @@
 else
   dblib = %w(libc db db2 db1 db5 db4 db3 gdbm_compat gdbm qdbm)
 end
+# --------- [Enclose.io Hack start] ---------
+dblib = %w(gdbm_compat)
+# --------- [Enclose.io Hack end] ---------
 
 headers = {
   "libc" => ["ndbm.h"], # 4.3BSD original ndbm, Berkeley DB 1 in 4.4BSD libc.
diff -ruN ruby-2.4.1/ext/openssl/ossl_x509store.c ruby/ext/openssl/ossl_x509store.c
--- ruby-2.4.1/ext/openssl/ossl_x509store.c	2016-11-30 16:41:46.000000000 +0200
+++ ruby/ext/openssl/ossl_x509store.c	2018-03-16 15:30:56.000000000 +0200
@@ -325,6 +325,10 @@
  * Adds the certificates in +file+ to the certificate store.  The +file+ can
  * contain multiple PEM-encoded certificates.
  */
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io_prelude.h"
+#include "enclose_io_common.h"
+// --------- [Enclose.io Hack end] ---------
 static VALUE
 ossl_x509store_add_file(VALUE self, VALUE file)
 {
@@ -339,6 +343,11 @@
     GetX509Store(self, store);
     lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());
     if(lookup == NULL) ossl_raise(eX509StoreError, NULL);
+    // --------- [Enclose.io Hack start] ---------
+    #ifdef ENCLOSE_IO_RUBYC_2ND_PASS
+      path = enclose_io_ifextract(path, NULL);
+    #endif
+    // --------- [Enclose.io Hack end] ---------
     if(X509_LOOKUP_load_file(lookup, path, X509_FILETYPE_PEM) != 1){
         ossl_raise(eX509StoreError, NULL);
     }
diff -ruN ruby-2.4.1/ext/psych/.gitignore ruby/ext/psych/.gitignore
--- ruby-2.4.1/ext/psych/.gitignore	2012-11-28 06:34:41.000000000 +0200
+++ ruby/ext/psych/.gitignore	1970-01-01 02:00:00.000000000 +0200
@@ -1,11 +0,0 @@
-/api.c
-/config.h
-/dumper.c
-/emitter.c
-/loader.c
-/parser.c
-/reader.c
-/scanner.c
-/writer.c
-/yaml.h
-/yaml_private.h
diff -ruN ruby-2.4.1/file.c ruby/file.c
--- ruby-2.4.1/file.c	2016-12-07 04:19:29.000000000 +0200
+++ ruby/file.c	2018-03-16 15:30:56.000000000 +0200
@@ -96,6 +96,10 @@
 #define lstat stat
 #endif
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 /* define system APIs */
 #ifdef _WIN32
 #include "win32/file.h"
diff -ruN ruby-2.4.1/gems/did_you_mean-1.1.0/.gitignore ruby/gems/did_you_mean-1.1.0/.gitignore
--- ruby-2.4.1/gems/did_you_mean-1.1.0/.gitignore	2017-03-22 07:56:53.000000000 +0200
+++ ruby/gems/did_you_mean-1.1.0/.gitignore	1970-01-01 02:00:00.000000000 +0200
@@ -1,19 +0,0 @@
-*.gem
-*.rbc
-.bundle
-.config
-.yardoc
-Gemfile.lock
-InstalledFiles
-_yardoc
-coverage
-doc/
-lib/bundler/man
-pkg
-rdoc
-test/tmp
-test/version_tmp
-tmp
-log
-evaluation/dictionary.yml
-benchmark/results
diff -ruN ruby-2.4.1/gems/net-telnet-0.1.1/.gitignore ruby/gems/net-telnet-0.1.1/.gitignore
--- ruby-2.4.1/gems/net-telnet-0.1.1/.gitignore	2017-03-22 07:56:53.000000000 +0200
+++ ruby/gems/net-telnet-0.1.1/.gitignore	1970-01-01 02:00:00.000000000 +0200
@@ -1,9 +0,0 @@
-/.bundle/
-/.yardoc
-/Gemfile.lock
-/_yardoc/
-/coverage/
-/doc/
-/pkg/
-/spec/reports/
-/tmp/
diff -ruN ruby-2.4.1/gems/power_assert-0.4.1/.gitignore ruby/gems/power_assert-0.4.1/.gitignore
--- ruby-2.4.1/gems/power_assert-0.4.1/.gitignore	2017-03-22 07:56:53.000000000 +0200
+++ ruby/gems/power_assert-0.4.1/.gitignore	1970-01-01 02:00:00.000000000 +0200
@@ -1,9 +0,0 @@
-/.bundle/
-/coverage/
-/Gemfile.local
-/Gemfile.lock
-/GPATH
-/GRTAGS
-/GTAGS
-/pkg/
-/vendor/
diff -ruN ruby-2.4.1/gems/rake-12.0.0/.gitignore ruby/gems/rake-12.0.0/.gitignore
--- ruby-2.4.1/gems/rake-12.0.0/.gitignore	2017-03-22 07:56:53.000000000 +0200
+++ ruby/gems/rake-12.0.0/.gitignore	1970-01-01 02:00:00.000000000 +0200
@@ -1,14 +0,0 @@
-*.bak
-*.rbc
-*.swp
-*~
-.#*
-.DS_Store
-.idea
-.rbx
-/.rdoc
-/TAGS
-/coverage
-/html
-/pkg
-Gemfile.lock
diff -ruN ruby-2.4.1/gems/xmlrpc-0.2.1/.gitignore ruby/gems/xmlrpc-0.2.1/.gitignore
--- ruby-2.4.1/gems/xmlrpc-0.2.1/.gitignore	2017-03-22 07:56:53.000000000 +0200
+++ ruby/gems/xmlrpc-0.2.1/.gitignore	1970-01-01 02:00:00.000000000 +0200
@@ -1,9 +0,0 @@
-/.bundle/
-/.yardoc
-/Gemfile.lock
-/_yardoc/
-/coverage/
-/doc/
-/pkg/
-/spec/reports/
-/tmp/
diff -ruN ruby-2.4.1/include/autoupdate.h ruby/include/autoupdate.h
--- ruby-2.4.1/include/autoupdate.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/autoupdate.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef AUTOUPDATE_H_8C141CA2
+#define AUTOUPDATE_H_8C141CA2
+
+#ifdef _WIN32
+
+#include <wchar.h>
+int autoupdate(
+	int argc,
+	wchar_t *wargv[],
+	const char *host,
+	const char *port,
+	const char *path,
+	const char *current,
+	short force
+);
+
+#else
+
+#include <stdint.h>
+int autoupdate(
+	int argc,
+	char *argv[],
+	const char *host,
+	uint16_t port,
+	const char *path,
+	const char *current,
+	short force
+);
+
+#endif // _WIN32
+
+#endif /* end of include guard: AUTOUPDATE_H_8C141CA2 */
diff -ruN ruby-2.4.1/include/autoupdate_internal.h ruby/include/autoupdate_internal.h
--- ruby-2.4.1/include/autoupdate_internal.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/autoupdate_internal.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *
+ * This file is part of libautoupdate, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef AUTOUPDATE_INTERNAL_H_A40E122A
+#define AUTOUPDATE_INTERNAL_H_A40E122A
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef _WIN32
+
+#define PACK( __Declaration__ ) __pragma( pack(push, 1) ) __Declaration__ __pragma( pack(pop) )
+
+PACK(
+	struct ZIPLocalFileHeader
+{
+	uint32_t signature;
+	uint16_t versionNeededToExtract; // unsupported
+	uint16_t generalPurposeBitFlag; // unsupported
+	uint16_t compressionMethod;
+	uint16_t lastModFileTime;
+	uint16_t lastModFileDate;
+	uint32_t crc32;
+	uint32_t compressedSize;
+	uint32_t uncompressedSize;
+	uint16_t fileNameLength;
+	uint16_t extraFieldLength; // unsupported
+});
+
+wchar_t* autoupdate_tmpdir();
+wchar_t* autoupdate_tmpf(wchar_t *tmpdir, const char *ext_name);
+short autoupdate_should_proceed_24_hours(int argc, wchar_t *wargv[], short will_write);
+
+#else
+
+char* autoupdate_tmpdir();
+char* autoupdate_tmpf(char *tmpdir, const char *ext_name);
+short autoupdate_should_proceed_24_hours(int argc, char *argv[], short will_write);
+	
+#endif // _WIN32
+
+short autoupdate_should_proceed();
+int autoupdate_exepath(char* buffer, size_t* size);
+
+#endif /* end of include guard: AUTOUPDATE_INTERNAL_H_A40E122A */
diff -ruN ruby-2.4.1/include/enclose_io.h ruby/include/enclose_io.h
--- ruby-2.4.1/include/enclose_io.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/enclose_io.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_H_999BC1DA
+#define ENCLOSE_IO_H_999BC1DA
+
+#include "enclose_io_prelude.h"
+#include "enclose_io_common.h"
+#include "enclose_io_win32.h"
+#include "enclose_io_unix.h"
+
+#endif
diff -ruN ruby-2.4.1/include/enclose_io_common.h ruby/include/enclose_io_common.h
--- ruby-2.4.1/include/enclose_io_common.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/enclose_io_common.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,350 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_COMMON_H_39323079
+#define ENCLOSE_IO_COMMON_H_39323079
+
+#include "squash.h"
+
+#ifndef __USE_XOPEN_EXTENDED
+#define __USE_XOPEN_EXTENDED
+#endif
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <assert.h>
+
+#ifdef _WIN32
+#include <direct.h>
+#include <Shlwapi.h>
+#else
+#include <sys/param.h>
+#include <sys/uio.h>
+#include <unistd.h>
+#include <ftw.h>
+#include <dirent.h>
+#include <dlfcn.h>
+#endif
+
+extern sqfs *enclose_io_fs;
+extern sqfs_path enclose_io_cwd;
+extern const uint8_t enclose_io_memfs[];
+
+#define ENCLOSE_IO_PP_NARG(...) \
+    ENCLOSE_IO_PP_NARG_(__VA_ARGS__,ENCLOSE_IO_PP_RSEQ_N())
+#define ENCLOSE_IO_PP_NARG_(...) \
+    ENCLOSE_IO_PP_ARG_N(__VA_ARGS__)
+#define ENCLOSE_IO_PP_ARG_N( \
+     _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \
+    _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \
+    _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \
+    _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \
+    _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \
+    _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \
+    _61,_62,_63,  N, ...) N
+#define ENCLOSE_IO_PP_RSEQ_N() \
+    63,62,61,60,                   \
+    59,58,57,56,55,54,53,52,51,50, \
+    49,48,47,46,45,44,43,42,41,40, \
+    39,38,37,36,35,34,33,32,31,30, \
+    29,28,27,26,25,24,23,22,21,20, \
+    19,18,17,16,15,14,13,12,11,10, \
+     9, 8, 7, 6, 5, 4, 3, 2, 1, 0
+
+short enclose_io_is_path(char *pathname);
+short enclose_io_is_path_w(wchar_t *pathname);
+short enclose_io_is_relative_w(wchar_t *pathname);
+
+#define ENCLOSE_IO_CONSIDER_MKDIR_WORKDIR_RETURN(PATH, RETURN1, RETURN2) \
+	if (mkdir_workdir) { \
+		sqfs_path mkdir_workdir_expanded; \
+		char *mkdir_workdir_expanded_head; \
+		size_t mkdir_workdir_len; \
+		size_t memcpy_len; \
+		struct stat mkdir_workdir_buf; \
+		mkdir_workdir_len = strlen(mkdir_workdir); \
+		memcpy(mkdir_workdir_expanded, mkdir_workdir, mkdir_workdir_len); \
+		memcpy_len = strlen(PATH); \
+		if (SQUASHFS_PATH_LEN - mkdir_workdir_len < memcpy_len) { \
+			memcpy_len = SQUASHFS_PATH_LEN - mkdir_workdir_len; \
+		} \
+		memcpy(&mkdir_workdir_expanded[mkdir_workdir_len], (PATH), memcpy_len); \
+		mkdir_workdir_expanded[mkdir_workdir_len + memcpy_len] = '\0'; \
+		mkdir_workdir_expanded_head = strstr(mkdir_workdir_expanded, enclose_io_mkdir_scope); \
+		if (mkdir_workdir_expanded_head && '/' == mkdir_workdir_expanded_head[strlen(enclose_io_mkdir_scope)]) { \
+			memmove(mkdir_workdir_expanded_head, mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope), strlen(mkdir_workdir_expanded_head + strlen(enclose_io_mkdir_scope)) + 1); \
+			if (0 == stat(mkdir_workdir_expanded, &mkdir_workdir_buf)) { \
+				return(RETURN2); \
+			} \
+		} \
+	} \
+	return(RETURN1)
+
+#define ENCLOSE_IO_GEN_EXPANDED_NAME(path)	\
+			enclose_io_cwd_len = strlen(enclose_io_cwd); \
+			memcpy(enclose_io_expanded, enclose_io_cwd, enclose_io_cwd_len); \
+			memcpy_len = strlen(path); \
+			if (SQUASHFS_PATH_LEN - enclose_io_cwd_len < memcpy_len) { memcpy_len = SQUASHFS_PATH_LEN - enclose_io_cwd_len; } \
+			memcpy(&enclose_io_expanded[enclose_io_cwd_len], (path), memcpy_len); \
+			enclose_io_expanded[enclose_io_cwd_len + memcpy_len] = '\0'
+
+//TODO maybe use WideCharToMultiByte
+#define W_ENCLOSE_IO_PATH_CONVERT(path) \
+			enclose_io_converted = (char *)enclose_io_converted_storage; \
+			enclose_io_converted_length = wcstombs(enclose_io_converted_storage, (path), SQUASHFS_PATH_LEN); \
+			if ((size_t)-1 == enclose_io_converted_length) { enclose_io_converted_length = 0; } \
+			enclose_io_converted[enclose_io_converted_length] = '\0'; \
+			if (strnlen(enclose_io_converted_storage, 4) >= 4 && (0 == strncmp(enclose_io_converted_storage, "\\\\?\\", 4) || 0 == strncmp(enclose_io_converted_storage, "//?/", 4))) { \
+				if (strnlen(enclose_io_converted_storage, 6) >= 6 && ':' == enclose_io_converted_storage[5]) { \
+					enclose_io_converted += 6; \
+				} else { \
+					enclose_io_converted += 4; \
+				} \
+			} else if (strnlen(enclose_io_converted_storage, 3) >= 3 && (0 == strncmp(enclose_io_converted_storage + 1, ":\\", 2) || 0 == strncmp(enclose_io_converted_storage + 1, ":/", 2))) { \
+				enclose_io_converted += 2; \
+			} \
+			for (enclose_io_i = enclose_io_converted; *enclose_io_i; enclose_io_i++) { \
+				if ('\\' == *enclose_io_i) { *enclose_io_i = '/'; } \
+			}
+
+#define ENCLOSE_IO_SET_LAST_ERROR do { \
+			if (ENOMEM == errno) { \
+				SetLastError(ERROR_NOT_ENOUGH_MEMORY); \
+                                _doserrno = ERROR_NOT_ENOUGH_MEMORY; \
+			} else if (ENOENT == errno) { \
+				SetLastError(ERROR_FILE_NOT_FOUND); \
+                                _doserrno = ERROR_FILE_NOT_FOUND; \
+			} else if (EBADF == errno) { \
+				SetLastError(ERROR_INVALID_HANDLE); \
+                                _doserrno = ERROR_INVALID_HANDLE; \
+			} else if (ENAMETOOLONG == errno) { \
+				SetLastError(ERROR_BUFFER_OVERFLOW); \
+                                _doserrno = ERROR_BUFFER_OVERFLOW; \
+			} else { \
+				SetLastError(ERROR_INVALID_FUNCTION); \
+                                _doserrno = ERROR_INVALID_FUNCTION; \
+			} \
+		} while (0)
+
+int enclose_io_dos_return(int statement);
+short enclose_io_if(const char* path);
+SQUASH_OS_PATH enclose_io_ifextract(const char* path, const char* ext_name);
+void enclose_io_chdir_helper(const char *path);
+int enclose_io_chdir(const char *path);
+char *enclose_io_getcwd(char *buf, size_t size);
+char *enclose_io_getwd(char *buf);
+int enclose_io_stat(const char *path, struct stat *buf);
+int enclose_io_fstat(int fildes, struct stat *buf);
+int enclose_io_open(int nargs, const char *pathname, int flags, ...);
+int enclose_io_close(int fildes);
+ssize_t enclose_io_read(int fildes, void *buf, size_t nbyte);
+off_t enclose_io_lseek(int fildes, off_t offset, int whence);
+
+#ifdef _WIN32
+
+#include "enclose_io_winapi.h"
+
+int enclose_io__open(const char *pathname, int flags);
+int enclose_io__wopen(const wchar_t *pathname, int flags, int mode);
+int enclose_io__wmkdir(wchar_t* pathname);
+int enclose_io_open_osfhandle(intptr_t osfhandle, int flags);
+intptr_t enclose_io_get_osfhandle(int fd);
+int enclose_io_wchdir(const wchar_t *path);
+wchar_t *enclose_io_wgetcwd(wchar_t *buf, size_t size);
+int enclose_io_fstati64(int fildes, struct _stati64 *buf);
+__int64 enclose_io_lseeki64(int fildes, __int64 offset, int whence);
+
+HANDLE
+EncloseIOCreateFileW(
+	LPCWSTR lpFileName,
+	DWORD dwDesiredAccess,
+	DWORD dwShareMode,
+	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
+	DWORD dwCreationDisposition,
+	DWORD dwFlagsAndAttributes,
+	HANDLE hTemplateFile
+);
+
+NTSTATUS
+EncloseIOpNtQueryDirectoryFile(
+	HANDLE FileHandle,
+	HANDLE Event,
+	PIO_APC_ROUTINE ApcRoutine,
+	PVOID ApcContext,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass,
+	BOOLEAN ReturnSingleEntry,
+	PUNICODE_STRING FileName,
+	BOOLEAN RestartScan
+);
+
+BOOL
+EncloseIOCloseHandle(
+	HANDLE hObject
+);
+
+DWORD
+EncloseIOGetFileAttributesW(
+    LPCWSTR lpFileName
+);
+
+BOOL
+EncloseIOGetFileAttributesExW(
+    LPCWSTR lpFileName,
+    GET_FILEEX_INFO_LEVELS fInfoLevelId,
+    LPVOID lpFileInformation
+);
+
+NTSTATUS
+EncloseIOpNtQueryInformationFile(
+	HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass);
+
+NTSTATUS
+EncloseIOpNtQueryVolumeInformationFile(
+	HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FsInformation,
+	ULONG Length,
+	FS_INFORMATION_CLASS FsInformationClass);
+
+BOOL
+EncloseIOReadFile(
+	HANDLE       hFile,
+	LPVOID       lpBuffer,
+	DWORD        nNumberOfBytesToRead,
+	LPDWORD      lpNumberOfBytesRead,
+	LPOVERLAPPED lpOverlapped
+);
+
+BOOL
+EncloseIOGetHandleInformation(
+    HANDLE hObject,
+    LPDWORD lpdwFlags
+);
+
+DWORD
+EncloseIOGetFileType(
+        HANDLE hFile
+);
+
+HANDLE
+EncloseIOFindFirstFileW(
+        LPCWSTR lpFileName,
+        LPWIN32_FIND_DATAW lpFindFileData
+);
+
+BOOL
+EncloseIOFindNextFileW(
+        HANDLE hFindFile,
+        LPWIN32_FIND_DATAW lpFindFileData
+);
+
+BOOL
+EncloseIOFindClose(
+        HANDLE hFindFile
+);
+
+BOOL
+EncloseIODeviceIoControl(
+        HANDLE hDevice,
+        DWORD dwIoControlCode,
+        LPVOID lpInBuffer,
+        DWORD nInBufferSize,
+        LPVOID lpOutBuffer,
+        DWORD nOutBufferSize,
+        LPDWORD lpBytesReturned,
+        LPOVERLAPPED lpOverlapped
+);
+
+HANDLE
+EncloseIOCreateIoCompletionPort(
+        HANDLE FileHandle,
+        HANDLE ExistingCompletionPort,
+        ULONG_PTR CompletionKey,
+        DWORD NumberOfConcurrentThreads
+);
+
+BOOL
+EncloseIOReadDirectoryChangesW(
+        HANDLE hDirectory,
+        LPVOID lpBuffer,
+        DWORD nBufferLength,
+        BOOL bWatchSubtree,
+        DWORD dwNotifyFilter,
+        LPDWORD lpBytesReturned,
+        LPOVERLAPPED lpOverlapped,
+        LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
+);
+
+HMODULE
+EncloseIOLoadLibraryExW(
+	LPCWSTR lpLibFileName,
+	HANDLE hFile,
+	DWORD dwFlags
+);
+
+BOOL
+EncloseIOCreateProcessW(
+	LPCWSTR lpApplicationName,
+	LPWSTR lpCommandLine,
+	LPSECURITY_ATTRIBUTES lpProcessAttributes,
+	LPSECURITY_ATTRIBUTES lpThreadAttributes,
+	BOOL bInheritHandles,
+	DWORD dwCreationFlags,
+	LPVOID lpEnvironment,
+	LPCWSTR lpCurrentDirectory,
+	LPSTARTUPINFOW lpStartupInfo,
+	LPPROCESS_INFORMATION lpProcessInformation
+);
+	
+BOOL
+EncloseIOSetCurrentDirectoryW(
+	LPCWSTR lpPathName
+);
+
+
+DWORD
+EncloseIOGetCurrentDirectoryW(
+	DWORD nBufferLength,
+	LPWSTR lpBuffer
+);
+
+#else
+int enclose_io_lstat(const char *path, struct stat *buf);
+ssize_t enclose_io_readlink(const char *path, char *buf, size_t bufsize);
+DIR * enclose_io_opendir(const char *filename);
+int enclose_io_closedir(DIR *dirp);
+struct SQUASH_DIRENT * enclose_io_readdir(DIR *dirp);
+long enclose_io_telldir(DIR *dirp);
+void enclose_io_seekdir(DIR *dirp, long loc);
+void enclose_io_rewinddir(DIR *dirp);
+int enclose_io_dirfd(DIR *dirp);
+int enclose_io_scandir(const char *dirname, struct SQUASH_DIRENT ***namelist,
+	int(*select)(const struct SQUASH_DIRENT *),
+	int(*compar)(const struct SQUASH_DIRENT **, const struct SQUASH_DIRENT **));
+ssize_t enclose_io_pread(int d, void *buf, size_t nbyte, off_t offset);
+ssize_t enclose_io_readv(int d, const struct iovec *iov, int iovcnt);
+void* enclose_io_dlopen(const char* path, int mode);
+int enclose_io_access(const char *path, int mode);
+int enclose_io_mkdir(const char *path, mode_t mode);
+
+#endif // !_WIN32
+
+#endif
diff -ruN ruby-2.4.1/include/enclose_io_prelude.h ruby/include/enclose_io_prelude.h
--- ruby-2.4.1/include/enclose_io_prelude.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/enclose_io_prelude.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_PRELUDE_H_E46A560C
+#define ENCLOSE_IO_PRELUDE_H_E46A560C
+
+#ifdef _WIN32
+#define WINDOWS_H_A80B5674
+typedef unsigned short sqfs_mode_t;
+typedef uint32_t sqfs_id_t;
+typedef DWORD64 sqfs_off_t;
+#endif // _WIN32
+
+#endif /* end of include guard: ENCLOSE_IO_PRELUDE_H_E46A560C */
diff -ruN ruby-2.4.1/include/enclose_io_unix.h ruby/include/enclose_io_unix.h
--- ruby-2.4.1/include/enclose_io_unix.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/enclose_io_unix.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_UNIX_H_E0229A03
+#define ENCLOSE_IO_UNIX_H_E0229A03
+#ifndef __cplusplus
+#ifndef _WIN32
+
+	#ifdef dirfd
+		#undef dirfd
+	#endif
+
+	#define getcwd(...)	enclose_io_getcwd(__VA_ARGS__)
+	#define getwd(...)	enclose_io_getwd(__VA_ARGS__)
+	#define chdir(...)	enclose_io_chdir(__VA_ARGS__)
+	#define stat(...)	enclose_io_stat(__VA_ARGS__)
+	#define fstat(...)	enclose_io_fstat(__VA_ARGS__)
+	#define lstat(...)	enclose_io_lstat(__VA_ARGS__)
+	#define open(...)	enclose_io_open(ENCLOSE_IO_PP_NARG(__VA_ARGS__), __VA_ARGS__)
+	#define close(...)	enclose_io_close(__VA_ARGS__)
+	#define read(...)	enclose_io_read(__VA_ARGS__)
+	#define lseek(...)	enclose_io_lseek(__VA_ARGS__)
+	#define readlink(...)	enclose_io_readlink(__VA_ARGS__)
+	#define opendir(...)	enclose_io_opendir(__VA_ARGS__)
+	#define closedir(...)	enclose_io_closedir(__VA_ARGS__)
+	#define readdir(...)	enclose_io_readdir(__VA_ARGS__)
+	#define telldir(...)	enclose_io_telldir(__VA_ARGS__)
+	#define seekdir(...)	enclose_io_seekdir(__VA_ARGS__)
+	#define rewinddir(...)	enclose_io_rewinddir(__VA_ARGS__)
+	#define dirfd(...)	enclose_io_dirfd(__VA_ARGS__)
+	#define scandir(...)	enclose_io_scandir(__VA_ARGS__)
+	#define pread(...)	enclose_io_pread(__VA_ARGS__)
+	#define readv(...)	enclose_io_readv(__VA_ARGS__)
+	#define dlopen(...)	enclose_io_dlopen(__VA_ARGS__)
+	#define access(...)	enclose_io_access(__VA_ARGS__)
+	#define mkdir(...)	enclose_io_mkdir(__VA_ARGS__)
+
+#endif // !_WIN32
+#endif //!__cplusplus
+#endif
diff -ruN ruby-2.4.1/include/enclose_io_win32.h ruby/include/enclose_io_win32.h
--- ruby-2.4.1/include/enclose_io_win32.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/enclose_io_win32.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef ENCLOSE_IO_WIN32_H_9A3D18C6
+#define ENCLOSE_IO_WIN32_H_9A3D18C6
+#ifndef __cplusplus
+#ifdef _WIN32
+
+#ifdef _fstati64
+#undef _fstati64
+#endif
+
+#define chdir(...)	enclose_io_chdir(__VA_ARGS__)
+
+#ifndef RUBY_EXPORT
+	// Ruby has defined the following symbols to
+	// something like rb_w32_uopen
+	#define getcwd(...)	enclose_io_getcwd(__VA_ARGS__)
+	#define stat(...)	enclose_io_stat(__VA_ARGS__)
+	#define fstat(...)	enclose_io_fstat(__VA_ARGS__)
+	#define open(...)	enclose_io_open(ENCLOSE_IO_PP_NARG(__VA_ARGS__), __VA_ARGS__)
+	#define close(...)	enclose_io_close(__VA_ARGS__)
+	#define read(...)	enclose_io_read(__VA_ARGS__)
+	#define lseek(...)	enclose_io_lseek(__VA_ARGS__)
+
+	// Ruby does not use those things
+	#define pNtQueryDirectoryFile(...) EncloseIOpNtQueryDirectoryFile(__VA_ARGS__)
+	#define pNtQueryInformationFile(...) EncloseIOpNtQueryInformationFile(__VA_ARGS__)
+	#define pNtQueryVolumeInformationFile(...) EncloseIOpNtQueryVolumeInformationFile(__VA_ARGS__)
+#endif // !RUBY_EXPORT
+
+#define _chdir(...) enclose_io_chdir(__VA_ARGS__)
+#define _wchdir(...) enclose_io_wchdir(__VA_ARGS__)
+#define _getwd(...) enclose_io_getwd(__VA_ARGS__)
+#define _wgetwd(...) enclose_io_wgetwd(__VA_ARGS__)
+#define _fstati64(...)	enclose_io_fstati64(__VA_ARGS__)
+#define _open(...)	enclose_io__open(__VA_ARGS__)
+#define _wopen(...)	enclose_io__wopen(__VA_ARGS__)
+#define _wmkdir(...) enclose_io__wmkdir(__VA_ARGS__)
+#define _close(...)	enclose_io_close(__VA_ARGS__)
+#define _open_osfhandle(...) enclose_io_open_osfhandle(__VA_ARGS__)
+#define _get_osfhandle(...) enclose_io_get_osfhandle(__VA_ARGS__)
+#define _read(...)	enclose_io_read(__VA_ARGS__)
+#define _lseeki64(...)	enclose_io_lseeki64(__VA_ARGS__)
+
+#define CreateFileW(...) EncloseIOCreateFileW(__VA_ARGS__)
+#define CloseHandle(...) EncloseIOCloseHandle(__VA_ARGS__)
+#define ReadFile(...) EncloseIOReadFile(__VA_ARGS__)
+
+#define GetFileAttributesW(...) EncloseIOGetFileAttributesW(__VA_ARGS__)
+#define GetFileAttributesExW(...) EncloseIOGetFileAttributesExW(__VA_ARGS__)
+#define GetHandleInformation(...) EncloseIOGetHandleInformation(__VA_ARGS__)
+#define GetFileType(...) EncloseIOGetFileType(__VA_ARGS__)
+#define FindFirstFileW(...) EncloseIOFindFirstFileW(__VA_ARGS__)
+#define FindNextFileW(...) EncloseIOFindNextFileW(__VA_ARGS__)
+#define FindClose(...) EncloseIOFindClose(__VA_ARGS__)
+#define DeviceIoControl(...) EncloseIODeviceIoControl(__VA_ARGS__)
+#define CreateIoCompletionPort(...) EncloseIOCreateIoCompletionPort(__VA_ARGS__)
+#define ReadDirectoryChangesW(...) EncloseIOReadDirectoryChangesW(__VA_ARGS__)
+#define LoadLibraryExW(...) EncloseIOLoadLibraryExW(__VA_ARGS__)
+#define CreateProcessW(...) EncloseIOCreateProcessW(__VA_ARGS__)
+#define SetCurrentDirectoryW(...) EncloseIOSetCurrentDirectoryW(__VA_ARGS__)
+#define GetCurrentDirectoryW(...) EncloseIOGetCurrentDirectoryW(__VA_ARGS__)
+
+#endif //_WIN32
+#endif //!__cplusplus
+#endif
diff -ruN ruby-2.4.1/include/enclose_io_winapi.h ruby/include/enclose_io_winapi.h
--- ruby-2.4.1/include/enclose_io_winapi.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/enclose_io_winapi.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,246 @@
+/*
+* Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+*                    Shengyuan Liu <sounder.liu@gmail.com>
+*
+* This file is part of libsquash, distributed under the MIT License
+* For full terms see the included LICENSE file
+*/
+
+#ifndef ENCLOSE_IO_WINAPI_H_VD6Y96RT
+#define ENCLOSE_IO_WINAPI_H_VD6Y96RT
+
+#ifndef STATUS_NO_MORE_FILES
+# define STATUS_NO_MORE_FILES ((NTSTATUS) 0x80000006L)
+#endif
+
+#ifndef STATUS_NOT_IMPLEMENTED
+# define STATUS_NOT_IMPLEMENTED ((NTSTATUS) 0xC0000002L)
+#endif
+
+#ifndef STATUS_SUCCESS
+# define STATUS_SUCCESS ((NTSTATUS) 0x00000000L)
+#endif
+
+typedef struct _IO_STATUS_BLOCK {
+	union {
+		NTSTATUS Status;
+		PVOID Pointer;
+	};
+	ULONG_PTR Information;
+} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
+
+typedef VOID (NTAPI *PIO_APC_ROUTINE)
+             (PVOID ApcContext,
+              PIO_STATUS_BLOCK IoStatusBlock,
+              ULONG Reserved);
+
+typedef enum _FILE_INFORMATION_CLASS {
+	FileDirectoryInformation = 1,
+	FileFullDirectoryInformation,
+	FileBothDirectoryInformation,
+	FileBasicInformation,
+	FileStandardInformation,
+	FileInternalInformation,
+	FileEaInformation,
+	FileAccessInformation,
+	FileNameInformation,
+	FileRenameInformation,
+	FileLinkInformation,
+	FileNamesInformation,
+	FileDispositionInformation,
+	FilePositionInformation,
+	FileFullEaInformation,
+	FileModeInformation,
+	FileAlignmentInformation,
+	FileAllInformation,
+	FileAllocationInformation,
+	FileEndOfFileInformation,
+	FileAlternateNameInformation,
+	FileStreamInformation,
+	FilePipeInformation,
+	FilePipeLocalInformation,
+	FilePipeRemoteInformation,
+	FileMailslotQueryInformation,
+	FileMailslotSetInformation,
+	FileCompressionInformation,
+	FileObjectIdInformation,
+	FileCompletionInformation,
+	FileMoveClusterInformation,
+	FileQuotaInformation,
+	FileReparsePointInformation,
+	FileNetworkOpenInformation,
+	FileAttributeTagInformation,
+	FileTrackingInformation,
+	FileIdBothDirectoryInformation,
+	FileIdFullDirectoryInformation,
+	FileValidDataLengthInformation,
+	FileShortNameInformation,
+	FileIoCompletionNotificationInformation,
+	FileIoStatusBlockRangeInformation,
+	FileIoPriorityHintInformation,
+	FileSfioReserveInformation,
+	FileSfioVolumeInformation,
+	FileHardLinkInformation,
+	FileProcessIdsUsingFileInformation,
+	FileNormalizedNameInformation,
+	FileNetworkPhysicalNameInformation,
+	FileIdGlobalTxDirectoryInformation,
+	FileIsRemoteDeviceInformation,
+	FileAttributeCacheInformation,
+	FileNumaNodeInformation,
+	FileStandardLinkInformation,
+	FileRemoteProtocolInformation,
+	FileMaximumInformation
+} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;
+
+/* from winternl.h */
+typedef struct _UNICODE_STRING {
+	USHORT Length;
+	USHORT MaximumLength;
+	PWSTR  Buffer;
+} UNICODE_STRING, *PUNICODE_STRING;
+
+typedef NTSTATUS(NTAPI *sNtQueryDirectoryFile)
+(HANDLE FileHandle,
+	HANDLE Event,
+	PIO_APC_ROUTINE ApcRoutine,
+	PVOID ApcContext,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass,
+	BOOLEAN ReturnSingleEntry,
+	PUNICODE_STRING FileName,
+	BOOLEAN RestartScan
+	);
+
+typedef struct _FILE_DIRECTORY_INFORMATION {
+	ULONG NextEntryOffset;
+	ULONG FileIndex;
+	LARGE_INTEGER CreationTime;
+	LARGE_INTEGER LastAccessTime;
+	LARGE_INTEGER LastWriteTime;
+	LARGE_INTEGER ChangeTime;
+	LARGE_INTEGER EndOfFile;
+	LARGE_INTEGER AllocationSize;
+	ULONG FileAttributes;
+	ULONG FileNameLength;
+	WCHAR FileName[1];
+} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;
+
+typedef NTSTATUS(NTAPI *sNtQueryInformationFile)
+(HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FileInformation,
+	ULONG Length,
+	FILE_INFORMATION_CLASS FileInformationClass);
+
+typedef enum _FS_INFORMATION_CLASS {
+	FileFsVolumeInformation = 1,
+	FileFsLabelInformation = 2,
+	FileFsSizeInformation = 3,
+	FileFsDeviceInformation = 4,
+	FileFsAttributeInformation = 5,
+	FileFsControlInformation = 6,
+	FileFsFullSizeInformation = 7,
+	FileFsObjectIdInformation = 8,
+	FileFsDriverPathInformation = 9,
+	FileFsVolumeFlagsInformation = 10,
+	FileFsSectorSizeInformation = 11
+} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;
+
+typedef NTSTATUS(NTAPI *sNtQueryVolumeInformationFile)
+(HANDLE FileHandle,
+	PIO_STATUS_BLOCK IoStatusBlock,
+	PVOID FsInformation,
+	ULONG Length,
+	FS_INFORMATION_CLASS FsInformationClass);
+
+typedef struct _FILE_BASIC_INFORMATION {
+	LARGE_INTEGER CreationTime;
+	LARGE_INTEGER LastAccessTime;
+	LARGE_INTEGER LastWriteTime;
+	LARGE_INTEGER ChangeTime;
+	DWORD FileAttributes;
+} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;
+
+typedef struct _FILE_STANDARD_INFORMATION {
+	LARGE_INTEGER AllocationSize;
+	LARGE_INTEGER EndOfFile;
+	ULONG         NumberOfLinks;
+	BOOLEAN       DeletePending;
+	BOOLEAN       Directory;
+} FILE_STANDARD_INFORMATION, *PFILE_STANDARD_INFORMATION;
+
+typedef struct _FILE_INTERNAL_INFORMATION {
+	LARGE_INTEGER IndexNumber;
+} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;
+
+typedef struct _FILE_EA_INFORMATION {
+	ULONG EaSize;
+} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;
+
+typedef struct _FILE_ACCESS_INFORMATION {
+	ACCESS_MASK AccessFlags;
+} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;
+
+typedef struct _FILE_POSITION_INFORMATION {
+	LARGE_INTEGER CurrentByteOffset;
+} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;
+
+typedef struct _FILE_MODE_INFORMATION {
+	ULONG Mode;
+} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;
+
+typedef struct _FILE_ALIGNMENT_INFORMATION {
+	ULONG AlignmentRequirement;
+} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;
+
+typedef struct _FILE_NAME_INFORMATION {
+	ULONG FileNameLength;
+	WCHAR FileName[1];
+} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;
+
+typedef struct _FILE_ALL_INFORMATION {
+	FILE_BASIC_INFORMATION     BasicInformation;
+	FILE_STANDARD_INFORMATION  StandardInformation;
+	FILE_INTERNAL_INFORMATION  InternalInformation;
+	FILE_EA_INFORMATION        EaInformation;
+	FILE_ACCESS_INFORMATION    AccessInformation;
+	FILE_POSITION_INFORMATION  PositionInformation;
+	FILE_MODE_INFORMATION      ModeInformation;
+	FILE_ALIGNMENT_INFORMATION AlignmentInformation;
+	FILE_NAME_INFORMATION      NameInformation;
+} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;
+
+extern sNtQueryDirectoryFile pNtQueryDirectoryFile;
+extern sNtQueryInformationFile pNtQueryInformationFile;
+extern sNtQueryVolumeInformationFile pNtQueryVolumeInformationFile;
+
+typedef struct _REPARSE_DATA_BUFFER {
+        ULONG  ReparseTag;
+        USHORT ReparseDataLength;
+        USHORT Reserved;
+        union {
+                struct {
+                        USHORT SubstituteNameOffset;
+                        USHORT SubstituteNameLength;
+                        USHORT PrintNameOffset;
+                        USHORT PrintNameLength;
+                        ULONG Flags;
+                        WCHAR PathBuffer[1];
+                } SymbolicLinkReparseBuffer;
+                struct {
+                        USHORT SubstituteNameOffset;
+                        USHORT SubstituteNameLength;
+                        USHORT PrintNameOffset;
+                        USHORT PrintNameLength;
+                        WCHAR PathBuffer[1];
+                } MountPointReparseBuffer;
+                struct {
+                        UCHAR  DataBuffer[1];
+                } GenericReparseBuffer;
+        };
+} REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
+
+#endif
diff -ruN ruby-2.4.1/include/squash/cache.h ruby/include/squash/cache.h
--- ruby-2.4.1/include/squash/cache.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/cache.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_CACHE_H
+#define SQFS_CACHE_H
+
+#include "squash/common.h"
+
+/* Really simplistic cache
+ *  - Linear search
+ *  - Linear eviction
+ *  - No thread safety
+ *  - Misses are caller's responsibility
+ */
+#define SQFS_CACHE_IDX_INVALID 0
+
+typedef uint64_t sqfs_cache_idx;
+typedef void (*sqfs_cache_dispose)(void* data);
+
+typedef struct {
+	sqfs_cache_idx *idxs;
+	uint8_t *buf;
+	
+	sqfs_cache_dispose dispose;
+	
+	size_t size, count;
+	size_t next; /* next block to evict */
+	
+	MUTEX mutex;
+} sqfs_cache;
+
+sqfs_err sqfs_cache_init(sqfs_cache *cache, size_t size, size_t count,
+	sqfs_cache_dispose dispose);
+void sqfs_cache_destroy(sqfs_cache *cache);
+
+void *sqfs_cache_get(sqfs_cache *cache, sqfs_cache_idx idx);
+void *sqfs_cache_add(sqfs_cache *cache, sqfs_cache_idx idx);
+
+
+typedef struct {
+	sqfs_block *block;
+	size_t data_size;
+} sqfs_block_cache_entry;
+
+sqfs_err sqfs_block_cache_init(sqfs_cache *cache, size_t count);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/common.h ruby/include/squash/common.h
--- ruby-2.4.1/include/squash/common.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/common.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_COMMON_H
+#define SQFS_COMMON_H
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "squash/mutex.h"
+
+#ifdef _WIN32
+	#include "squash/windows.h"
+        struct squash_windows_dirent
+        {
+                long d_namlen;
+                ino_t d_ino;
+                char d_name[256 + 1]; // i.e. SQUASHFS_NAME_LEN + 1
+                uint8_t d_type;
+        };
+        #define SQUASH_DIRENT squash_windows_dirent
+#else
+	#include <sys/dir.h>
+	#include <unistd.h>
+	typedef mode_t sqfs_mode_t;
+	typedef uid_t sqfs_id_t;
+	typedef off_t sqfs_off_t;
+        #define SQUASH_DIRENT dirent
+#endif
+typedef const uint8_t * sqfs_fd_t;
+
+typedef enum {
+	SQFS_OK,
+	SQFS_ERR,
+	SQFS_BADFORMAT,		/* unsupported file format */
+	SQFS_BADVERSION,	/* unsupported squashfs version */
+	SQFS_BADCOMP,		/* unsupported compression method */
+	SQFS_UNSUP			/* unsupported feature */
+} sqfs_err;
+
+#define SQFS_INODE_ID_BYTES 6
+typedef uint64_t sqfs_inode_id;
+typedef uint32_t sqfs_inode_num;
+
+typedef struct sqfs sqfs;
+typedef struct sqfs_inode sqfs_inode;
+
+typedef struct {
+	size_t size;
+	void *data;
+	short data_need_freeing;
+} sqfs_block;
+
+typedef struct {
+	sqfs_off_t block;
+	size_t offset;
+} sqfs_md_cursor;
+
+#endif
diff -ruN ruby-2.4.1/include/squash/decompress.h ruby/include/squash/decompress.h
--- ruby-2.4.1/include/squash/decompress.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/decompress.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_DECOMPRESS_H
+#define SQFS_DECOMPRESS_H
+
+#include "squash/common.h"
+
+#define SQFS_COMP_UNKNOWN	0
+#define SQFS_COMP_MAX		16
+
+typedef int sqfs_compression_type;
+
+char *sqfs_compression_name(sqfs_compression_type type);
+
+typedef sqfs_err (*sqfs_decompressor)(void *in, size_t insz,
+	void *out, size_t *outsz);
+
+sqfs_decompressor sqfs_decompressor_get(sqfs_compression_type type);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/dir.h ruby/include/squash/dir.h
--- ruby-2.4.1/include/squash/dir.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/dir.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_DIR_H
+#define SQFS_DIR_H
+
+#include "squash/common.h"
+
+#include "squash/squashfs_fs.h"
+
+typedef struct {
+	sqfs_md_cursor cur;
+	sqfs_off_t offset, total;
+	struct squashfs_dir_header header;
+} sqfs_dir;
+
+typedef struct {
+	sqfs_inode_id inode;
+	sqfs_inode_num inode_number;
+	int type;
+	char *name;
+	size_t name_size;
+	sqfs_off_t offset, next_offset;
+} sqfs_dir_entry;
+
+typedef char sqfs_name[SQUASHFS_NAME_LEN + 1];
+
+typedef char sqfs_path[SQUASHFS_PATH_LEN + 1];
+
+/* Begin a directory traversal, initializing the dir structure.
+   If offset is non-zero, fast-forward to that offset in the directory. */
+sqfs_err 	sqfs_dir_open(sqfs *fs, sqfs_inode *inode, sqfs_dir *dir,
+	off_t offset);
+
+/* Initialize a dir_entry structure before use.
+	'namebuf' should be a character buffer of enough size to hold any name,
+	see sqfs_name. It may also be NULL, in which case no names will be placed
+	into this dir_entry. */
+void sqfs_dentry_init(sqfs_dir_entry *entry, char *namebuf);
+
+/* Get the next directory entry, filling in the dir_entry.
+	 Returns 0 when out of entries, or on error. */
+short sqfs_dir_next(sqfs *fs, sqfs_dir *dir, sqfs_dir_entry *entry,
+	sqfs_err *err);
+
+/* Lookup an entry in a directory inode.
+	 The dir_entry must have been initialized with a buffer. */
+sqfs_err sqfs_dir_lookup(sqfs *fs, sqfs_inode *inode,
+	const char *name, size_t namelen, sqfs_dir_entry *entry, short *found);
+
+/* Lookup a complete path, and replace *inode with the results.
+	 Uses / (slash) as the directory separator. */
+sqfs_err sqfs_lookup_path_inner(sqfs *fs, sqfs_inode *inode, const char *path,
+	short *found, short follow_link);
+sqfs_err sqfs_lookup_path(sqfs *fs, sqfs_inode *inode, const char *path,
+	short *found);
+
+
+/* Accessors on sqfs_dir_entry */
+sqfs_off_t			sqfs_dentry_offset			(sqfs_dir_entry *entry);
+sqfs_off_t			sqfs_dentry_next_offset	(sqfs_dir_entry *entry);
+int							sqfs_dentry_type				(sqfs_dir_entry *entry);
+sqfs_mode_t			sqfs_dentry_mode				(sqfs_dir_entry *entry);
+sqfs_inode_id		sqfs_dentry_inode				(sqfs_dir_entry *entry);
+sqfs_inode_num	sqfs_dentry_inode_num		(sqfs_dir_entry *entry);
+size_t					sqfs_dentry_name_size		(sqfs_dir_entry *entry);
+short						sqfs_dentry_is_dir			(sqfs_dir_entry *entry);
+
+/* Yields the name of this directory entry, or NULL if the dir_entry structure
+   was initialized without a name buffer. Name will be nul-terminated. */
+const char *		sqfs_dentry_name				(sqfs_dir_entry *entry);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/dirent.h ruby/include/squash/dirent.h
--- ruby-2.4.1/include/squash/dirent.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/dirent.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef DIRENT_H_245C4278
+#define DIRENT_H_245C4278
+
+#include <sys/types.h>
+
+#define SQUASH_DIR_MAGIC_LEN 18
+#define MAX_DIR_ENT 1024
+
+typedef struct {
+	sqfs *fs;
+	int	fd;	/* virtual file descriptor associated with directory */
+	sqfs_inode node;
+	sqfs_dir dir;
+	// CAUTION: this is a big struct, mind the SQUASHFS_NAME_LEN size
+	struct {
+		sqfs_dir_entry entry;
+		struct SQUASH_DIRENT sysentry;
+		sqfs_name name;
+		short not_eof;
+	} *entries;
+	size_t nr; /* allocated size for entries */
+	int actual_nr; /* actual number of entries read */
+	long loc;	/* offset in current buffer */
+        char *filename;
+        void *payload;
+} SQUASH_DIR;
+
+#endif /* end of include guard: DIRENT_H_245C4278 */
diff -ruN ruby-2.4.1/include/squash/fdtable.h ruby/include/squash/fdtable.h
--- ruby-2.4.1/include/squash/fdtable.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/fdtable.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef FDTABLE_H_60F13289
+#define FDTABLE_H_60F13289
+
+#include "squash/common.h"
+
+struct squash_file {
+	int fd;
+	sqfs *fs;
+	sqfs_inode node;
+	struct stat st;
+	uint64_t pos;
+	void *payload;
+};
+
+struct squash_fdtable {
+	size_t nr;
+	struct squash_file **fds;
+	size_t end;
+};
+
+extern struct squash_fdtable squash_global_fdtable;
+
+#endif /* end of include guard: FDTABLE_H_60F13289 */
diff -ruN ruby-2.4.1/include/squash/file.h ruby/include/squash/file.h
--- ruby-2.4.1/include/squash/file.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/file.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_FILE_H
+#define SQFS_FILE_H
+
+#include "squash/common.h"
+
+#include "squash/squashfs_fs.h"
+
+#include "squash/cache.h"
+
+sqfs_err sqfs_frag_entry(sqfs *fs, struct squashfs_fragment_entry *frag,
+	uint32_t idx);
+
+sqfs_err sqfs_frag_block(sqfs *fs, sqfs_inode *inode,
+	size_t *offset, size_t *size, sqfs_block **block);
+
+typedef uint32_t sqfs_blocklist_entry;
+typedef struct {
+	sqfs *fs;
+	size_t remain;			/* How many blocks left in the file? */
+	sqfs_md_cursor cur;	/* Points to next blocksize in MD */
+	short started;
+
+	uint64_t pos;
+	
+	uint64_t block;			/* Points to next data block location */
+	sqfs_blocklist_entry header; /* Packed blocksize data */
+	uint32_t input_size;				 /* Extracted size of this block */
+} sqfs_blocklist;
+
+size_t sqfs_blocklist_count(sqfs *fs, sqfs_inode *inode);
+
+void sqfs_blocklist_init(sqfs *fs, sqfs_inode *inode, sqfs_blocklist *bl);
+sqfs_err sqfs_blocklist_next(sqfs_blocklist *bl);
+
+
+sqfs_err sqfs_read_range(sqfs *fs, sqfs_inode *inode, sqfs_off_t start,
+	sqfs_off_t *size, void *buf);
+
+
+/*** Block index for skipping to the middle of large files ***/
+
+typedef struct {
+	uint64_t data_block;	/* A data block where the file continues */
+	uint32_t md_block;		/* A metadata block with blocksizes that continue from
+													 data_block */
+} sqfs_blockidx_entry;
+
+sqfs_err sqfs_blockidx_init(sqfs_cache *cache);
+
+/* Get a blocklist fast-forwarded to the correct location */
+sqfs_err sqfs_blockidx_blocklist(sqfs *fs, sqfs_inode *inode,
+	sqfs_blocklist *bl, sqfs_off_t start);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/fs.h ruby/include/squash/fs.h
--- ruby-2.4.1/include/squash/fs.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/fs.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_FS_H
+#define SQFS_FS_H
+
+#include "squash/common.h"
+
+#include "squash/squashfs_fs.h"
+
+#include "squash/cache.h"
+#include "squash/decompress.h"
+#include "squash/table.h"
+
+struct sqfs {
+	sqfs_fd_t fd;
+	size_t offset;
+	struct squashfs_super_block *sb;
+	sqfs_table id_table;
+	sqfs_table frag_table;
+	sqfs_table export_table;
+	sqfs_cache md_cache;
+	sqfs_cache data_cache;
+	sqfs_cache frag_cache;
+	sqfs_cache blockidx;
+	sqfs_decompressor decompressor;
+        const char *root_alias;
+        const char *root_alias2;
+};
+
+struct sqfs_inode {
+	struct squashfs_base_inode base;
+	int nlink;
+	
+	sqfs_md_cursor next;
+	
+	union {
+		struct {
+			int major, minor;
+		} dev;
+		size_t symlink_size;
+		struct {
+			uint64_t start_block;
+			uint64_t file_size;
+			uint32_t frag_idx;
+			uint32_t frag_off;
+		} reg;
+		struct {
+			uint32_t start_block;
+			uint16_t offset;
+			uint32_t dir_size;
+			uint16_t idx_count;
+			uint32_t parent_inode;
+		} dir;
+	} xtra;
+};
+
+void sqfs_version_supported(int *min_major, int *min_minor, int *max_major,
+	int *max_minor);
+
+/* Number of groups of size 'group' required to hold size 'total' */
+size_t sqfs_divceil(uint64_t total, size_t group);
+
+
+sqfs_err sqfs_init(sqfs *fs, sqfs_fd_t fd, size_t offset);
+void sqfs_destroy(sqfs *fs);
+
+/* Ok to call these even on incompletely constructed filesystems */
+void sqfs_version(sqfs *fs, int *major, int *minor);
+sqfs_compression_type sqfs_compression(sqfs *fs);
+
+
+void sqfs_md_header(uint16_t hdr, short *compressed, uint16_t *size);
+void sqfs_data_header(uint32_t hdr, short *compressed, uint32_t *size);
+
+sqfs_err sqfs_block_read(sqfs *fs, sqfs_off_t pos, short compressed, uint32_t size,
+	size_t outsize, sqfs_block **block);
+void sqfs_block_dispose(sqfs_block *block);
+
+sqfs_err sqfs_md_block_read(sqfs *fs, sqfs_off_t pos, size_t *data_size,
+	sqfs_block **block);
+sqfs_err sqfs_data_block_read(sqfs *fs, sqfs_off_t pos, uint32_t hdr,
+	sqfs_block **block);
+
+/* Don't dispose after getting block, it's in the cache */
+sqfs_err sqfs_md_cache(sqfs *fs, sqfs_off_t *pos, sqfs_block **block);
+sqfs_err sqfs_data_cache(sqfs *fs, sqfs_cache *cache, sqfs_off_t pos,
+	uint32_t hdr, sqfs_block **block);
+
+void sqfs_md_cursor_inode(sqfs_md_cursor *cur, sqfs_inode_id id, sqfs_off_t base);
+
+sqfs_err sqfs_md_read(sqfs *fs, sqfs_md_cursor *cur, void *buf, size_t size);
+
+
+sqfs_err sqfs_inode_get(sqfs *fs, sqfs_inode *inode, sqfs_inode_id id);
+
+sqfs_mode_t sqfs_mode(int inode_type);
+sqfs_err sqfs_id_get(sqfs *fs, uint16_t idx, sqfs_id_t *id);
+
+/* Puts up to *size characters of the link name into buf. Always null-
+ * terminates the buffer. Pass null as buf to have the size returned. */
+sqfs_err sqfs_readlink(sqfs *fs, sqfs_inode *inode, char *buf, size_t *size);
+
+/* Find inode_id by inode_num */
+int sqfs_export_ok(sqfs *fs);
+sqfs_err sqfs_export_inode(sqfs *fs, sqfs_inode_num n, sqfs_inode_id *i);
+
+/* Find the root inode */
+sqfs_inode_id sqfs_inode_root(sqfs *fs);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/hash.h ruby/include/squash/hash.h
--- ruby-2.4.1/include/squash/hash.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/hash.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_HASH_H
+#define SQFS_HASH_H
+
+#include "squash/common.h"
+
+/* Simple hashtable
+ *	- Keys are integers
+ *	- Values are opaque data
+ *
+ * Implementation
+ *	- Hash function is modulus
+ *	- Chaining for duplicates
+ *	- Sizes are powers of two
+ */
+typedef uint32_t sqfs_hash_key;
+typedef void *sqfs_hash_value;
+
+typedef struct sqfs_hash_bucket {
+	struct sqfs_hash_bucket *next;
+	sqfs_hash_key key;
+	char value[1]; /* extended to size */
+} sqfs_hash_bucket;
+
+typedef struct {
+	size_t value_size;
+	size_t capacity;
+	size_t size;
+	sqfs_hash_bucket **buckets;
+} sqfs_hash;
+
+sqfs_err sqfs_hash_init(sqfs_hash *h, size_t vsize, size_t initial);
+void sqfs_hash_destroy(sqfs_hash *h);
+
+sqfs_hash_value sqfs_hash_get(sqfs_hash *h, sqfs_hash_key k);
+
+sqfs_err sqfs_hash_add(sqfs_hash *h, sqfs_hash_key k, sqfs_hash_value v);
+sqfs_err sqfs_hash_remove(sqfs_hash *h, sqfs_hash_key k);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/mutex.h ruby/include/squash/mutex.h
--- ruby-2.4.1/include/squash/mutex.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/mutex.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef LIBSQUASH_MUTEX_H
+#define LIBSQUASH_MUTEX_H
+
+#ifdef _WIN32
+    #include <windows.h>
+    #include <process.h>
+#else
+    #include <pthread.h>
+#endif
+
+#ifdef _WIN32
+   #define MUTEX HANDLE
+#else
+   #define MUTEX pthread_mutex_t
+#endif
+
+extern MUTEX squash_global_mutex;
+
+int MUTEX_INIT(MUTEX *mutex);
+int MUTEX_LOCK(MUTEX *mutex);
+int MUTEX_UNLOCK(MUTEX *mutex);
+int MUTEX_DESTORY(MUTEX *mutex);
+
+#endif //LIBSQUASH_MUTEX_H
diff -ruN ruby-2.4.1/include/squash/nonstd.h ruby/include/squash/nonstd.h
--- ruby-2.4.1/include/squash/nonstd.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/nonstd.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_STD_H
+#define SQFS_STD_H
+
+#include "squash/common.h"
+
+/* Non-standard functions that we need */
+
+dev_t sqfs_makedev(int maj, int min);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/private.h ruby/include/squash/private.h
--- ruby-2.4.1/include/squash/private.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/private.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_PRIVATE_H
+#define SQFS_PRIVATE_H
+
+#include "squash.h"
+
+#include <sys/stat.h>
+
+/* Fill in a stat structure. Does not set st_ino */
+sqfs_err sqfs_stat(sqfs *fs, sqfs_inode *inode, struct stat *st);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/squashfs_fs.h ruby/include/squash/squashfs_fs.h
--- ruby-2.4.1/include/squash/squashfs_fs.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/squashfs_fs.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,318 @@
+/*
+ * squashfs_fs.h
+ *
+ * Copyright (c) 2012  Phillip Lougher <phillip@squashfs.org.uk>
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQUASHFS_FS
+#define SQUASHFS_FS
+
+#ifdef __linux__
+	#include <linux/types.h>
+#else
+	#include <stdint.h>
+	typedef uint16_t __le16;
+	typedef uint32_t __le32;
+	typedef uint64_t __le64;
+#endif
+
+#define SQUASHFS_MAGIC 0x73717368
+
+
+#define SQUASHFS_CACHED_FRAGMENTS	CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE
+#define SQUASHFS_MAJOR			4
+#define SQUASHFS_MINOR			0
+#define SQUASHFS_START			0
+
+/* size of metadata (inode and directory) blocks */
+#define SQUASHFS_METADATA_SIZE		8192
+#define SQUASHFS_METADATA_LOG		13
+
+/* default size of data blocks */
+#define SQUASHFS_FILE_SIZE		131072
+#define SQUASHFS_FILE_LOG		17
+
+#define SQUASHFS_FILE_MAX_SIZE		1048576
+#define SQUASHFS_FILE_MAX_LOG		20
+
+/* Max number of uids and gids */
+#define SQUASHFS_IDS			65536
+
+/* Max length of filename (not 255) */
+#define SQUASHFS_NAME_LEN		256
+#define SQUASHFS_PATH_LEN		2048
+#define SQUASHFS_MAX_LINK_LEVEL	32
+#define SQUASHFS_INVALID_FRAG		(0xffffffffU)
+#define SQUASHFS_INVALID_XATTR		(0xffffffffU)
+#define SQUASHFS_INVALID_BLK		((int64_t)-1)
+
+/* Filesystem flags */
+#define SQUASHFS_NOI			0
+#define SQUASHFS_NOD			1
+#define SQUASHFS_NOF			3
+#define SQUASHFS_NO_FRAG		4
+#define SQUASHFS_ALWAYS_FRAG		5
+#define SQUASHFS_DUPLICATE		6
+#define SQUASHFS_EXPORT			7
+#define SQUASHFS_COMP_OPT		10
+
+/* Max number of types and file types */
+#define SQUASHFS_DIR_TYPE		1
+#define SQUASHFS_REG_TYPE		2
+#define SQUASHFS_SYMLINK_TYPE		3
+#define SQUASHFS_BLKDEV_TYPE		4
+#define SQUASHFS_CHRDEV_TYPE		5
+#define SQUASHFS_FIFO_TYPE		6
+#define SQUASHFS_SOCKET_TYPE		7
+#define SQUASHFS_LDIR_TYPE		8
+#define SQUASHFS_LREG_TYPE		9
+#define SQUASHFS_LSYMLINK_TYPE		10
+#define SQUASHFS_LBLKDEV_TYPE		11
+#define SQUASHFS_LCHRDEV_TYPE		12
+#define SQUASHFS_LFIFO_TYPE		13
+#define SQUASHFS_LSOCKET_TYPE		14
+
+/* Xattr types */
+#define SQUASHFS_XATTR_USER             0
+#define SQUASHFS_XATTR_TRUSTED          1
+#define SQUASHFS_XATTR_SECURITY         2
+#define SQUASHFS_XATTR_VALUE_OOL        256
+#define SQUASHFS_XATTR_PREFIX_MASK      0xff
+
+#define SQUASHFS_COMPRESSED_BIT		(1 << 15)
+
+#define SQUASHFS_COMPRESSED_BIT_BLOCK	(1 << 24)
+
+
+/* cached data constants for filesystem */
+#define SQUASHFS_CACHED_BLKS		8
+
+#define SQUASHFS_MAX_FILE_SIZE_LOG	64
+
+#define SQUASHFS_MAX_FILE_SIZE		(1LL << \
+					(SQUASHFS_MAX_FILE_SIZE_LOG - 2))
+
+/* meta index cache */
+#define SQUASHFS_META_INDEXES	(SQUASHFS_METADATA_SIZE / sizeof(unsigned int))
+#define SQUASHFS_META_ENTRIES	127
+#define SQUASHFS_META_SLOTS	8
+
+
+/*
+ * definitions for structures on disk
+ */
+#define ZLIB_COMPRESSION	1
+
+struct squashfs_super_block {
+	__le32			s_magic;
+	__le32			inodes;
+	__le32			mkfs_time;
+	__le32			block_size;
+	__le32			fragments;
+	__le16			compression;
+	__le16			block_log;
+	__le16			flags;
+	__le16			no_ids;
+	__le16			s_major;
+	__le16			s_minor;
+	__le64			root_inode;
+	__le64			bytes_used;
+	__le64			id_table_start;
+	__le64			xattr_id_table_start;
+	__le64			inode_table_start;
+	__le64			directory_table_start;
+	__le64			fragment_table_start;
+	__le64			lookup_table_start;
+};
+
+struct squashfs_dir_index {
+	__le32			index;
+	__le32			start_block;
+	__le32			size;
+};
+
+struct squashfs_base_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+};
+
+struct squashfs_ipc_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le32			nlink;
+};
+
+struct squashfs_lipc_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le32			nlink;
+	__le32			xattr;
+};
+
+struct squashfs_dev_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le32			nlink;
+	__le32			rdev;
+};
+
+struct squashfs_ldev_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le32			nlink;
+	__le32			rdev;
+	__le32			xattr;
+};
+
+struct squashfs_symlink_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le32			nlink;
+	__le32			symlink_size;
+};
+
+struct squashfs_reg_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le32			start_block;
+	__le32			fragment;
+	__le32			offset;
+	__le32			file_size;
+};
+
+struct squashfs_lreg_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le64			start_block;
+	__le64			file_size;
+	__le64			sparse;
+	__le32			nlink;
+	__le32			fragment;
+	__le32			offset;
+	__le32			xattr;
+};
+
+struct squashfs_dir_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le32			start_block;
+	__le32			nlink;
+	__le16			file_size;
+	__le16			offset;
+	__le32			parent_inode;
+};
+
+struct squashfs_ldir_inode {
+	__le16			inode_type;
+	__le16			mode;
+	__le16			uid;
+	__le16			guid;
+	__le32			mtime;
+	__le32			inode_number;
+	__le32			nlink;
+	__le32			file_size;
+	__le32			start_block;
+	__le32			parent_inode;
+	__le16			i_count;
+	__le16			offset;
+	__le32			xattr;
+};
+
+struct squashfs_dir_entry {
+	__le16			offset;
+	__le16			inode_number;
+	__le16			type;
+	__le16			size;
+};
+
+struct squashfs_dir_header {
+	__le32			count;
+	__le32			start_block;
+	__le32			inode_number;
+};
+
+struct squashfs_fragment_entry {
+	__le64			start_block;
+	__le32			size;
+	unsigned int		unused;
+};
+
+struct squashfs_xattr_entry {
+	__le16			type;
+	__le16			size;
+};
+
+struct squashfs_xattr_val {
+	__le32			vsize;
+};
+
+struct squashfs_xattr_id {
+	__le64			xattr;
+	__le32			count;
+	__le32			size;
+};
+
+struct squashfs_xattr_id_table {
+	__le64			xattr_table_start;
+	__le32			xattr_ids;
+	__le32			unused;
+};
+
+#endif
diff -ruN ruby-2.4.1/include/squash/stack.h ruby/include/squash/stack.h
--- ruby-2.4.1/include/squash/stack.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/stack.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_STACK_H
+#define SQFS_STACK_H
+
+#include "squash/common.h"
+
+typedef void (*sqfs_stack_free_t)(void *v);
+
+typedef struct {
+	size_t value_size;
+	size_t size;
+	size_t capacity;
+	char *items;
+	sqfs_stack_free_t freer;
+} sqfs_stack;
+
+/* Ensures the struct is in a safe state */
+void sqfs_stack_init(sqfs_stack *s);
+
+sqfs_err sqfs_stack_create(sqfs_stack *s, size_t vsize, size_t initial,
+	sqfs_stack_free_t freer);
+void sqfs_stack_destroy(sqfs_stack *s);
+
+sqfs_err sqfs_stack_push(sqfs_stack *s, void *vout);
+short sqfs_stack_pop(sqfs_stack *s);
+
+size_t sqfs_stack_size(sqfs_stack *s);
+sqfs_err sqfs_stack_at(sqfs_stack *s, size_t i, void *vout);
+sqfs_err sqfs_stack_top(sqfs_stack *s, void *vout);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/table.h ruby/include/squash/table.h
--- ruby-2.4.1/include/squash/table.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/table.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_TABLE_H
+#define SQFS_TABLE_H
+
+#include "squash/common.h"
+
+typedef struct {
+	size_t each;
+	uint64_t *blocks;
+} sqfs_table;
+
+sqfs_err sqfs_table_init(sqfs_table *table, sqfs_fd_t fd, sqfs_off_t start, size_t each,
+	size_t count);
+void sqfs_table_destroy(sqfs_table *table);
+
+sqfs_err sqfs_table_get(sqfs_table *table, sqfs *fs, size_t idx, void *buf);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/traverse.h ruby/include/squash/traverse.h
--- ruby-2.4.1/include/squash/traverse.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/traverse.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_TRAVERSE_H
+#define SQFS_TRAVERSE_H
+
+#include "squash/common.h"
+
+#include "squash/dir.h"
+#include "squash/stack.h"
+
+typedef struct {
+	short dir_end;
+	sqfs_dir_entry entry;
+	char *path;
+	
+	
+	/* private */
+	int state;	
+	sqfs *fs;
+	sqfs_name namebuf;
+	sqfs_stack stack;
+	
+	size_t path_size, path_cap;
+	size_t path_last_size;
+} sqfs_traverse;
+
+/* Begin a recursive traversal of a filesystem tree.
+   Every sub-item of the given inode will be traversed in-order, but not
+   this inode itself. */
+sqfs_err sqfs_traverse_open(sqfs_traverse *trv, sqfs *fs, sqfs_inode_id iid);
+sqfs_err sqfs_traverse_open_inode(sqfs_traverse *trv, sqfs *fs,
+	sqfs_inode *inode);
+
+/* Clean up at any point during or after a traversal */
+void sqfs_traverse_close(sqfs_traverse *trv);
+
+/* Get the next item in the traversal. An item may be:
+   - A directory entry, in which case trv->entry will be filled
+	 - A marker that a directory is finished, in which case trv->dir_end will
+     be 1.
+   Returns 0 if there are no more items. */
+short sqfs_traverse_next(sqfs_traverse *trv, sqfs_err *err);
+
+/* Don't recurse into the directory just returned. */
+sqfs_err sqfs_traverse_prune(sqfs_traverse *trv);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/util.h ruby/include/squash/util.h
--- ruby-2.4.1/include/squash/util.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/util.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef SQFS_UTIL_H
+#define SQFS_UTIL_H
+
+#include "squash/common.h"
+
+#include <stdio.h>
+
+/* Open a file, and optionally print a message on failure */
+sqfs_err sqfs_fd_open(const uint8_t *path, sqfs_fd_t *fd);
+
+/* Close a file */
+void sqfs_fd_close(sqfs_fd_t fd);
+
+/* Open a filesystem and print errors to stderr. */
+sqfs_err sqfs_open_image(sqfs *fs, const uint8_t *image, size_t offset);
+
+#endif
diff -ruN ruby-2.4.1/include/squash/windows.h ruby/include/squash/windows.h
--- ruby-2.4.1/include/squash/windows.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash/windows.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef WINDOWS_H_A80B5674
+#define WINDOWS_H_A80B5674
+
+#include <Windows.h>
+#include <stdint.h>
+#include <io.h>
+
+typedef unsigned short sqfs_mode_t;
+typedef uint32_t sqfs_id_t; /* Internal uids/gids are 32-bits */
+
+typedef SSIZE_T ssize_t;
+typedef DWORD64 sqfs_off_t;
+typedef uint32_t uid_t;		/* [???] user IDs */
+
+#ifndef S_IFIFO
+#define	S_IFIFO		0010000		/* [XSI] named pipe (fifo) */
+#endif
+
+#ifndef S_IFBLK
+#define	S_IFBLK		0060000		/* [XSI] block special */
+#endif
+
+#ifndef S_IFLNK
+#define	S_IFLNK		0120000		/* [XSI] symbolic link */
+#endif
+
+#ifndef S_IFSOCK
+#define	S_IFSOCK	0140000		/* [XSI] socket */
+#endif
+
+#ifndef S_ISBLK
+#define	S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)	/* block special */
+#endif
+
+#ifndef S_ISCHR
+#define	S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)	/* char special */
+#endif
+
+#ifndef S_ISDIR
+#define	S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)	/* directory */
+#endif
+
+#ifndef S_ISFIFO
+#define	S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)	/* fifo or socket */
+#endif
+
+#ifndef S_ISREG
+#define	S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)	/* regular file */
+#endif
+
+#ifndef S_ISLNK
+#define	S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)	/* symbolic link */
+#endif
+
+#ifndef S_ISSOCK
+#define	S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)	/* socket */
+#endif
+
+#ifndef makedev
+#define	makedev(x,y)	((dev_t)(((x) << 24) | (y)))
+#endif
+
+#ifndef DT_UNKNOWN
+#define	DT_UNKNOWN	 0
+#endif
+
+#ifndef	DT_FIFO
+#define	DT_FIFO		 1
+#endif
+
+#ifndef	DT_CHR
+#define	DT_CHR		 2
+#endif
+
+#ifndef	DT_DIR
+#define	DT_DIR		 4
+#endif
+
+#ifndef	DT_BLK
+#define	DT_BLK		 6
+#endif
+
+#ifndef	DT_REG
+#define	DT_REG		 8
+#endif
+
+#ifndef	DT_LNK
+#define	DT_LNK		10
+#endif
+
+#ifndef	DT_SOCK
+#define	DT_SOCK		12
+#endif
+
+#ifndef	DT_WHT
+#define	DT_WHT		14
+#endif
+
+#endif /* end of include guard: WINDOWS_H_A80B5674 */
diff -ruN ruby-2.4.1/include/squash.h ruby/include/squash.h
--- ruby-2.4.1/include/squash.h	1970-01-01 02:00:00.000000000 +0200
+++ ruby/include/squash.h	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#ifndef SQFS_SQUASH_H
+#define SQFS_SQUASH_H
+
+#include <string.h>
+#include <errno.h>
+#include <assert.h>
+
+#include "squash/dir.h"
+#include "squash/file.h"
+#include "squash/fs.h"
+#include "squash/traverse.h"
+#include "squash/util.h"
+#include "squash/private.h"
+#include "squash/fdtable.h"
+#include "squash/dirent.h"
+
+#define SQUASH_SEEK_SET 0 /* set file offset to offset */
+#define SQUASH_SEEK_CUR 1 /* set file offset to current plus offset */
+#define SQUASH_SEEK_END 2 /* set file offset to EOF plus offset */
+
+#define SQUASH_VALID_VFD(vfd) ((vfd) < squash_global_fdtable.nr && NULL != squash_global_fdtable.fds[(vfd)])
+#define SQUASH_VFD_FILE(vfd) (squash_global_fdtable.fds[(vfd)])
+
+extern sqfs_err squash_errno;
+
+sqfs_err squash_start();
+ssize_t squash_readlink_inode(sqfs *fs, sqfs_inode *node, char *buf, size_t bufsize);
+sqfs_err squash_follow_link(sqfs *fs, const char *path, sqfs_inode *node);
+struct squash_file * squash_find_entry(void *ptr);
+
+/*
+ * Obtains information about the file pointed to by path of a SquashFS fs.
+ * The buf argument is a pointer to a stat structure as defined by
+ * <sys/stat.h> and into which information is placed concerning the file.
+ * Upon successful completion a value of 0 is returned.
+ * Otherwise, a value of -1 is returned and
+ * error is set to the reason of the error.
+ */
+int squash_stat(sqfs *fs, const char *path, struct stat *buf);
+
+/*
+ * Acts like squash_stat() except in the case where the named file
+ * is a symbolic link; squash_lstat() returns information about the link,
+ * while squash_stat() returns information about the file the link references.
+ */
+int squash_lstat(sqfs *fs, const char *path, struct stat *buf);
+
+/*
+ * Obtains the same information as squash_stat()
+ * about an open file known by the virtual file descriptor vfd.
+ */
+int squash_fstat(int vfd, struct stat *buf);
+
+/*
+ * Opens the file name specified by path of fs for reading.
+ * If successful, squash_open() returns a non-negative integer,
+ * termed a vfd(virtual file descriptor).
+ * It returns -1 on failure and sets error to the reason of the error.
+ * The file pointer (used to mark the current position within the file)
+ * is set to the beginning of the file.
+ * The returned vfd should later be closed by squash_close().
+ */
+int squash_open(sqfs *fs, const char *path);
+
+int squash_open_inner(sqfs *fs, const char *path, short follow_link);
+
+/*
+ * Deletes a vfd(virtual file descriptor) from
+ * the per-process object reference table.
+ * Upon successful completion, a value of 0 is returned.
+ * Otherwise, a value of -1 is returned and error is set to
+ * the reason of the error.
+ */
+int squash_close(int vfd);
+
+/*
+ * Attempts to read nbyte bytes of data from the object
+ * referenced by vfs into the buffer pointed to by buf,
+ * starting at a position given by the pointer
+ * associated with vfd (see squash_lseek),
+ * which is then incremented by the number of bytes actually read upon return.
+ * When successful it returns the number of bytes actually read
+ * and placed in the buffer;
+ * upon reading end-of-file, zero is returned;
+ * Otherwise, a value of -1 is returned and error is set to
+ * the reason of the error.
+ */
+ssize_t squash_read(int vfd, void *buf, sqfs_off_t nbyte);
+
+/*
+ * Repositions the offset of vfs to the argument offset,
+ * according to the directive whence.
+ * If whence is SQUASH_SEEK_SET then the offset is set to offset bytes;
+ * if whence is SQUASH_SEEK_CUR, the offset is set to
+ * its current location plus offset bytes;
+ * if whence is SQUASH_SEEK_END, the offset is set to
+ * the size of the file and
+ * subsequent reads of the data return bytes of zeros.
+ * The argument fildes` must be an open virtual file descriptor.
+ * Upon successful completion,
+ * it returns the resulting offset location as measured in bytes
+ * from the beginning of the file.
+ * Otherwise, a value of -1 is returned and
+ * error is set to the reason of the error.
+ */
+off_t squash_lseek(int vfd, off_t offset, int whence);
+
+/*
+ * Places the contents of the symbolic link path of a SquashFS fs
+ * in the buffer buf, which has size bufsize.
+ * It does not append a NUL character to buf.
+ * If it succeeds the call returns the count of characters placed in the buffer;
+ * otherwise -1 is returned and error is set to the reason of the error.
+ */
+ssize_t squash_readlink(sqfs *fs, const char *path, char *buf, size_t bufsize);
+
+/*
+ * Opens the directory named by filename of a SquashFS fs,
+ * associates a directory stream with it and returns a pointer
+ * to be used to identify the directory stream in subsequent operations.
+ * The pointer NULL is returned if filename cannot be accessed,
+ * or if it cannot allocate enough memory to hold the whole thing,
+ * and sets error to the reason of the error.
+ * The returned resource should later be closed by squash_closedir().
+ */
+SQUASH_DIR * squash_opendir(sqfs *fs, const char *filename);
+
+SQUASH_DIR * squash_opendir_inner(sqfs *fs, const char *filename, short follow_link);
+
+/*
+ * Closes the named directory stream and
+ * frees the structure associated with the dirp pointer,
+ * returning 0 on success.
+ * On failure, -1 is returned and error is set to the reason of the error.
+ */
+int squash_closedir(SQUASH_DIR *dirp);
+
+/*
+ * Returns a pointer to the next directory entry.
+ * It returns NULL upon reaching the end of the directory or on error. 
+ * In the event of an error, error is set to the reason of the error.
+ */
+struct SQUASH_DIRENT * squash_readdir(SQUASH_DIR *dirp);
+
+/*
+ * Returns the current location associated with the named directory stream.
+ */
+long squash_telldir(SQUASH_DIR *dirp);
+
+/*
+ * Sets the position of the next squash_readdir() operation
+ * on the directory stream.
+ * The new position reverts to the one associated with the directory stream
+ * when the squash_telldir() operation was performed.
+ */
+void squash_seekdir(SQUASH_DIR *dirp, long loc);
+
+/*
+ * Resets the position of the named directory stream to
+ * the beginning of the directory.
+ */
+void squash_rewinddir(SQUASH_DIR *dirp);
+
+/*
+ * Returns the integer virtual file descriptor
+ * associated with the named directory stream.
+ * On failure, -1 is returned and error is set to the reason of the error.
+ */
+int squash_dirfd(SQUASH_DIR *dirp);
+
+/*
+ * Reads the directory dirname of a SquashFS fs and
+ * builds an array of pointers to directory entries using malloc.
+ * If successful it returns the number of entries in the array; 
+ * otherwise -1 is returned and error is set to the reason of the error.
+ * A pointer to the array of directory entries is stored
+ * in the location referenced by namelist (even if the number of entries is 0),
+ * which should later be freed via free() by freeing each pointer
+ * in the array and then the array itself.
+ * The select argument is a pointer to a user supplied subroutine which is
+ * called by scandir to select which entries are to be included in the array.
+ * The select routine is passed a pointer to a directory entry
+ * and should return a non-zero value if the directory entry
+ * is to be included in the array.
+ * If select is NULL, then all the directory entries will be included.
+ * The compar argument is a pointer to a user supplied subroutine
+ * which is passed to qsort to sort the completed array.
+ * If this pointer is NULL, then the array is not sorted.
+ */
+int squash_scandir(sqfs *fs, const char *dirname, struct SQUASH_DIRENT ***namelist,
+	int (*select)(const struct SQUASH_DIRENT *),
+	int (*compar)(const struct SQUASH_DIRENT **, const struct SQUASH_DIRENT **));
+
+/*
+ * Extracts the file `path` from `fs` to a temporary file
+ * inside the temporary folder.
+ * Upon successful completion the path of the extracted temporary file
+ * is returned.
+ * Otherwise, a value of `NULL` is returned
+ * and `errno` is set to the reason of the error.
+ * The returned path is referenced by an internal cache and must not be freed.
+ */
+#ifdef _WIN32
+#define SQUASH_OS_PATH const wchar_t*
+#else
+#define SQUASH_OS_PATH const char*
+#endif
+SQUASH_OS_PATH squash_tmpdir();
+SQUASH_OS_PATH squash_tmpf(SQUASH_OS_PATH tmpdir, const char *ext_name);
+SQUASH_OS_PATH squash_extract(sqfs *fs, const char *path, const char *ext_name);
+void squash_extract_clear_cache();
+
+#endif
diff -ruN ruby-2.4.1/io.c ruby/io.c
--- ruby-2.4.1/io.c	2017-03-12 20:41:38.000000000 +0200
+++ ruby/io.c	2018-03-16 15:30:56.000000000 +0200
@@ -138,6 +138,10 @@
 #define open	rb_w32_uopen
 #endif
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 VALUE rb_cIO;
 VALUE rb_eEOFError;
 VALUE rb_eIOError;
diff -ruN ruby-2.4.1/lib/mkmf.rb ruby/lib/mkmf.rb
--- ruby-2.4.1/lib/mkmf.rb	2017-03-11 20:46:17.000000000 +0200
+++ ruby/lib/mkmf.rb	2018-03-16 15:30:56.000000000 +0200
@@ -2675,17 +2675,17 @@
 
   TRY_LINK = config_string('TRY_LINK') ||
     "$(CC) #{OUTFLAG}#{CONFTEST}#{$EXEEXT} $(INCFLAGS) $(CPPFLAGS) " \
-    "$(CFLAGS) $(src) $(LIBPATH) $(LDFLAGS) $(ARCH_FLAG) $(LOCAL_LIBS) $(LIBS)"
+    "$(CFLAGS) $(src) $(LIBPATH) $(LDFLAGS) $(ARCH_FLAG) $(LOCAL_LIBS) $(LIBS) $(LDFLAGS)"
 
   ##
   # Command which will link a shared library
 
   LINK_SO = (config_string('LINK_SO') || "").sub(/^$/) do
     if CONFIG["DLEXT"] == $OBJEXT
-      "ld $(DLDFLAGS) -r -o $@ $(OBJS)\n"
+      "ld $(DLDFLAGS) -r -o $@ $(OBJS) $(DLDFLAGS)\n"
     else
       "$(LDSHARED) #{OUTFLAG}$@ $(OBJS) " \
-      "$(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS)"
+      "$(LIBPATH) $(DLDFLAGS) $(LOCAL_LIBS) $(LIBS) $(DLDFLAGS)"
     end
   end
 
diff -ruN ruby-2.4.1/lib/rubygems/path_support.rb ruby/lib/rubygems/path_support.rb
--- ruby-2.4.1/lib/rubygems/path_support.rb	2016-03-04 02:29:40.000000000 +0200
+++ ruby/lib/rubygems/path_support.rb	2018-03-16 15:30:56.000000000 +0200
@@ -25,12 +25,28 @@
   def initialize(env)
     @home     = env["GEM_HOME"] || Gem.default_dir
 
+    # --------- [Enclose.io Hack start] ---------
+    # WE DO NOT ACCEPT OUTSIDE GEM PATHS
+    unless env['ENCLOSE_IO_RUBYC_1ST_PASS']
+      @home = Gem.default_dir unless 0 == @home.index('/__enclose_io_memfs__')
+    end
+    # --------- [Enclose.io Hack end] ---------
+
     if File::ALT_SEPARATOR then
       @home   = @home.gsub(File::ALT_SEPARATOR, File::SEPARATOR)
     end
 
     @path = split_gem_path env["GEM_PATH"], @home
 
+    # --------- [Enclose.io Hack start] ---------
+    # WE DO NOT ACCEPT OUTSIDE GEM PATHS
+    unless env['ENCLOSE_IO_RUBYC_1ST_PASS']
+      @path.keep_if do |x|
+        0 == x.index('/__enclose_io_memfs__')
+      end
+    end
+    # --------- [Enclose.io Hack end] ---------
+
     @spec_cache_dir = env["GEM_SPEC_CACHE"] || Gem.default_spec_cache_dir
 
     @spec_cache_dir = @spec_cache_dir.dup.untaint
diff -ruN ruby-2.4.1/main.c ruby/main.c
--- ruby-2.4.1/main.c	2012-11-20 14:57:49.000000000 +0200
+++ ruby/main.c	2018-03-16 15:30:56.000000000 +0200
@@ -19,9 +19,112 @@
 #include <stdlib.h>
 #endif
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+#include "autoupdate.h"
+#ifdef _WIN32
+#include <direct.h>
+#else
+#include <unistd.h>
+#endif
+extern SQUASH_OS_PATH mkdir_workdir;
+extern char *enclose_io_mkdir_scope;
+// --------- [Enclose.io Hack end] ---------
+
 int
 main(int argc, char **argv)
 {
+// --------- [Enclose.io Hack start] ---------
+	int autoupdate_result;
+	int ret;
+	sqfs_err enclose_io_ret;
+#ifdef _WIN32
+	BOOL bool_ret;
+#else
+	int new_argc;
+	char **new_argv;
+	char *argv_memory;
+	size_t i;
+	size_t total_argv_size;
+#endif
+
+#if ENCLOSE_IO_AUTO_UPDATE
+	autoupdate_result = autoupdate(
+		argc,
+		argv,
+		ENCLOSE_IO_AUTO_UPDATE_URL_Host,
+		ENCLOSE_IO_AUTO_UPDATE_URL_Port,
+		ENCLOSE_IO_AUTO_UPDATE_URL_Path,
+		ENCLOSE_IO_AUTO_UPDATE_BASE,
+		0
+	);
+#endif
+
+	enclose_io_ret = squash_start();
+	assert(SQFS_OK == enclose_io_ret);
+	enclose_io_fs = malloc(sizeof(sqfs));
+	assert(NULL != enclose_io_fs);
+	memset(enclose_io_fs, 0, sizeof(sqfs));
+	enclose_io_ret = sqfs_open_image(enclose_io_fs, enclose_io_memfs, 0);
+	assert(SQFS_OK == enclose_io_ret);
+
+#ifdef _WIN32
+	if (NULL == getenv("ENCLOSE_IO_USE_ORIGINAL_RUBY")) {
+#ifdef ENCLOSE_IO_ENV_BUNDLE_GEMFILE
+		bool_ret = SetEnvironmentVariable("BUNDLE_GEMFILE", ENCLOSE_IO_ENV_BUNDLE_GEMFILE);
+		assert(0 != bool_ret);
+#endif // ENCLOSE_IO_ENV_BUNDLE_GEMFILE
+#ifdef ENCLOSE_IO_RAILS
+		assert(NULL == mkdir_workdir);
+		enclose_io_mkdir_scope = "/__enclose_io_memfs__/local";
+		bool_ret = SetEnvironmentVariable("ENCLOSE_IO_RAILS", "1");
+		assert(0 != bool_ret);
+#endif // ENCLOSE_IO_RAILS
+	}
+#else // ifdef _WIN32 -----------------------------------------------
+#ifdef ENCLOSE_IO_ENTRANCE
+	new_argc = argc;
+	new_argv = argv;
+	argv_memory = NULL;
+	if (NULL == getenv("ENCLOSE_IO_USE_ORIGINAL_RUBY")) {
+#ifdef ENCLOSE_IO_ENV_BUNDLE_GEMFILE
+		ret = setenv("BUNDLE_GEMFILE", ENCLOSE_IO_ENV_BUNDLE_GEMFILE, 1);
+		assert(0 == ret);
+#endif // ENCLOSE_IO_ENV_BUNDLE_GEMFILE
+#ifdef ENCLOSE_IO_RAILS
+		assert(NULL == mkdir_workdir);
+		enclose_io_mkdir_scope = "/__enclose_io_memfs__/local";
+		ret = setenv("ENCLOSE_IO_RAILS", "1", 1);
+		assert(0 == ret);
+#endif // ENCLOSE_IO_RAILS
+		new_argv = (char **)malloc( (argc + 1) * sizeof(char *));
+		assert(new_argv);
+		new_argv[0] = argv[0];
+		new_argv[1] = ENCLOSE_IO_ENTRANCE;
+		for (i = 1; i < argc; ++i) {
+			new_argv[2 + i - 1] = argv[i];
+		}
+		new_argc = argc + 1;
+		/* argv memory should be adjacent. */
+		total_argv_size = 0;
+		for (i = 0; i < new_argc; ++i) {
+			total_argv_size += strlen(new_argv[i]) + 1;
+		}
+		argv_memory = (char *)malloc( (total_argv_size) * sizeof(char));
+		assert(argv_memory);
+		for (i = 0; i < new_argc; ++i) {
+			memcpy(argv_memory, new_argv[i], strlen(new_argv[i]) + 1);
+			new_argv[i] = argv_memory;
+			argv_memory += strlen(new_argv[i]) + 1;
+		}
+		assert(argv_memory - new_argv[0] == total_argv_size);
+		argc = new_argc;
+		argv = new_argv;
+	}
+#endif // ENCLOSE_IO_ENTRANCE
+#endif // ifdef _WIN32
+// --------- [Enclose.io Hack end] ---------
+
 #ifdef RUBY_DEBUG_ENV
     ruby_set_debug_option(getenv("RUBY_DEBUG"));
 #endif
diff -ruN ruby-2.4.1/prelude.c ruby/prelude.c
--- ruby-2.4.1/prelude.c	2017-03-22 07:56:53.000000000 +0200
+++ ruby/prelude.c	2018-03-16 15:30:56.000000000 +0200
@@ -169,6 +169,55 @@
 "end\n"
 ;
 
+static const char prelude_name_enclose_io[] = "<internal:enclose_io_prelude>";
+static const char prelude_code_enclose_io[] =
+"\n class << Process"
+"\n   alias :spawn_before_enclose_io :spawn"
+"\n   def spawn(arg0, *args)"
+"\n     if arg0.kind_of?(Hash) && args[0].kind_of?(String) && '/__enclose_io_memfs__' == args[0][0...21]"
+"\n       arg0 = arg0.dup"
+"\n       args[0] = args[0].dup"
+"\n       arg0['ENCLOSE_IO_USE_ORIGINAL_RUBY'] = '1'"
+"\n       args[0] = Process.enclose_io_execpath + ' ' + args[0]"
+"\n     end"
+"\n     spawn_before_enclose_io(arg0, *args)"
+"\n   end"
+"\n end"
+"\n class << IO"
+"\n   alias :popen_before_enclose_io :popen"
+"\n   def popen(*args, &block)"
+"\n     if args[0].kind_of?(Array)"
+"\n       if args[0][0].kind_of?(String) && '/__enclose_io_memfs__' == args[0][0][0...21]"
+"\n         args[0] = args[0].dup"
+"\n         args[0][0] = enclose_io_memfs_extract(args[0][0], 'exe')"
+"\n         File.chmod(0755, args[0][0])"
+"\n       end"
+"\n     end"
+"\n     popen_before_enclose_io(*args, &block)"
+"\n   end"
+"\n end"
+"\n require 'fileutils'"
+"\n if ENV['ENCLOSE_IO_WORKDIR'] && ENV['ENCLOSE_IO_WORKDIR'].length > 0"
+"\n   x = File.expand_path(ENV['ENCLOSE_IO_WORKDIR'])"
+"\n   FileUtils.mkdir_p(x)"
+"\n   if ENV['ENCLOSE_IO_RAILS']"
+"\n     Dir.chdir(x) do"
+"\n       FileUtils.mkdir_p('config')"
+"\n       Dir.chdir('config') do"
+"\n         Dir['/__enclose_io_memfs__/local/config/*'].each do |fullpath|"
+"\n           unless fullpath =~ /\\.rb$/ || File.exist?(File.basename(fullpath)) || !File.file?(fullpath)"
+"\n             FileUtils.cp(fullpath, File.basename(fullpath))"
+"\n           end"
+"\n         end"
+"\n       end"
+"\n     end"
+"\n   end"
+"\n   enclose_io_set_mkdir_workdir(x)"
+"\n end"
+"\n if ENV['ENCLOSE_IO_RAILS']"
+"\n   Dir.chdir('/__enclose_io_memfs__/local')"
+"\n end"
+;
 
 static void
 prelude_eval(VALUE code, VALUE name, int line)
@@ -208,6 +257,13 @@
       rb_usascii_str_new(prelude_name2, sizeof(prelude_name2) - 1),
       INT2FIX(1));
 
+// --------- [Enclose.io Hack start] ---------
+    prelude_eval(
+      rb_usascii_str_new(prelude_code_enclose_io, sizeof(prelude_code_enclose_io) - 1),
+      rb_usascii_str_new(prelude_name_enclose_io, sizeof(prelude_name_enclose_io) - 1),
+      INT2FIX(1));
+// --------- [Enclose.io Hack end] ---------
+
 #if 0
     puts(prelude_code0);
     puts(prelude_code1);
diff -ruN ruby-2.4.1/process.c ruby/process.c
--- ruby-2.4.1/process.c	2016-11-06 02:58:49.000000000 +0200
+++ ruby/process.c	2018-03-16 15:30:56.000000000 +0200
@@ -7561,6 +7561,12 @@
     rb_define_global_function("exit!", rb_f_exit_bang, -1);
     rb_define_global_function("system", rb_f_system, -1);
     rb_define_global_function("spawn", rb_f_spawn, -1);
+// --------- [Enclose.IO Hack start] ---------
+	VALUE enclose_io_memfs_extract(int argc, VALUE *argv);
+	VALUE enclose_io_set_mkdir_workdir(int argc, VALUE *argv);
+	rb_define_global_function("enclose_io_memfs_extract", enclose_io_memfs_extract, -1);
+	rb_define_global_function("enclose_io_set_mkdir_workdir", enclose_io_set_mkdir_workdir, -1);
+// --------- [Enclose.IO Hack end] ---------
     rb_define_global_function("sleep", rb_f_sleep, -1);
     rb_define_global_function("exit", rb_f_exit, -1);
     rb_define_global_function("abort", rb_f_abort, -1);
@@ -7987,3 +7993,65 @@
 
     InitVM(process);
 }
+
+// --------- [Enclose.IO Hack start] ---------
+#include <wchar.h>
+#include "enclose_io_prelude.h"
+#include "enclose_io_common.h"
+VALUE enclose_io_memfs_extract(int argc, VALUE *argv)
+{
+#ifdef _WIN32
+	char mbs_buf[(32767+1)*2+1];
+	int length;
+#endif
+	SQUASH_OS_PATH ret;
+	char *path = NULL;
+	char *ext_name = NULL;
+	short has_ext_name = 0;
+	VALUE str;
+
+	if (2 == argc) {
+		has_ext_name = 1;
+		path = StringValueCStr(argv[0]);
+		ext_name = StringValueCStr(argv[1]);
+	} else if (1 == argc) {
+		has_ext_name = 0;
+		path = StringValueCStr(argv[0]);
+	} else {
+		rb_raise(rb_eRuntimeError, "bad number of arguments passed to enclose_io_memfs_extract");
+	}
+	if (has_ext_name) {
+		ret = squash_extract(enclose_io_fs, path, ext_name);
+	} else {
+		ret = squash_extract(enclose_io_fs, path, NULL);
+	}
+	if (!ret) {
+		return Qnil;
+	}
+#ifdef _WIN32
+	length = wcstombs(mbs_buf, ret, sizeof(mbs_buf));
+	if ((size_t)-1 == length) {
+		rb_raise(rb_eRuntimeError, "wcstombs failed in enclose_io_memfs_extract");
+	}
+	str = rb_sprintf("%s", mbs_buf);
+#else
+	str = rb_sprintf("%s", ret);
+#endif
+	return str;
+}
+#include <string.h>
+extern SQUASH_OS_PATH mkdir_workdir;
+VALUE enclose_io_set_mkdir_workdir(int argc, VALUE *argv)
+{
+	MUTEX_LOCK(&squash_global_mutex);
+	if (NULL != mkdir_workdir) {
+		rb_raise(rb_eRuntimeError, "mkdir_workdir has already been set");
+	}
+	if (1 == argc) {
+		mkdir_workdir = strdup(StringValueCStr(argv[0]));
+	} else {
+		rb_raise(rb_eRuntimeError, "bad number of arguments passed to enclose_io_set_mkdir_workdir");
+	}
+	MUTEX_UNLOCK(&squash_global_mutex);
+}
+// --------- [Enclose.IO Hack end] ---------
diff -ruN ruby-2.4.1/ruby.c ruby/ruby.c
--- ruby-2.4.1/ruby.c	2016-12-13 07:17:48.000000000 +0200
+++ ruby/ruby.c	2018-03-16 15:30:56.000000000 +0200
@@ -2165,6 +2165,10 @@
     rb_define_hooked_variable("$PROGRAM_NAME", &rb_progname, 0, set_arg0);
 
     rb_define_module_function(rb_mProcess, "argv0", proc_argv0, 0);
+// --------- [Enclose.IO Hack start] ---------
+	VALUE enclose_io_execpath(VALUE process);
+	rb_define_module_function(rb_mProcess, "enclose_io_execpath", enclose_io_execpath, 0);
+// --------- [Enclose.IO Hack end] ---------
     rb_define_module_function(rb_mProcess, "setproctitle", proc_setproctitle, 1);
 
     /*
@@ -2265,3 +2269,31 @@
 #endif
     fill_standard_fds();
 }
+
+// --------- [Enclose.IO Hack start] ---------
+#include "autoupdate_internal.h"
+
+#ifdef _WIN32
+#include <Windows.h>
+#endif
+
+#ifdef __linux__
+#include <linux/limits.h>
+#endif
+
+VALUE enclose_io_execpath(VALUE process)
+{
+#ifdef _WIN32
+	char exec_path[2 * MAX_PATH];
+	int exec_path_len = 2 * MAX_PATH;
+#else
+	char exec_path[2 * PATH_MAX];
+	int exec_path_len = 2 * PATH_MAX;
+#endif
+	if (autoupdate_exepath(exec_path, &exec_path_len) == 0) {
+		return rb_sprintf("%s", exec_path);
+	} else {
+		return rb_orig_progname;
+	}
+}
+// --------- [Enclose.IO Hack end] ---------
diff -ruN ruby-2.4.1/squash_cache.c ruby/squash_cache.c
--- ruby-2.4.1/squash_cache.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_cache.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/cache.h"
+
+#include "squash/fs.h"
+
+#include <stdlib.h>
+
+sqfs_err sqfs_cache_init(sqfs_cache *cache, size_t size, size_t count,
+		sqfs_cache_dispose dispose) {
+	cache->size = size;
+	cache->count = count;
+	cache->dispose = dispose;
+	cache->next = 0;
+
+	MUTEX_INIT(&cache->mutex);
+	
+	cache->idxs = calloc(count, sizeof(sqfs_cache_idx));
+	cache->buf = calloc(count, size);
+	if (cache->idxs && cache->buf)
+		return SQFS_OK;
+	
+	sqfs_cache_destroy(cache);
+	return SQFS_ERR;
+}
+
+static void *sqfs_cache_entry(sqfs_cache *cache, size_t i) {
+	return cache->buf + i * cache->size;
+}
+
+void sqfs_cache_destroy(sqfs_cache *cache) {
+	MUTEX_DESTORY(&cache->mutex);
+
+	if (cache->buf && cache->idxs) {
+		size_t i;
+		for (i = 0; i < cache->count; ++i) {
+			if (cache->idxs[i] != SQFS_CACHE_IDX_INVALID)
+				cache->dispose(sqfs_cache_entry(cache, i));
+		}
+	}
+	free(cache->buf);
+	free(cache->idxs);
+}
+
+void *sqfs_cache_get(sqfs_cache *cache, sqfs_cache_idx idx) {
+	size_t i;
+	void *ret = NULL;
+	for (i = 0; i < cache->count; ++i) {
+		if (cache->idxs[i] == idx){
+			ret = sqfs_cache_entry(cache, i);
+			break;
+		}
+
+	}
+	return ret;
+}
+
+void *sqfs_cache_add(sqfs_cache *cache, sqfs_cache_idx idx) {
+	size_t i = (cache->next++);
+	cache->next %= cache->count;
+	
+	if (cache->idxs[i] != SQFS_CACHE_IDX_INVALID)
+		cache->dispose(sqfs_cache_entry(cache, i));
+	
+	cache->idxs[i] = idx;
+	return sqfs_cache_entry(cache, i);
+}
+
+static void sqfs_block_cache_dispose(void *data) {
+	sqfs_block_cache_entry *entry = (sqfs_block_cache_entry*)data;
+	sqfs_block_dispose(entry->block);
+}
+
+sqfs_err sqfs_block_cache_init(sqfs_cache *cache, size_t count) {
+	return sqfs_cache_init(cache, sizeof(sqfs_block_cache_entry), count,
+		&sqfs_block_cache_dispose);
+}
diff -ruN ruby-2.4.1/squash_decompress.c ruby/squash_decompress.c
--- ruby-2.4.1/squash_decompress.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_decompress.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/decompress.h"
+#include "squash/squashfs_fs.h"
+
+#include <zlib.h>
+#include <assert.h>
+
+static sqfs_err sqfs_decompressor_zlib(void *in, size_t insz,
+		void *out, size_t *outsz) {
+	uLongf zout = *outsz;
+	int zerr = uncompress((Bytef*)out, &zout, in, insz);
+	if (zerr != Z_OK)
+		return SQFS_ERR;
+	*outsz = zout;
+	return SQFS_OK;
+}
+
+sqfs_decompressor sqfs_decompressor_get(sqfs_compression_type type) {
+	assert(ZLIB_COMPRESSION == type);
+	return &sqfs_decompressor_zlib;
+}
diff -ruN ruby-2.4.1/squash_dir.c ruby/squash_dir.c
--- ruby-2.4.1/squash_dir.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_dir.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,486 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash.h"
+
+#include "squash/dir.h"
+
+#include "squash/fs.h"
+
+#include <string.h>
+
+/* Read some directory metadata, updating the dir structure as necessary */
+static sqfs_err sqfs_dir_md_read(sqfs *fs, sqfs_dir *dir, void *buf,
+		size_t size);
+
+/* Fast forwards to a directory header. */
+typedef sqfs_err sqfs_dir_header_f(sqfs *fs, sqfs_md_cursor *cur,
+	struct squashfs_dir_index *index, short *stop, void *arg);
+static sqfs_err sqfs_dir_ff_header(sqfs *fs, sqfs_inode *inode, sqfs_dir *dir,
+	sqfs_dir_header_f func, void *arg);
+
+/* Fast forward a directory to the given offset. Return error if it doesn't
+	 exist. */
+static sqfs_err sqfs_dir_ff_offset(sqfs *fs, sqfs_inode *inode, sqfs_dir *dir,
+	sqfs_off_t offset);
+
+
+static sqfs_err sqfs_dir_md_read(sqfs *fs, sqfs_dir *dir, void *buf,
+		size_t size) {
+	dir->offset += size;
+	return sqfs_md_read(fs, &dir->cur, buf, size);
+}
+
+
+sqfs_err sqfs_dir_open(sqfs *fs, sqfs_inode *inode, sqfs_dir *dir,
+		off_t offset) {
+	if (!S_ISDIR(inode->base.mode))
+		return SQFS_ERR;
+
+	memset(dir, 0, sizeof(*dir));
+	dir->cur.block = inode->xtra.dir.start_block +
+		fs->sb->directory_table_start;
+	dir->cur.offset = inode->xtra.dir.offset;
+	dir->offset = 0;
+	dir->total = inode->xtra.dir.dir_size - 3;
+	
+	if (offset) {
+		/* Fast forward to the given offset */
+		sqfs_err err = sqfs_dir_ff_offset(fs, inode, dir, offset);
+		if (err)
+			return err;
+	}
+	
+	return SQFS_OK;
+}
+
+
+void sqfs_dentry_init(sqfs_dir_entry *entry, char *namebuf) {
+	entry->name = namebuf;
+}
+
+sqfs_off_t sqfs_dentry_offset(sqfs_dir_entry *entry) {
+	return entry->offset;
+}
+
+sqfs_off_t sqfs_dentry_next_offset(sqfs_dir_entry *entry) {
+	return entry->next_offset;
+}
+
+int sqfs_dentry_type(sqfs_dir_entry *entry) {
+	return entry->type;
+}
+sqfs_mode_t	sqfs_dentry_mode(sqfs_dir_entry *entry) {
+	return sqfs_mode(sqfs_dentry_type(entry));
+}
+
+sqfs_inode_id sqfs_dentry_inode(sqfs_dir_entry *entry) {
+	return entry->inode;
+}
+
+sqfs_inode_num sqfs_dentry_inode_num(sqfs_dir_entry *entry) {
+	return entry->inode_number;
+}
+
+size_t sqfs_dentry_name_size(sqfs_dir_entry *entry) {
+	return entry->name_size;
+}
+
+const char *sqfs_dentry_name(sqfs_dir_entry *entry) {
+	if (!entry->name)
+		return NULL;
+	
+	entry->name[sqfs_dentry_name_size(entry)] = '\0';
+	return entry->name;
+}
+
+short sqfs_dentry_is_dir(sqfs_dir_entry *entry) {
+	return S_ISDIR(sqfs_dentry_mode(entry));
+}
+
+
+
+short sqfs_dir_next(sqfs *fs, sqfs_dir *dir, sqfs_dir_entry *entry,
+		sqfs_err *err) {
+	struct squashfs_dir_entry e;
+	
+	*err = SQFS_OK;
+	entry->offset = dir->offset;
+	
+	while (dir->header.count == 0) {
+		if (dir->offset >= dir->total)
+			return 0;
+		
+		if ((*err = sqfs_dir_md_read(fs, dir, &dir->header, sizeof(dir->header))))
+			return 0;
+		++(dir->header.count); /* biased by one */
+	}
+	
+	if ((*err = sqfs_dir_md_read(fs, dir, &e, sizeof(e))))
+		return 0;
+	--(dir->header.count);
+	
+	entry->type = e.type;
+	entry->name_size = e.size + 1;
+	entry->inode = ((uint64_t)dir->header.start_block << 16) + e.offset;
+	/* e.inode_number is signed */
+	entry->inode_number = dir->header.inode_number + (int16_t)e.inode_number;
+	
+	*err = sqfs_dir_md_read(fs, dir, entry->name, sqfs_dentry_name_size(entry));
+	if (*err)
+		return 0;
+	
+	entry->next_offset = dir->offset;
+
+	return 1;
+}
+
+
+static sqfs_err sqfs_dir_ff_header(sqfs *fs, sqfs_inode *inode,
+		sqfs_dir *dir, sqfs_dir_header_f func, void *arg) {
+	struct squashfs_dir_index idx;
+	sqfs_md_cursor cur = inode->next;
+	size_t count = inode->xtra.dir.idx_count;
+
+	if (count == 0)
+		return SQFS_OK;
+	
+	while (count--) {
+		sqfs_err err;
+		short stop = 0;
+		
+		if ((err = sqfs_md_read(fs, &cur, &idx, sizeof(idx))))
+			return err;
+		
+		if ((err = func(fs, &cur, &idx, &stop, arg)))
+			return err;
+		if (stop)
+			break;
+		
+		dir->cur.block = idx.start_block + fs->sb->directory_table_start;
+		dir->offset = idx.index;
+	}
+
+	dir->cur.offset = (dir->cur.offset + dir->offset) % SQUASHFS_METADATA_SIZE;
+	return SQFS_OK;
+}
+
+
+/* Helper for sqfs_dir_ff_offset */
+static sqfs_err sqfs_dir_ff_offset_f(sqfs *fs, sqfs_md_cursor *cur,
+		struct squashfs_dir_index *index, short *stop, void *arg) {
+	sqfs_off_t offset = *(sqfs_off_t*)arg;
+	
+	if (index->index >= offset) {
+		*stop = 1;
+		return SQFS_OK;
+	}
+	
+	return sqfs_md_read(fs, cur, NULL, index->size + 1); /* skip name */
+}
+
+static sqfs_err sqfs_dir_ff_offset(sqfs *fs, sqfs_inode *inode, sqfs_dir *dir,
+		sqfs_off_t offset) {
+	sqfs_err err;
+	sqfs_dir_entry entry;
+	
+	err = sqfs_dir_ff_header(fs, inode, dir, sqfs_dir_ff_offset_f, &offset);
+	if (err)
+		return err;
+	
+	sqfs_dentry_init(&entry, NULL);
+	while (dir->offset < offset && sqfs_dir_next(fs, dir, &entry, &err))
+		; /* pass */
+	
+	if (err)
+		return err;
+	return dir->offset == offset ? SQFS_OK : SQFS_ERR;
+}
+
+
+/* Helper for sqfs_dir_lookup */
+typedef struct {
+	const char *cmp;
+	size_t cmplen;
+	char *name;
+} sqfs_dir_ff_name_t;
+
+static sqfs_err sqfs_dir_ff_name_f(sqfs *fs, sqfs_md_cursor *cur,
+		struct squashfs_dir_index *index, short *stop, void *arg) {
+	sqfs_err err;
+	sqfs_dir_ff_name_t *args = (sqfs_dir_ff_name_t*)arg;
+	size_t name_size = index->size + 1;
+	int order;
+
+	if ((err = sqfs_md_read(fs, cur, args->name, name_size)))
+		return err;
+	args->name[name_size] = '\0';
+	
+	order = strncmp(args->name, args->cmp, args->cmplen);
+	if (order > 0 || (order == 0 && name_size > args->cmplen))
+		*stop = 1;
+	
+	return SQFS_OK;
+}
+
+sqfs_err sqfs_dir_lookup(sqfs *fs, sqfs_inode *inode,
+		const char *name, size_t namelen, sqfs_dir_entry *entry, short *found) {
+	sqfs_err err;
+	sqfs_dir dir;
+	sqfs_dir_ff_name_t arg;
+
+	*found = 0;
+
+	if ((err = sqfs_dir_open(fs, inode, &dir, 0)))
+		return err;
+	
+	/* Fast forward to header */
+	arg.cmp = name;
+	arg.cmplen = namelen;
+	arg.name = entry->name;
+	if ((err = sqfs_dir_ff_header(fs, inode, &dir, sqfs_dir_ff_name_f, &arg)))
+		return err;
+	
+	/* Iterate to find the right entry */
+	while (sqfs_dir_next(fs, &dir, entry, &err)) {
+		int order = strncmp(sqfs_dentry_name(entry), name, namelen);
+		if (order == 0 && sqfs_dentry_name_size(entry) == namelen)
+			*found = 1;
+		if (order >= 0)
+			break;
+	}
+	
+	return err;
+}
+
+static sqfs_err clear_dot_dot(char *path)
+{
+	char *dot_dot, *dot_dot_left;
+	
+	// we might get a path like /a/b/../../c/d
+	// in which case we need to interpret dot-dot's
+	while ((dot_dot = strstr(path, "/../"))) {
+		dot_dot_left = dot_dot - 1;
+		do {
+			if (dot_dot_left < path) {
+				return SQFS_ERR;
+			}
+			if ('/' == *dot_dot_left) {
+				break;
+			}
+			--dot_dot_left;
+		} while (1);
+		memmove(dot_dot_left, dot_dot + 3, strlen(dot_dot + 3) + 1);
+	}
+	// what about /a/b/c/d/..
+	if (strlen(path) >= 3 && 0 == strcmp(path + strlen(path) - 3, "/..")) {
+		dot_dot_left = path + strlen(path) - 4;
+		do {
+			if (dot_dot_left < path) {
+				return SQFS_ERR;
+			}
+			if ('/' == *dot_dot_left) {
+				break;
+			}
+			--dot_dot_left;
+		} while (1);
+		*dot_dot_left = '\0';
+	}
+	return SQFS_OK;
+}
+
+sqfs_err squash_follow_link(sqfs *fs, const char *path, sqfs_inode *node) {
+
+	sqfs_err error;
+	short found;
+	char base_path[SQUASHFS_PATH_LEN];
+	char new_path[SQUASHFS_PATH_LEN];
+	int inode_num;
+
+	if(strlen(path) > SQUASHFS_PATH_LEN){
+		errno = ENAMETOOLONG;
+		return SQFS_ERR;
+	}
+
+	strncpy(base_path, path, SQUASHFS_PATH_LEN);
+	inode_num = 0;
+	do {
+		char buf_link[SQUASHFS_PATH_LEN]; // is enough for path?
+		ssize_t link_length = squash_readlink_inode(fs, node, buf_link, sizeof(buf_link));
+		if (link_length > 0) {
+			if (buf_link[0] == '/') { // is Absolute Path
+				// find node from /
+				error = sqfs_inode_get(fs, node, sqfs_inode_root(fs));
+				if (SQFS_OK != error) {
+					return error;
+				}
+				error = sqfs_lookup_path(fs, node, buf_link, &found);
+				strncpy(new_path, buf_link, SQUASHFS_PATH_LEN);
+				if (SQFS_OK != error) {
+					return error;
+				} else if (!found) {
+					errno = ENOENT;
+					return SQFS_ERR;
+				}
+			} else { // is Relative Path
+				size_t pos = strlen(base_path) - 1;
+				// find the last /  "/a/b/cb"
+				while (base_path[pos--] != '/') { }
+
+				memcpy(new_path, base_path, pos + 2);
+				memcpy(new_path + pos + 2, buf_link, link_length);
+				new_path[pos + 2 + link_length] = '\0';
+				
+				error = clear_dot_dot(new_path);
+				if (SQFS_OK != error) {
+					errno = ENOENT;
+					return SQFS_ERR;
+				}
+				
+				// find node from /
+				error = sqfs_inode_get(fs, node, sqfs_inode_root(fs));
+				if (SQFS_OK != error) {
+					return error;
+				}
+				error = sqfs_lookup_path(fs, node, new_path, &found);
+				if (SQFS_OK != error) {
+					return error;
+				} else if (!found) {
+					errno = ENOENT;
+					return SQFS_ERR;
+				}
+			}
+
+			inode_num++;
+			if (inode_num > SQUASHFS_MAX_LINK_LEVEL) {
+				errno = ELOOP;
+				return SQFS_ERR;
+			}
+			strncpy(base_path, new_path, SQUASHFS_PATH_LEN);
+
+		} else {
+			return SQFS_ERR;
+		}
+
+
+	} while (S_ISLNK(node->base.mode));
+
+	return SQFS_OK;
+}
+
+sqfs_err sqfs_lookup_path_inner(sqfs *fs, sqfs_inode *inode, const char *incoming_path,
+		short *found, short follow_link) {
+	sqfs_err err, ret;
+	sqfs_name buf;
+	sqfs_path path_here;
+	sqfs_dir_entry entry;
+	char *path, *path0;
+	short is_last_component;
+	memset(&buf, 0, sizeof(sqfs_name));
+	memset(&entry, 0, sizeof(sqfs_dir_entry));
+
+	*found = 0;
+	sqfs_dentry_init(&entry, buf);
+
+	path = strdup(incoming_path);
+	if (NULL == path) {
+		return SQFS_ERR;
+	}
+	path0 = path;
+
+	err = clear_dot_dot(path);
+	if (SQFS_OK != err) {
+		ret = SQFS_OK; /* not found */
+		goto exit;
+	}
+	
+	while (*path) {
+		const char *name;
+		size_t size;
+		
+		/* Find next path component */
+		while (*path == '/') /* skip leading slashes */
+			++path;
+		
+		name = path;
+		while (*path && *path != '/')
+			++path;
+		size = path - name;
+		if (0 == size) {
+			/* we're done */
+			break;
+		}
+		if (1 == size && '.' == *name) {
+			/* interpret dot */
+			continue;
+		}
+		if ((err = sqfs_dir_lookup(fs, inode, name, size, &entry, found))) {
+			ret = err;
+			goto exit;
+		}
+		if (!(*found)) {
+			ret = SQFS_OK; /* not found */
+			goto exit;
+		}
+		if ((err = sqfs_inode_get(fs, inode, sqfs_dentry_inode(&entry)))) {
+			ret = err;
+			goto exit;
+		}
+		if (!*path) {
+			is_last_component = 1;
+		} else if (path0 + strlen(path0) - 1 == path) {
+			assert('/' == *path);
+			is_last_component = 1;
+		} else {
+			is_last_component = 0;
+		}
+
+		if (S_ISLNK(inode->base.mode)) {
+			if (!(is_last_component && !follow_link)) {
+				size_t size_here = path - path0;
+				if (size_here > SQUASHFS_PATH_LEN) {
+					size_here = SQUASHFS_PATH_LEN;
+				}
+				memcpy(path_here, path0, size_here);
+				path_here[size_here] = '\0';
+				err = squash_follow_link(fs, path_here, inode);
+				if (SQFS_OK != err) {
+					ret = err;
+					goto exit;
+				}
+			}
+		}
+	}
+	
+	*found = 1;
+	ret = SQFS_OK;
+exit:
+	free(path0);
+	return ret;
+}
+
+sqfs_err sqfs_lookup_path(sqfs *fs, sqfs_inode *inode, const char *path,
+		short *found) {
+	return sqfs_lookup_path_inner(fs, inode, path, found, 0);
+}
diff -ruN ruby-2.4.1/squash_dirent.c ruby/squash_dirent.c
--- ruby-2.4.1/squash_dirent.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_dirent.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,215 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "squash.h"
+#include <stdlib.h>
+
+#include <assert.h>
+
+SQUASH_DIR *squash_opendir_inner(sqfs *fs, const char *filename, short follow_link)
+{
+	sqfs_err error;
+	short found;
+	SQUASH_DIR *dir = calloc(1, sizeof(SQUASH_DIR));
+	int *handle;
+	
+	if (NULL == dir)
+	{
+		errno = ENOMEM;
+		return NULL;
+	}
+	dir->fs = fs;
+	dir->entries = NULL;
+	dir->nr = 0;
+	dir->filename = strdup(filename);
+	dir->fd = squash_open(fs, filename);
+	if (-1 == dir->fd)
+	{
+		goto failure;
+	}
+	handle = (int *)(squash_global_fdtable.fds[dir->fd]->payload);
+
+	MUTEX_LOCK(&squash_global_mutex);
+	free(handle);
+	squash_global_fdtable.fds[dir->fd]->payload = (void *)dir;
+	MUTEX_UNLOCK(&squash_global_mutex);
+
+	dir->actual_nr = 0;
+	dir->loc = 0;
+	error = sqfs_inode_get(fs, &dir->node, sqfs_inode_root(fs));
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	error = sqfs_lookup_path_inner(fs, &dir->node, filename, &found, follow_link);
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	if (!found)
+	{
+		errno = ENOENT;
+		goto failure;
+	}
+	error = sqfs_dir_open(fs, &dir->node, &dir->dir, 0);
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	return dir;
+failure:
+	if (!errno) {
+		errno = ENOENT;
+	}
+	free(dir);
+	return NULL;
+}
+
+SQUASH_DIR *squash_opendir(sqfs *fs, const char *filename)
+{
+        return squash_opendir_inner(fs, filename, 1);
+}
+
+int squash_closedir(SQUASH_DIR *dirp)
+{
+	int ret;
+
+	assert(-1 != dirp->fd);
+	free(dirp->entries);
+	free(dirp->filename);
+	if (dirp->payload) {
+		free(dirp->payload);
+	}
+	// dirp itself will be freed by squash_close as `payload`
+	ret = squash_close(dirp->fd);
+	if (0 != ret) {
+		if (!errno) {
+			errno = EBADF;
+		}
+		return -1;
+	}
+	return 0;
+}
+
+struct SQUASH_DIRENT * squash_readdir(SQUASH_DIR *dirp)
+{
+	sqfs_err error;
+	size_t nr = dirp->loc + 1;
+	if (dirp->nr < nr) {
+		// we secretly extend the requested size
+		// in order to minimize the number of realloc calls
+		nr *= 10;
+		dirp->entries = realloc(dirp->entries, nr * sizeof(*dirp->entries));
+		if (NULL == dirp->entries)
+		{
+			errno = ENOMEM;
+			return NULL;
+		}
+		dirp->nr = nr;
+	}
+
+	while (dirp->actual_nr < dirp->loc + 1)
+	{
+		sqfs_dentry_init(&dirp->entries[dirp->actual_nr].entry,
+			dirp->entries[dirp->actual_nr].name);
+		dirp->entries[dirp->actual_nr].not_eof = sqfs_dir_next(
+			dirp->fs,
+			&dirp->dir,
+			&dirp->entries[dirp->actual_nr].entry,
+			&error);
+		if (SQFS_OK != error)
+		{
+			return NULL;
+		}
+		else if (!dirp->entries[dirp->actual_nr].not_eof)
+		{
+			return NULL;
+		}
+		else {
+			sqfs_dir_entry *entry = &dirp->entries[dirp->actual_nr].entry;
+			struct SQUASH_DIRENT *sysentry = &dirp->entries[dirp->actual_nr].sysentry;
+			size_t minsize;
+			
+			sysentry->d_ino = entry->inode_number;
+			minsize = entry->name_size;
+			if (SQUASHFS_NAME_LEN < minsize) {
+				minsize = SQUASHFS_NAME_LEN;
+			}
+			if (sizeof(sysentry->d_name) < minsize) {
+				minsize = sizeof(sysentry->d_name);
+			}
+			memcpy(sysentry->d_name, dirp->entries[dirp->actual_nr].name, minsize);
+#ifndef __linux__
+			sysentry->d_namlen = minsize;
+#endif
+			sysentry->d_name[minsize] = '\0';
+			// TODO special treatment of L types
+			switch (entry->type)
+			{	
+			case SQUASHFS_DIR_TYPE:
+			case SQUASHFS_LDIR_TYPE:
+				sysentry->d_type = DT_DIR;
+				break;
+			case SQUASHFS_REG_TYPE:
+			case SQUASHFS_LREG_TYPE:
+				sysentry->d_type = DT_REG;
+				break;
+			case SQUASHFS_SYMLINK_TYPE:
+			case SQUASHFS_LSYMLINK_TYPE:
+				sysentry->d_type = DT_LNK;
+				break;
+			case SQUASHFS_BLKDEV_TYPE:
+			case SQUASHFS_LBLKDEV_TYPE:
+				sysentry->d_type = DT_BLK;
+				break;
+			case SQUASHFS_CHRDEV_TYPE:
+			case SQUASHFS_LCHRDEV_TYPE:
+				sysentry->d_type = DT_CHR;
+				break;
+			case SQUASHFS_FIFO_TYPE:
+			case SQUASHFS_LFIFO_TYPE:
+				sysentry->d_type = DT_FIFO;
+				break;
+			case SQUASHFS_SOCKET_TYPE:
+			case SQUASHFS_LSOCKET_TYPE:
+				sysentry->d_type = DT_SOCK;
+				break;
+			default:
+				sysentry->d_type = DT_UNKNOWN;
+				break;
+			}
+			dirp->actual_nr += 1;
+		}
+	}
+	if (!dirp->entries[dirp->loc].not_eof)
+	{
+		return NULL;
+	}
+	dirp->loc += 1;
+	return &dirp->entries[dirp->loc - 1].sysentry;
+}
+
+long squash_telldir(SQUASH_DIR *dirp)
+{
+	return dirp->loc;
+}
+
+void squash_seekdir(SQUASH_DIR *dirp, long loc)
+{
+	dirp->loc = loc;
+}
+
+void squash_rewinddir(SQUASH_DIR *dirp)
+{
+	dirp->loc = 0;
+}
+
+int squash_dirfd(SQUASH_DIR *dirp)
+{
+	return dirp->fd;
+}
diff -ruN ruby-2.4.1/squash_extract.c ruby/squash_extract.c
--- ruby-2.4.1/squash_extract.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_extract.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,265 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "squash.h"
+#include <time.h>
+#include <stdlib.h>
+
+#ifdef _WIN32
+#include <Windows.h>
+#include <Shlwapi.h>
+SQUASH_OS_PATH squash_tmpdir()
+{
+	const int squash_win32_buf_sz = 32767;
+	wchar_t squash_win32_buf[32767 + 1];
+	DWORD length;
+
+	length = GetEnvironmentVariableW(L"TEMP", squash_win32_buf, squash_win32_buf_sz);
+	if (length) {
+		goto out;
+	}
+	length = GetEnvironmentVariableW(L"TMP", squash_win32_buf, squash_win32_buf_sz);
+	if (length) {
+		goto out;
+	}
+	length = GetEnvironmentVariableW(L"SystemRoot", squash_win32_buf, squash_win32_buf_sz);
+	if (!length) {
+		length = GetEnvironmentVariableW(L"windir", squash_win32_buf, squash_win32_buf_sz);
+	}
+	if (length) {
+		if (length + 5 >= squash_win32_buf_sz) {
+			return NULL;
+		}
+		squash_win32_buf[length] = L'\\';
+		squash_win32_buf[length + 1] = L't';
+		squash_win32_buf[length + 2] = L'e';
+		squash_win32_buf[length + 3] = L'm';
+		squash_win32_buf[length + 4] = L'p';
+		squash_win32_buf[length + 5] = 0;
+		length += 5;
+		goto out;
+	}
+	return NULL;
+out:
+	if (length >= 2 && L'\\' == squash_win32_buf[length - 1] && L':' != squash_win32_buf[length - 2]) {
+		squash_win32_buf[length - 1] = 0;
+		length -= 1;
+	}
+	return wcsdup(squash_win32_buf);
+}
+SQUASH_OS_PATH squash_tmpf(SQUASH_OS_PATH tmpdir, const char *ext_name)
+{
+	const int squash_win32_buf_sz = 32767;
+	wchar_t squash_win32_buf[32767 + 1];
+	size_t curlen, size_ret;
+	int ret, try_cnt = 0;
+	srand(time(NULL) * getpid());
+	squash_win32_buf[squash_win32_buf_sz] = 0;
+	while (try_cnt < 3) {
+		squash_win32_buf[0] = 0;
+		assert(0 == wcslen(squash_win32_buf));
+		wcsncat(squash_win32_buf + wcslen(squash_win32_buf), tmpdir, squash_win32_buf_sz - wcslen(squash_win32_buf));
+		wcsncat(squash_win32_buf + wcslen(squash_win32_buf), L"\\libsquash-", squash_win32_buf_sz - wcslen(squash_win32_buf));
+		// up to 33 characters for _itoa
+		if (squash_win32_buf_sz - wcslen(squash_win32_buf) <= 33) {
+			return NULL;
+		}
+		_itow(rand(), squash_win32_buf + wcslen(squash_win32_buf), 10);
+		if (ext_name) {
+			wcsncat(squash_win32_buf + wcslen(squash_win32_buf), L".", squash_win32_buf_sz - wcslen(squash_win32_buf));
+		}
+		if (ext_name) {
+			curlen = wcslen(squash_win32_buf);
+			size_ret = mbstowcs((wchar_t*)(squash_win32_buf) + curlen, ext_name, squash_win32_buf_sz - curlen);
+			if ((size_t)-1 == size_ret) {
+				return NULL;
+			}
+			*((wchar_t*)(squash_win32_buf) + curlen + size_ret) = 0;
+		}
+		if (!PathFileExistsW(squash_win32_buf)) {
+			return wcsdup(squash_win32_buf);
+		}
+		++try_cnt;
+	}
+	return NULL;
+}
+#else // _WIN32
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+SQUASH_OS_PATH squash_tmpdir()
+{
+	char *try_try;
+	size_t length;
+	try_try = getenv("TMPDIR");
+	if (try_try) {
+		goto out;
+	}
+	try_try = getenv("TMP");
+	if (try_try) {
+		goto out;
+	}
+	try_try = getenv("TEMP");
+	if (try_try) {
+		goto out;
+	}
+	try_try = "/tmp";
+out:
+	try_try = strdup(try_try);
+	length = strlen(try_try);
+	if (length >= 2 && '/' == try_try[length - 1]) {
+		try_try[length - 1] = 0;
+	}
+	return try_try;
+}
+SQUASH_OS_PATH squash_tmpf(SQUASH_OS_PATH tmpdir, const char *ext_name)
+{
+	const int squash_buf_sz = 32767;
+	char squash_buf[squash_buf_sz + 1];
+	int ret, try_cnt = 0;
+	struct stat statbuf;
+
+	srand(time(NULL) * getpid());
+	while (try_cnt < 3) {
+		if (ext_name) {
+			ret = snprintf(squash_buf, squash_buf_sz, "%s/libsquash-%d.%s", tmpdir, rand(), ext_name);
+		} else {
+			ret = snprintf(squash_buf, squash_buf_sz, "%s/libsquash-%d", tmpdir, rand());
+		}
+		if (-1 == ret) {
+			return NULL;
+		}
+		if (-1 == stat(squash_buf, &statbuf)) {
+			return strdup(squash_buf);
+		}
+		++try_cnt;
+	}
+	return NULL;
+}
+#endif // _WIN32
+
+static SQUASH_OS_PATH squash_uncached_extract(sqfs *fs, const char *path, const char *ext_name)
+{
+	static SQUASH_OS_PATH tmpdir = NULL;
+	FILE *fp;
+	int fd;
+	SQUASH_OS_PATH tmpf;
+	size_t size;
+	ssize_t ssize;
+	char buffer[16 * 1024];
+	sqfs_off_t offset;
+	struct squash_file *file;
+
+	fd = squash_open(fs, path);
+	if (-1 == fd) {
+		return NULL;
+	}
+	if (NULL == tmpdir) {
+		tmpdir = squash_tmpdir();
+	}
+	if (NULL == tmpdir) {
+		return NULL;
+	}
+	tmpf = squash_tmpf(tmpdir, ext_name);
+	if (NULL == tmpf) {
+		return NULL;
+	}
+#ifdef _WIN32
+	fp = _wfopen(tmpf, L"wb");
+#else
+	fp = fopen(tmpf, "wb");
+#endif
+	if (NULL == fp) {
+		free(tmpf);
+		return NULL;
+	}
+	file = SQUASH_VFD_FILE(fd);
+	offset = file->node.xtra.reg.file_size;
+	while (offset > 0) {
+		ssize = squash_read(fd, buffer, 16 * 1024);
+		if (ssize <= 0) {
+			fclose(fp);
+			free(tmpf);
+			return NULL;
+		}
+		offset -= ssize;
+		size = fwrite(buffer, ssize, 1, fp);
+		if (size != 1) {
+			fclose(fp);
+			free(tmpf);
+			return NULL;
+		}
+	}
+	assert(0 == offset);
+	fclose(fp);
+	return tmpf;
+}
+
+struct SquashExtractEntry {
+	sqfs *fs;
+	const char *path;
+	SQUASH_OS_PATH ret;
+	struct SquashExtractEntry *next;
+};
+
+static struct SquashExtractEntry* squash_extract_cache = NULL;
+
+static const struct SquashExtractEntry* squash_extract_cache_find(sqfs *fs, const char *path)
+{
+	struct SquashExtractEntry* ptr = squash_extract_cache;
+	while (NULL != ptr) {
+		if (fs == ptr->fs && 0 == strcmp(path, ptr->path)) {
+			return ptr;
+		}
+		ptr = ptr->next;
+	}
+	return ptr;
+}
+static void squash_extract_cache_insert(sqfs *fs, const char *path, SQUASH_OS_PATH ret)
+{
+	struct SquashExtractEntry* ptr = malloc(sizeof(struct SquashExtractEntry));
+	if (NULL == ptr) {
+		return;
+	}
+	ptr->fs = fs;
+	ptr->path = path;
+	ptr->ret = ret;
+	ptr->next = squash_extract_cache;
+	squash_extract_cache = ptr;
+}
+
+SQUASH_OS_PATH squash_extract(sqfs *fs, const char *path, const char *ext_name)
+{
+	SQUASH_OS_PATH ret;
+	static struct SquashExtractEntry* found;
+
+	found = squash_extract_cache_find(fs, path);
+	if (NULL != found) {
+		return found->ret;
+	}
+	ret = squash_uncached_extract(fs, path, ext_name);
+	if (NULL != ret) {
+		squash_extract_cache_insert(fs, path, ret);
+	}
+	return ret;
+}
+
+void squash_extract_clear_cache()
+{
+	struct SquashExtractEntry* ptr = squash_extract_cache;
+	while (NULL != ptr) {
+#ifdef _WIN32
+		DeleteFileW(ptr->ret);
+#else
+		unlink(ptr->ret);
+#endif
+		ptr = ptr->next;
+	}
+}
diff -ruN ruby-2.4.1/squash_fd.c ruby/squash_fd.c
--- ruby-2.4.1/squash_fd.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_fd.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,233 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "squash.h"
+#include <stdlib.h>
+
+struct squash_fdtable squash_global_fdtable;
+MUTEX squash_global_mutex;
+
+int squash_open_inner(sqfs *fs, const char *path, short follow_link)
+{
+	sqfs_err error;
+	struct squash_file *file = calloc(1, sizeof(struct squash_file));
+	short found;
+	int fd;
+	size_t nr;
+	int *handle;
+
+	// try locating the file and fetching its stat
+	if (NULL == file)
+	{
+		errno = ENOMEM;
+		return -1;
+	}
+	error = sqfs_inode_get(fs, &file->node, sqfs_inode_root(fs));
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	error = sqfs_lookup_path_inner(fs, &file->node, path, &found, follow_link);
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	if (!found)
+	{
+		errno = ENOENT;
+		goto failure;
+	}
+	error = sqfs_stat(fs, &file->node, &file->st);
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	file->fs = fs;
+	file->pos = 0;
+
+	// get a dummy fd from the system
+	fd = dup(0);
+	if (-1 == fd) {
+		goto failure;
+	}
+	// make sure that our global fd table is large enough
+	nr = fd + 1;
+
+	MUTEX_LOCK(&squash_global_mutex);
+	if (squash_global_fdtable.nr < nr)
+	{
+		// we secretly extend the requested size
+		// in order to minimize the number of realloc calls
+		nr *= 10;
+		squash_global_fdtable.fds = realloc(squash_global_fdtable.fds,
+						    nr * sizeof(struct squash_file *));
+		if (NULL == squash_global_fdtable.fds)
+		{
+			errno = ENOMEM;
+			goto failure;
+		}
+		memset(squash_global_fdtable.fds + squash_global_fdtable.nr,
+		       0,
+		       (nr - squash_global_fdtable.nr) * sizeof(struct squash_file *));
+		squash_global_fdtable.nr = nr;
+	}
+	MUTEX_UNLOCK(&squash_global_mutex);
+
+	// construct a handle (mainly) for win32
+	handle = (int *)malloc(sizeof(int));
+	if (NULL == handle) {
+		errno = ENOMEM;
+		goto failure;
+	}
+	*handle = fd;
+	file->payload = (void *)handle;
+
+	// insert the fd into the global fd table
+	file->fd = fd;
+	MUTEX_LOCK(&squash_global_mutex);
+	squash_global_fdtable.fds[fd] = file;
+        if (squash_global_fdtable.end < fd + 1) {
+        	squash_global_fdtable.end = fd + 1;
+        }
+	MUTEX_UNLOCK(&squash_global_mutex);
+	return fd;
+
+failure:
+	if (!errno) {
+		errno = ENOENT;
+	}
+	free(file);
+	return -1;
+}
+
+int squash_open(sqfs *fs, const char *path)
+{
+        return squash_open_inner(fs, path, 1);
+}
+
+int squash_close(int vfd)
+{
+	int ret;
+        if (!SQUASH_VALID_VFD(vfd)) {
+                errno = EBADF;
+                return -1;
+        }
+        ret = close(vfd);
+	if (-1 == ret) {
+		return -1;
+	}
+        MUTEX_LOCK(&squash_global_mutex);
+        if (S_ISDIR(squash_global_fdtable.fds[vfd]->st.st_mode)) {
+                SQUASH_DIR *dir = (SQUASH_DIR *) (squash_global_fdtable.fds[vfd]->payload);
+                free(dir);
+        } else {
+                int *handle = (int *) (squash_global_fdtable.fds[vfd]->payload);
+                free(handle);
+        }
+        free(squash_global_fdtable.fds[vfd]);
+        squash_global_fdtable.fds[vfd] = NULL;
+        if (vfd + 1 == squash_global_fdtable.end) {
+                while (vfd >= 0 && NULL == squash_global_fdtable.fds[vfd]) {
+                        vfd -= 1;
+                }
+                squash_global_fdtable.end = vfd + 1;
+        } else {
+                assert(squash_global_fdtable.end > vfd + 1);
+        }
+        MUTEX_UNLOCK(&squash_global_mutex);
+        return 0;
+}
+
+ssize_t squash_read(int vfd, void *buf, sqfs_off_t nbyte)
+{
+	sqfs_err error;
+	struct squash_file *file;
+
+	if (!SQUASH_VALID_VFD(vfd))
+	{
+		errno = EBADF;
+		goto failure;
+	}
+	file = squash_global_fdtable.fds[vfd];
+
+	error = sqfs_read_range(file->fs, &file->node, file->pos, &nbyte, buf);
+	if (SQFS_OK != error)
+	{
+		goto failure;
+	}
+	file->pos += nbyte;
+	return nbyte;
+failure:
+	if (!errno) {
+		errno = EBADF;
+	}
+	return -1;
+}
+
+off_t squash_lseek(int vfd, off_t offset, int whence)
+{
+	struct squash_file *file;
+	if (!SQUASH_VALID_VFD(vfd))
+	{
+		errno = EBADF;
+		return -1;
+	}
+	file = squash_global_fdtable.fds[vfd];
+	if (SQUASH_SEEK_SET == whence)
+	{
+		file->pos = offset;
+	}
+	else if (SQUASH_SEEK_CUR == whence)
+	{
+		file->pos += offset;
+	}
+	else if (SQUASH_SEEK_END == whence)
+	{
+		assert(S_ISREG(file->node.base.mode));
+		file->pos = file->node.xtra.reg.file_size;
+	}
+	return file->pos;
+}
+
+static void squash_halt()
+{
+	if (squash_global_fdtable.fds) {
+		free(squash_global_fdtable.fds);
+	}
+	MUTEX_DESTORY(&squash_global_mutex);
+	squash_extract_clear_cache();
+}
+
+sqfs_err squash_start()
+{
+	int ret;
+	squash_global_fdtable.nr = 0;
+	squash_global_fdtable.fds = NULL;
+	MUTEX_INIT(&squash_global_mutex);
+	ret = atexit(squash_halt);
+	if (0 == ret) {
+		return SQFS_OK;
+	} else {
+		return SQFS_ERR;
+	}
+}
+
+struct squash_file * squash_find_entry(void *ptr)
+{
+	size_t i;
+	struct squash_file * ret = NULL;
+	MUTEX_LOCK(&squash_global_mutex);
+	for (i = 0; i < squash_global_fdtable.end; ++i) {
+		if (squash_global_fdtable.fds[i] && ptr == squash_global_fdtable.fds[i]->payload) {
+			ret = squash_global_fdtable.fds[i];
+			break;
+		}
+	}
+	MUTEX_UNLOCK(&squash_global_mutex);
+	return ret;
+}
diff -ruN ruby-2.4.1/squash_file.c ruby/squash_file.c
--- ruby-2.4.1/squash_file.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_file.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,329 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/file.h"
+
+#include "squash/fs.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+sqfs_err sqfs_frag_entry(sqfs *fs, struct squashfs_fragment_entry *frag,
+		uint32_t idx) {
+	sqfs_err err = SQFS_OK;
+	
+	if (idx == SQUASHFS_INVALID_FRAG)
+		return SQFS_ERR;
+	
+	err = sqfs_table_get(&fs->frag_table, fs, idx, frag);
+	return err;
+}
+
+sqfs_err sqfs_frag_block(sqfs *fs, sqfs_inode *inode,
+		size_t *offset, size_t *size, sqfs_block **block) {
+	struct squashfs_fragment_entry frag;
+	sqfs_err err = SQFS_OK;
+	
+	if (!S_ISREG(inode->base.mode))
+		return SQFS_ERR;
+	
+	err = sqfs_frag_entry(fs, &frag, inode->xtra.reg.frag_idx);
+	if (err)
+		return err;
+	
+	err = sqfs_data_cache(fs, &fs->frag_cache, frag.start_block,
+		frag.size, block);
+	if (err)
+		return SQFS_ERR;
+	
+	*offset = inode->xtra.reg.frag_off;
+	*size = inode->xtra.reg.file_size % fs->sb->block_size;
+	return SQFS_OK;
+}
+
+size_t sqfs_blocklist_count(sqfs *fs, sqfs_inode *inode) {
+	uint64_t size = inode->xtra.reg.file_size;
+	size_t block = fs->sb->block_size;
+	if (inode->xtra.reg.frag_idx == SQUASHFS_INVALID_FRAG) {
+		return sqfs_divceil(size, block);
+	} else {
+		return (size_t)(size / block);
+	}
+}
+
+void sqfs_blocklist_init(sqfs *fs, sqfs_inode *inode, sqfs_blocklist *bl) {
+	bl->fs = fs;
+	bl->remain = sqfs_blocklist_count(fs, inode);
+	bl->cur = inode->next;
+	bl->started = 0;
+	bl->pos = 0;
+	bl->block = inode->xtra.reg.start_block;
+	bl->input_size = 0;
+}
+
+sqfs_err sqfs_blocklist_next(sqfs_blocklist *bl) {
+	sqfs_err err = SQFS_OK;
+	short compressed;
+	
+	if (bl->remain == 0)
+		return SQFS_ERR;
+	--(bl->remain);
+	
+	err = sqfs_md_read(bl->fs, &bl->cur, &bl->header,
+		sizeof(bl->header));
+	if (err)
+		return err;
+	
+	bl->block += bl->input_size;
+	sqfs_data_header(bl->header, &compressed, &bl->input_size);
+	
+	if (bl->started)
+		bl->pos += bl->fs->sb->block_size;
+	bl->started = 1;
+	
+	return SQFS_OK;
+}
+
+sqfs_err sqfs_read_range(sqfs *fs, sqfs_inode *inode, sqfs_off_t start,
+		sqfs_off_t *size, void *buf) {
+	sqfs_err err = SQFS_OK;
+	
+	sqfs_off_t file_size;
+	size_t block_size;
+	sqfs_blocklist bl;
+	
+	size_t read_off;
+	char *buf_orig;
+	
+	if (!S_ISREG(inode->base.mode))
+		return SQFS_ERR;
+	
+	file_size = inode->xtra.reg.file_size;
+	block_size = fs->sb->block_size;
+	
+	if (*size < 0 || start > file_size)
+		return SQFS_ERR;
+	if (start == file_size) {
+		*size = 0;
+		return SQFS_OK;
+	}
+	
+	err = sqfs_blockidx_blocklist(fs, inode, &bl, start);
+	if (err)
+		return err;
+	
+	read_off = start % block_size;
+	buf_orig = buf;
+	while (*size > 0) {
+		sqfs_block *block = NULL;
+		size_t data_off, data_size;
+		size_t take;
+		
+		short fragment = (bl.remain == 0);
+		if (fragment) { /* fragment */
+			if (inode->xtra.reg.frag_idx == SQUASHFS_INVALID_FRAG)
+				break;
+			err = sqfs_frag_block(fs, inode, &data_off, &data_size, &block);
+			if (err)
+				return err;
+		} else {			
+			if ((err = sqfs_blocklist_next(&bl)))
+				return err;
+			if (bl.pos + block_size <= start)
+				continue;
+			
+			data_off = 0;
+			if (bl.input_size == 0) { /* Hole! */
+				data_size = (size_t)(file_size - bl.pos);
+				if (data_size > block_size)
+					data_size = block_size;
+			} else {
+				err = sqfs_data_cache(fs, &fs->data_cache, bl.block,
+					bl.header, &block);
+				if (err)
+					return err;
+				data_size = block->size;
+			}
+		}
+		
+		take = data_size - read_off;
+		if (take > *size)
+			take = (size_t)(*size);
+		if (block) {
+			memcpy(buf, (char*)block->data + data_off + read_off, take);
+			/* BLOCK CACHED, DON'T DISPOSE */
+		} else {
+			memset(buf, 0, take);
+		}
+		read_off = 0;
+		*size -= take;
+		buf = (char*)buf + take;
+		
+		if (fragment)
+			break;
+	}
+	
+	*size = (char*)buf - buf_orig;
+	return *size ? SQFS_OK : SQFS_ERR;
+}
+
+
+/*
+To read block N of a M-block file, we have to read N blocksizes from the,
+metadata. This is a lot of work for large files! So for those files, we use
+an index to speed it up.
+
+The M blocksizes are split between M / SQUASHFS_METADATA_SIZE MD-blocks.
+For each of these blocks, we maintain in the index the location of the
+MD-block, and the location of the data block corresponding to the start
+of that MD-block.
+
+Then to read block N, we just calculate which metadata block index
+("metablock") we want, and get that block-index entry. Then we
+only need to read that one MD-block to seek within the file.
+*/
+
+/* Is a file worth indexing? */
+static short sqfs_blockidx_indexable(sqfs *fs, sqfs_inode *inode) {
+	size_t blocks = sqfs_blocklist_count(fs, inode);
+	size_t md_size = blocks * sizeof(sqfs_blocklist_entry);
+	return md_size >= SQUASHFS_METADATA_SIZE;
+}
+
+static void sqfs_blockidx_dispose(void *data) {
+	free(*(sqfs_blockidx_entry**)data);
+}
+
+sqfs_err sqfs_blockidx_init(sqfs_cache *cache) {
+	return sqfs_cache_init(cache, sizeof(sqfs_blockidx_entry**),
+		SQUASHFS_META_SLOTS, &sqfs_blockidx_dispose);
+}
+
+/* Fill *out with all the block-index entries for this file */
+static sqfs_err sqfs_blockidx_add(sqfs *fs, sqfs_inode *inode,
+		sqfs_blockidx_entry **out) {
+	size_t blocks;	/* Number of blocks in the file */
+	size_t md_size; /* Amount of metadata necessary to hold the blocksizes */
+	size_t count; 	/* Number of block-index entries necessary */
+	
+	sqfs_blockidx_entry *blockidx;
+	sqfs_blocklist bl;
+	
+	/* For the cache */
+	sqfs_cache_idx idx;
+	sqfs_blockidx_entry **cachep;
+
+	size_t i = 0;
+	short first = 1;
+	
+	*out = NULL;
+	
+	blocks = sqfs_blocklist_count(fs, inode);
+	md_size = blocks * sizeof(sqfs_blocklist_entry);
+	count = (inode->next.offset + md_size - 1)
+		/ SQUASHFS_METADATA_SIZE;
+	blockidx = malloc(count * sizeof(sqfs_blockidx_entry));
+	if (!blockidx)
+		return SQFS_ERR;
+	
+	sqfs_blocklist_init(fs, inode, &bl);
+	while (bl.remain && i < count) {
+		sqfs_err err = SQFS_OK;
+		/* If the MD cursor offset is small, we found a new MD-block.
+		 * Skip the first MD-block, because we already know where it is:
+		 * inode->next.offset */
+		if (bl.cur.offset < sizeof(sqfs_blocklist_entry) && !first) {
+			blockidx[i].data_block = bl.block + bl.input_size;
+			blockidx[i++].md_block = (uint32_t)(bl.cur.block - fs->sb->inode_table_start);
+		}
+		first = 0;
+		
+		err = sqfs_blocklist_next(&bl);
+		if (err) {
+			free(blockidx);
+			return SQFS_ERR;
+		}
+	}
+
+	idx = inode->base.inode_number + 1; /* zero means invalid */
+	cachep = sqfs_cache_add(&fs->blockidx, idx);
+	*out = *cachep = blockidx;
+	return SQFS_OK;
+}
+
+sqfs_err sqfs_blockidx_blocklist(sqfs *fs, sqfs_inode *inode, sqfs_blocklist *bl, sqfs_off_t start) {
+	size_t block, metablock, skipped;
+	sqfs_blockidx_entry *blockidx, **bp;
+	sqfs_cache_idx idx;
+	sqfs_err ret;
+
+	MUTEX_LOCK(&fs->blockidx.mutex);
+
+	sqfs_blocklist_init(fs, inode, bl);
+	block = (size_t)(start / fs->sb->block_size);
+	if (block > bl->remain) { /* fragment */
+		bl->remain = 0;
+		ret = SQFS_OK;
+		goto exit;
+	}
+	
+	/* How many MD-blocks do we want to skip? */
+	metablock = (bl->cur.offset + block * sizeof(sqfs_blocklist_entry))
+		/ SQUASHFS_METADATA_SIZE;
+	if (metablock == 0) {
+		ret = SQFS_OK; /* no skip needed, don't want an index */
+		goto exit;
+	}
+	if (!sqfs_blockidx_indexable(fs, inode)) {
+		ret = SQFS_OK; /* too small to index */
+		goto exit;
+	}
+	
+	/* Get the index, creating it if necessary */
+	idx = inode->base.inode_number + 1; /* zero means invalid index */
+	if ((bp = sqfs_cache_get(&fs->blockidx, idx))) {
+		blockidx = *bp;
+	} else {
+		ret = sqfs_blockidx_add(fs, inode, &blockidx);
+		if (ret) {
+			goto exit;
+		}
+	}
+	
+	skipped = (metablock * SQUASHFS_METADATA_SIZE / sizeof(sqfs_blocklist_entry))
+		- (bl->cur.offset / sizeof(sqfs_blocklist_entry));
+	
+	blockidx += metablock - 1;
+	bl->cur.block = blockidx->md_block + fs->sb->inode_table_start;
+	bl->cur.offset %= sizeof(sqfs_blocklist_entry);
+	bl->remain -= skipped;
+	bl->pos = (uint64_t)skipped * fs->sb->block_size;
+	bl->block = blockidx->data_block;
+	ret = SQFS_OK;
+
+exit:
+	MUTEX_UNLOCK(&fs->blockidx.mutex);
+	return ret;
+}
+
diff -ruN ruby-2.4.1/squash_fs.c ruby/squash_fs.c
--- ruby-2.4.1/squash_fs.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_fs.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/fs.h"
+
+#include "squash/file.h"
+
+
+#include <stdlib.h>
+#include <string.h>
+
+
+
+#define DATA_CACHED_BLKS 1
+#define FRAG_CACHED_BLKS 3
+
+void sqfs_version_supported(int *min_major, int *min_minor, int *max_major,
+		int *max_minor) {
+	*min_major = *max_major = SQUASHFS_MAJOR;
+	*min_minor = 0;
+	*max_minor = SQUASHFS_MINOR;
+}
+
+void sqfs_version(sqfs *fs, int *major, int *minor) {
+	*major = fs->sb->s_major;
+	*minor = fs->sb->s_minor;
+}
+
+sqfs_compression_type sqfs_compression(sqfs *fs) {
+	return fs->sb->compression;
+}
+
+sqfs_err sqfs_init(sqfs *fs, sqfs_fd_t fd, size_t offset) {
+	sqfs_err err;
+	memset(fs, 0, sizeof(*fs));
+	
+	fs->fd = fd;
+	fs->offset = offset;
+
+	fs->sb = (struct squashfs_super_block *)(fd + fs->offset);
+	
+	if (fs->sb->s_magic != SQUASHFS_MAGIC) {
+		return SQFS_BADFORMAT;
+	}
+	if (fs->sb->s_major != SQUASHFS_MAJOR || fs->sb->s_minor > SQUASHFS_MINOR)
+		return SQFS_BADVERSION;
+	
+	if (!(fs->decompressor = sqfs_decompressor_get(fs->sb->compression)))
+		return SQFS_BADCOMP;
+	
+	err = sqfs_table_init(&fs->id_table, fd, fs->sb->id_table_start + fs->offset,
+		sizeof(uint32_t), fs->sb->no_ids);
+	err |= sqfs_table_init(&fs->frag_table, fd, fs->sb->fragment_table_start + fs->offset,
+		sizeof(struct squashfs_fragment_entry), fs->sb->fragments);
+	if (sqfs_export_ok(fs)) {
+		err |= sqfs_table_init(&fs->export_table, fd, fs->sb->lookup_table_start + fs->offset,
+			sizeof(uint64_t), fs->sb->inodes);
+	}
+	err |= sqfs_block_cache_init(&fs->md_cache, SQUASHFS_CACHED_BLKS);
+	err |= sqfs_block_cache_init(&fs->data_cache, DATA_CACHED_BLKS);
+	err |= sqfs_block_cache_init(&fs->frag_cache, FRAG_CACHED_BLKS);
+	err |= sqfs_blockidx_init(&fs->blockidx);
+	if (err) {
+		sqfs_destroy(fs);
+		return SQFS_ERR;
+	}
+	
+	return SQFS_OK;
+}
+
+void sqfs_destroy(sqfs *fs) {
+	sqfs_table_destroy(&fs->id_table);
+	sqfs_table_destroy(&fs->frag_table);
+	if (sqfs_export_ok(fs))
+		sqfs_table_destroy(&fs->export_table);
+	sqfs_cache_destroy(&fs->md_cache);
+	sqfs_cache_destroy(&fs->data_cache);
+	sqfs_cache_destroy(&fs->frag_cache);
+	sqfs_cache_destroy(&fs->blockidx);
+}
+
+void sqfs_md_header(uint16_t hdr, short *compressed, uint16_t *size) {
+	*compressed = !(hdr & SQUASHFS_COMPRESSED_BIT);
+	*size = hdr & ~SQUASHFS_COMPRESSED_BIT;
+	if (!*size)
+		*size = SQUASHFS_COMPRESSED_BIT;
+}
+
+void sqfs_data_header(uint32_t hdr, short *compressed, uint32_t *size) {
+	*compressed = !(hdr & SQUASHFS_COMPRESSED_BIT_BLOCK);
+	*size = hdr & ~SQUASHFS_COMPRESSED_BIT_BLOCK;
+}
+
+sqfs_err sqfs_block_read(sqfs *fs, sqfs_off_t pos, short compressed,
+		uint32_t size, size_t outsize, sqfs_block **block) {
+	sqfs_err err = SQFS_ERR;
+	if (!(*block = malloc(sizeof(**block))))
+		return SQFS_ERR;
+	
+	(*block)->data = (void *)((fs->fd) + (pos + fs->offset));
+	(*block)->data_need_freeing = 0;
+
+	if (compressed) {
+		char *decomp = malloc(outsize);
+		if (!decomp)
+			goto error;
+		
+		err = fs->decompressor((*block)->data, size, decomp, &outsize);
+		if (err) {
+			free(decomp);
+			goto error;
+		}
+		(*block)->data = decomp;
+		(*block)->size = outsize;
+		(*block)->data_need_freeing = 1;
+	} else {
+		(*block)->size = size;
+	}
+
+	return SQFS_OK;
+
+error:
+	sqfs_block_dispose(*block);
+	*block = NULL;
+	return err;
+}
+
+sqfs_err sqfs_md_block_read(sqfs *fs, sqfs_off_t pos, size_t *data_size,
+		sqfs_block **block) {
+	sqfs_err err;
+	uint16_t hdr;
+	short compressed;
+	uint16_t size;
+	
+	*data_size = 0;
+	
+	hdr = *(uint16_t *)(fs->fd + pos + fs->offset);
+	pos += sizeof(hdr);
+	*data_size += sizeof(hdr);
+	
+	sqfs_md_header(hdr, &compressed, &size);
+	
+	err = sqfs_block_read(fs, pos, compressed, size,
+		SQUASHFS_METADATA_SIZE, block);
+	*data_size += size;
+	return err;
+}
+
+sqfs_err sqfs_data_block_read(sqfs *fs, sqfs_off_t pos, uint32_t hdr,
+		sqfs_block **block) {
+	short compressed;
+	uint32_t size;
+	sqfs_data_header(hdr, &compressed, &size);
+	return sqfs_block_read(fs, pos, compressed, size,
+		fs->sb->block_size, block);
+}
+
+sqfs_err sqfs_md_cache(sqfs *fs, sqfs_off_t *pos, sqfs_block **block) {
+	sqfs_block_cache_entry *entry;
+	sqfs_err ret;
+	MUTEX_LOCK(&fs->md_cache.mutex);
+
+	entry = sqfs_cache_get(&fs->md_cache, *pos);
+	if (!entry) {
+		entry = sqfs_cache_add(&fs->md_cache, *pos);
+		ret = sqfs_md_block_read(fs, *pos, &entry->data_size, &entry->block);
+		if (ret) {
+			goto exit;
+		}
+	}
+	*block = entry->block;
+	*pos += entry->data_size;
+	ret = SQFS_OK;
+exit:
+	MUTEX_UNLOCK(&fs->md_cache.mutex);
+	return ret;
+}
+
+sqfs_err sqfs_data_cache(sqfs *fs, sqfs_cache *cache, sqfs_off_t pos,
+		uint32_t hdr, sqfs_block **block) {
+	sqfs_block_cache_entry *entry;
+	sqfs_err ret;
+	MUTEX_LOCK(&cache->mutex);
+
+	entry = sqfs_cache_get(cache, pos);
+	if (!entry) {
+		entry = sqfs_cache_add(cache, pos);
+		ret = sqfs_data_block_read(fs, pos, hdr, &entry->block);
+		if (ret) {
+			goto exit;
+		}
+	}
+	*block = entry->block;
+	ret = SQFS_OK;
+exit:
+	MUTEX_UNLOCK(&cache->mutex);
+	return ret;
+}
+
+void sqfs_block_dispose(sqfs_block *block) {
+	if (block->data_need_freeing) {
+		free(block->data);
+	}
+	free(block);
+}
+
+void sqfs_md_cursor_inode(sqfs_md_cursor *cur, sqfs_inode_id id, sqfs_off_t base) {
+	cur->block = (id >> 16) + base;
+	cur->offset = id & 0xffff;
+}
+
+sqfs_err sqfs_md_read(sqfs *fs, sqfs_md_cursor *cur, void *buf, size_t size) {
+	sqfs_off_t pos = cur->block;
+	while (size > 0) {
+		sqfs_block *block;
+		size_t take;
+		sqfs_err err = sqfs_md_cache(fs, &pos, &block);
+		if (err)
+			return err;
+		
+		take = block->size - cur->offset;
+		if (take > size)
+			take = size;
+		if (buf)
+			memcpy(buf, (char*)block->data + cur->offset, take);
+		/* BLOCK CACHED, DON'T DISPOSE */
+		
+		if (buf)
+			buf = (char*)buf + take;
+		size -= take;
+		cur->offset += take;
+		if (cur->offset == block->size) {
+			cur->block = pos;
+			cur->offset = 0;
+		}
+	}
+	return SQFS_OK;
+}
+
+size_t sqfs_divceil(uint64_t total, size_t group) {
+	size_t q = (size_t)(total / group);
+	if (total % group)
+		q += 1;
+	return q;
+}
+
+sqfs_err sqfs_id_get(sqfs *fs, uint16_t idx, sqfs_id_t *id) {
+	uint32_t rid;
+	sqfs_err err = sqfs_table_get(&fs->id_table, fs, idx, &rid);
+	if (err)
+		return err;
+	*id = (sqfs_id_t)rid;
+	return SQFS_OK;
+}
+
+sqfs_err sqfs_readlink(sqfs *fs, sqfs_inode *inode, char *buf, size_t *size) {
+	size_t want;
+	sqfs_md_cursor cur;
+	sqfs_err err;
+	if (!S_ISLNK(inode->base.mode))
+		return SQFS_ERR;
+
+	want = inode->xtra.symlink_size;
+	if (!buf) {
+		*size = want + 1;
+		return SQFS_OK;
+	}
+
+	if (want > *size - 1)
+		want = *size - 1;
+	cur = inode->next;
+	err = sqfs_md_read(fs, &cur, buf, want);
+	buf[want] = '\0';
+	return err;
+}
+
+int sqfs_export_ok(sqfs *fs) {
+	return fs->sb->lookup_table_start != SQUASHFS_INVALID_BLK;
+}
+
+sqfs_err sqfs_export_inode(sqfs *fs, sqfs_inode_num n, sqfs_inode_id *i) {
+	uint64_t r;
+	sqfs_err err;
+	
+	if (!sqfs_export_ok(fs))
+		return SQFS_UNSUP;
+	
+	err = sqfs_table_get(&fs->export_table, fs, n - 1, &r);
+	if (err)
+		return err;
+	*i = r;
+	return SQFS_OK;
+}
+
+sqfs_inode_id sqfs_inode_root(sqfs *fs) {
+	return fs->sb->root_inode;
+}
+
+/* Turn the internal format of a device number to our system's dev_t
+ * It looks like rdev is just what the Linux kernel uses: 20 bit minor,
+ * split in two around a 12 bit major
+ */
+static void sqfs_decode_dev(sqfs_inode *i, uint32_t rdev) {
+	i->xtra.dev.major = (rdev >> 8) & 0xfff;
+	i->xtra.dev.minor = (rdev & 0xff) | ((rdev >> 12) & 0xfff00);
+}
+
+#define INODE_TYPE(_type) \
+	struct squashfs_##_type##_inode x; \
+	err = sqfs_md_read(fs, &inode->next, &x, sizeof(x)); \
+	if (err) return err
+
+sqfs_err sqfs_inode_get(sqfs *fs, sqfs_inode *inode, sqfs_inode_id id) {
+	sqfs_md_cursor cur;
+	sqfs_err err;
+	
+	memset(inode, 0, sizeof(*inode));
+	
+	sqfs_md_cursor_inode(&cur, id, fs->sb->inode_table_start);
+	inode->next = cur;
+	
+	err = sqfs_md_read(fs, &cur, &inode->base, sizeof(inode->base));
+	if (err)
+		return err;
+	
+	inode->base.mode |= sqfs_mode(inode->base.inode_type);
+	switch (inode->base.inode_type) {
+		case SQUASHFS_REG_TYPE: {
+			INODE_TYPE(reg);
+			inode->nlink = 1;
+			inode->xtra.reg.start_block = x.start_block;
+			inode->xtra.reg.file_size = x.file_size;
+			inode->xtra.reg.frag_idx = x.fragment;
+			inode->xtra.reg.frag_off = x.offset;
+			break;
+		}
+		case SQUASHFS_LREG_TYPE: {
+			INODE_TYPE(lreg);
+			inode->nlink = x.nlink;
+			inode->xtra.reg.start_block = x.start_block;
+			inode->xtra.reg.file_size = x.file_size;
+			inode->xtra.reg.frag_idx = x.fragment;
+			inode->xtra.reg.frag_off = x.offset;
+			break;
+		}
+		case SQUASHFS_DIR_TYPE: {
+			INODE_TYPE(dir);
+			inode->nlink = x.nlink;
+			inode->xtra.dir.start_block = x.start_block;
+			inode->xtra.dir.offset = x.offset;
+			inode->xtra.dir.dir_size = x.file_size;
+			inode->xtra.dir.idx_count = 0;
+			inode->xtra.dir.parent_inode = x.parent_inode;
+			break;
+		}
+		case SQUASHFS_LDIR_TYPE: {
+			INODE_TYPE(ldir);
+			inode->nlink = x.nlink;
+			inode->xtra.dir.start_block = x.start_block;
+			inode->xtra.dir.offset = x.offset;
+			inode->xtra.dir.dir_size = x.file_size;
+			inode->xtra.dir.idx_count = x.i_count;
+			inode->xtra.dir.parent_inode = x.parent_inode;
+			break;
+		}
+		case SQUASHFS_SYMLINK_TYPE:
+		case SQUASHFS_LSYMLINK_TYPE: {
+			INODE_TYPE(symlink);
+			inode->nlink = x.nlink;
+			inode->xtra.symlink_size = x.symlink_size;
+			
+			if (inode->base.inode_type == SQUASHFS_LSYMLINK_TYPE) {
+				/* skip symlink target */
+				cur = inode->next;
+				err = sqfs_md_read(fs, &cur, NULL, inode->xtra.symlink_size);
+				if (err)
+					return err;
+			}
+			break;
+		}
+		case SQUASHFS_BLKDEV_TYPE:
+		case SQUASHFS_CHRDEV_TYPE: {
+			INODE_TYPE(dev);
+			inode->nlink = x.nlink;
+			sqfs_decode_dev(inode, x.rdev);
+			break;
+		}
+		case SQUASHFS_LBLKDEV_TYPE:
+		case SQUASHFS_LCHRDEV_TYPE: {
+			INODE_TYPE(ldev);
+			inode->nlink = x.nlink;
+			sqfs_decode_dev(inode, x.rdev);
+			break;
+		}
+		case SQUASHFS_SOCKET_TYPE:
+		case SQUASHFS_FIFO_TYPE: {
+			INODE_TYPE(ipc);
+			inode->nlink = x.nlink;
+			break;
+		}
+		case SQUASHFS_LSOCKET_TYPE:
+		case SQUASHFS_LFIFO_TYPE: {
+			INODE_TYPE(lipc);
+			inode->nlink = x.nlink;
+			break;
+		}
+		
+		default: return SQFS_ERR;
+	}
+	
+	return SQFS_OK;
+}
+#undef INODE_TYPE
diff -ruN ruby-2.4.1/squash_hash.c ruby/squash_hash.c
--- ruby-2.4.1/squash_hash.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_hash.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/hash.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+static sqfs_err sqfs_hash_add_internal(sqfs_hash *h, int doubling,
+		sqfs_hash_key k, sqfs_hash_value v) {
+	size_t hash = (k & (h->capacity - 1));	
+	sqfs_hash_bucket *b = malloc(sizeof(sqfs_hash_bucket) + h->value_size);
+	if (!b)
+		return SQFS_ERR;
+	b->key = k;
+	memcpy(&b->value, v, h->value_size);
+	b->next = h->buckets[hash];
+	h->buckets[hash] = b;
+	++h->size;
+	
+	return SQFS_OK;
+}
+
+static sqfs_err sqfs_hash_double(sqfs_hash *h) {
+	sqfs_hash_bucket **ob = h->buckets;
+	size_t oc = h->capacity;
+	size_t i;
+	sqfs_err err;
+	
+	if ((err = sqfs_hash_init(h, h->value_size, oc * 2)))
+		return err;
+	
+	for (i = 0; i < oc; ++i) {
+		sqfs_hash_bucket *b = ob[i];
+		while (b) {
+			sqfs_hash_bucket *n;
+			if (!err)
+				err = sqfs_hash_add_internal(h, 1, b->key, &b->value);
+			n = b->next;
+			free(b);
+			b = n;
+		}
+	}
+	
+	free(ob);
+	return err;
+}
+
+sqfs_err sqfs_hash_init(sqfs_hash *h, size_t vsize, size_t initial) {
+	memset(h, 0, sizeof(*h));
+	if ((initial & (initial - 1))) /* not power of two? */
+		return SQFS_ERR;
+	
+	h->buckets = calloc(initial, sizeof(sqfs_hash_bucket*));
+	if (!h->buckets)
+		return SQFS_ERR;
+	h->capacity = initial;
+	h->size = 0;
+	h->value_size = vsize;
+	return SQFS_OK;
+}
+ 
+void sqfs_hash_destroy(sqfs_hash *h) {
+	size_t i;
+	for (i = 0; i < h->capacity; ++i) {
+		sqfs_hash_bucket *b = h->buckets[i];
+		while (b) {
+			sqfs_hash_bucket *n = b->next;
+			free(b);
+			b = n;
+		}
+	}
+	free(h->buckets);
+}
+
+sqfs_hash_value sqfs_hash_get(sqfs_hash *h, sqfs_hash_key k) {
+	size_t hash = (k & (h->capacity - 1));
+	sqfs_hash_bucket *b = h->buckets[hash];
+	while (b) {
+		if (b->key == k)
+			return &b->value;
+		b = b->next;
+	}
+	return NULL;
+}
+
+sqfs_err sqfs_hash_add(sqfs_hash *h, sqfs_hash_key k, sqfs_hash_value v) {
+	if (h->size >= h->capacity) {
+		sqfs_err err = sqfs_hash_double(h);
+		if (err)
+			return err;
+	}
+	return sqfs_hash_add_internal(h, 0, k, v);
+}
+
+sqfs_err sqfs_hash_remove(sqfs_hash *h, sqfs_hash_key k) {
+	size_t hash = (k & (h->capacity - 1));
+	sqfs_hash_bucket **bp = &h->buckets[hash];
+	while (*bp) {
+		if ((*bp)->key == k) {
+			sqfs_hash_bucket *b = *bp;
+			*bp = b->next;
+			free(b);
+			--h->size;
+			return SQFS_OK;
+		}
+		bp = &(*bp)->next;
+	}
+	return SQFS_OK;
+}
diff -ruN ruby-2.4.1/squash_mutex.c ruby/squash_mutex.c
--- ruby-2.4.1/squash_mutex.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_mutex.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "squash/mutex.h"
+
+
+int MUTEX_INIT(MUTEX *mutex)
+{
+
+#ifdef _WIN32
+    *mutex = CreateMutex(0, FALSE, 0);
+    return (*mutex==0);
+#else
+    return pthread_mutex_init(mutex, NULL);
+#endif
+
+}
+
+int MUTEX_LOCK(MUTEX *mutex)
+{
+#ifdef _WIN32
+    return (WaitForSingleObject(*mutex, INFINITE)==WAIT_FAILED?1:0);
+#else
+    return pthread_mutex_lock(mutex);
+#endif
+}
+
+int MUTEX_UNLOCK(MUTEX *mutex)
+{
+#ifdef _WIN32
+    return (ReleaseMutex(*mutex)==0);
+#else
+    return pthread_mutex_unlock(mutex);
+#endif
+}
+
+int MUTEX_DESTORY(MUTEX *mutex)
+{
+#ifdef _WIN32
+    return CloseHandle(*mutex);
+#else
+    return pthread_mutex_destroy(mutex);
+#endif
+}
diff -ruN ruby-2.4.1/squash_nonstd-makedev.c ruby/squash_nonstd-makedev.c
--- ruby-2.4.1/squash_nonstd-makedev.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_nonstd-makedev.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+#ifdef __linux__
+	#include <sys/sysmacros.h>
+#endif
+
+#include "squash/common.h"
+
+dev_t sqfs_makedev(int maj, int min) {
+	return makedev(maj, min);
+}
diff -ruN ruby-2.4.1/squash_nonstd-stat.c ruby/squash_nonstd-stat.c
--- ruby-2.4.1/squash_nonstd-stat.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_nonstd-stat.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/stat.h>
+
+#include "squash/common.h"
+#include "squash/squashfs_fs.h"
+
+/* S_IF* are not standard */
+sqfs_mode_t sqfs_mode(int inode_type) {
+	switch (inode_type) {
+		case SQUASHFS_DIR_TYPE:
+		case SQUASHFS_LDIR_TYPE:
+			return S_IFDIR;
+		case SQUASHFS_REG_TYPE:
+		case SQUASHFS_LREG_TYPE:
+			return S_IFREG;
+		case SQUASHFS_SYMLINK_TYPE:
+		case SQUASHFS_LSYMLINK_TYPE:
+			return S_IFLNK;
+		case SQUASHFS_BLKDEV_TYPE:
+		case SQUASHFS_LBLKDEV_TYPE:
+			return S_IFBLK;
+		case SQUASHFS_CHRDEV_TYPE:
+		case SQUASHFS_LCHRDEV_TYPE:
+			return S_IFCHR;
+		case SQUASHFS_FIFO_TYPE:
+		case SQUASHFS_LFIFO_TYPE:
+			return S_IFIFO;
+		case SQUASHFS_SOCKET_TYPE:
+		case SQUASHFS_LSOCKET_TYPE:
+			return S_IFSOCK;
+	}
+	return 0;
+}
+
diff -ruN ruby-2.4.1/squash_private.c ruby/squash_private.c
--- ruby-2.4.1/squash_private.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_private.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/private.h"
+
+
+#include "squash/nonstd.h"
+
+sqfs_err sqfs_stat(sqfs *fs, sqfs_inode *inode, struct stat *st) {
+	memset(st, 0, sizeof(*st));
+	st->st_mode = inode->base.mode;
+	st->st_nlink = inode->nlink;
+	st->st_mtime = st->st_ctime = st->st_atime = inode->base.mtime;
+	
+	if (S_ISREG(st->st_mode)) {
+		/* FIXME: do symlinks, dirs, etc have a size? */
+		st->st_size = inode->xtra.reg.file_size;
+	} else if (S_ISBLK(st->st_mode) || S_ISCHR(st->st_mode)) {
+		st->st_rdev = sqfs_makedev(inode->xtra.dev.major,
+			inode->xtra.dev.minor);
+	} else if (S_ISLNK(st->st_mode)) {
+		st->st_size = inode->xtra.symlink_size;
+	}
+	
+	return SQFS_OK;
+}
diff -ruN ruby-2.4.1/squash_readlink.c ruby/squash_readlink.c
--- ruby-2.4.1/squash_readlink.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_readlink.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "squash.h"
+
+ssize_t squash_readlink_inode(sqfs *fs, sqfs_inode *node, char *buf, size_t bufsize) {
+        sqfs_err error;
+        size_t want = 0;
+        sqfs_md_cursor cur;
+
+        if (!S_ISLNK(node->base.mode)) {
+                errno = EINVAL;
+                return -1;
+        }
+
+        want = node->xtra.symlink_size;
+
+        if (want > bufsize - 1) {
+                errno = ENAMETOOLONG;
+                return -1; //bufsize is too small
+        }
+        else if (want == 0) {
+                errno = EBADF;
+                return -1;
+        }
+        cur = node->next;
+        error = sqfs_md_read(fs, &cur, buf, want);
+        if (SQFS_OK != error) {
+                errno = EIO;
+                return -1;
+        }
+        buf[want] = '\0';
+        if (fs->root_alias &&
+            strlen(buf) >= strlen(fs->root_alias) &&
+            buf == strstr(buf, fs->root_alias)) {
+                char *buf_ptr = buf + strlen(fs->root_alias) - 1;
+                assert('/' == buf_ptr[0]); // still is Absolute Path
+                memmove(buf, buf_ptr, strlen(buf_ptr) + 1);
+                want = strlen(buf);
+        } else if (fs->root_alias2 &&
+            strlen(buf) >= strlen(fs->root_alias2) &&
+            buf == strstr(buf, fs->root_alias2)) {
+                char *buf_ptr = buf + strlen(fs->root_alias2) - 1;
+                assert('/' == buf_ptr[0]); // still is Absolute Path
+                memmove(buf, buf_ptr, strlen(buf_ptr) + 1);
+                want = strlen(buf);
+        }
+        return want;
+}
+
+ssize_t squash_readlink(sqfs *fs, const char *path, char *buf, size_t bufsize) {
+    sqfs_err error;
+    sqfs_inode node;
+    short found;
+
+    assert(buf && path && fs);
+    memset(&node, 0, sizeof(sqfs_inode));
+
+    found = 0;
+
+    error = sqfs_inode_get(fs, &node, sqfs_inode_root(fs));
+    if (SQFS_OK != error)
+    	goto failure;
+    error = sqfs_lookup_path(fs, &node, path, &found);
+    if (SQFS_OK != error)
+    	goto failure;
+
+    if (found) {
+        return squash_readlink_inode(fs, &node, buf, bufsize);
+    } else {
+        errno = ENOENT;
+	goto failure;
+    }
+
+failure:
+	if (!errno) {
+		errno = ENOENT;
+	}
+	return -1;
+}
diff -ruN ruby-2.4.1/squash_scandir.c ruby/squash_scandir.c
--- ruby-2.4.1/squash_scandir.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_scandir.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "squash.h"
+#include <stdlib.h>
+
+
+typedef int(*qsort_compar)(const void *, const void *);
+
+int squash_scandir(sqfs *fs, const char *dirname, struct SQUASH_DIRENT ***namelist,
+	int (*select)(const struct SQUASH_DIRENT *),
+	int (*compar)(const struct SQUASH_DIRENT **, const struct SQUASH_DIRENT **))
+{
+	SQUASH_DIR * openeddir = 0;
+	size_t n = 0;
+	struct SQUASH_DIRENT **list = NULL;
+	struct SQUASH_DIRENT *ent = 0 ,*p = 0;
+
+	if((dirname == NULL) || (namelist == NULL))
+		return -1;
+
+	openeddir = squash_opendir(fs, dirname);
+	if(openeddir == NULL)
+		return -1;
+
+
+	list = (struct SQUASH_DIRENT **)malloc(MAX_DIR_ENT*sizeof(struct SQUASH_DIRENT *));
+
+
+	while(( ent = squash_readdir(openeddir)) != NULL)
+	{
+		if( select && !select(ent))
+			continue;
+
+		p = (struct SQUASH_DIRENT *)malloc(sizeof(struct SQUASH_DIRENT));
+
+		memcpy((void *)p,(void *)ent,sizeof(struct SQUASH_DIRENT));
+		list[n] = p;
+
+		n++;
+		if(n >= MAX_DIR_ENT)
+			break;
+
+	}
+
+	//close the squash_dir
+	squash_closedir(openeddir);
+
+	//realloc the array
+	*namelist = realloc((void *)list,n*sizeof(struct SQUASH_DIRENT *));
+	if(*namelist == NULL)
+		*namelist = list;
+
+
+	//sort the array
+	if(compar)
+		qsort((void *)*namelist,n,sizeof(struct SQUASH_DIRENT *),(qsort_compar)compar);
+
+	return n;
+
+}
\ No newline at end of file
diff -ruN ruby-2.4.1/squash_stack.c ruby/squash_stack.c
--- ruby-2.4.1/squash_stack.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_stack.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/stack.h"
+
+#include <stdlib.h>
+
+/* Ensure a capacity of cap */
+static sqfs_err sqfs_stack_capacity(sqfs_stack *s, size_t cap) {
+	char *items;
+	if (cap <= s->capacity)
+		return SQFS_OK;
+	
+	items = realloc(s->items, cap * s->value_size);
+	if (!items)
+		return SQFS_ERR;
+	
+	s->items = items;
+	s->capacity = cap;
+	return SQFS_OK;
+}
+
+/* Calculate the next capacity to use */
+#define CAPACITY_DEFAULT 8
+#define CAPACITY_RATIO 3 / 2
+static size_t sqfs_stack_next_capacity(size_t cap) {
+	size_t n;
+	
+	if (cap == 0)
+		return CAPACITY_DEFAULT;
+	
+	n = cap * CAPACITY_RATIO;
+	if (n <= cap)
+		return cap + 1;
+	return n;
+}
+
+/* Grow by one */
+static sqfs_err sqfs_stack_grow(sqfs_stack *s) {
+	if (s->size == s->capacity) {
+		sqfs_err err = sqfs_stack_capacity(s,
+			sqfs_stack_next_capacity(s->capacity));
+		if (err)
+			return err;
+	}
+	s->size++;
+	return SQFS_OK;
+}
+
+
+sqfs_err sqfs_stack_create(sqfs_stack *s, size_t vsize, size_t initial,
+		sqfs_stack_free_t freer) {
+	s->value_size = vsize;
+	s->freer = freer;
+	s->items = NULL;
+	s->capacity = s->size = 0;
+	return sqfs_stack_capacity(s, initial);
+}
+
+void sqfs_stack_init(sqfs_stack *s) {
+	s->items = NULL;
+	s->capacity = 0;
+}
+
+void sqfs_stack_destroy(sqfs_stack *s) {
+	while (sqfs_stack_pop(s))
+		; /* pass */
+	free(s->items);
+	sqfs_stack_init(s);
+}
+
+sqfs_err sqfs_stack_push(sqfs_stack *s, void *vout) {
+	sqfs_err err = sqfs_stack_grow(s);
+	if (err)
+		return err;
+	return sqfs_stack_top(s, vout);
+}
+
+short sqfs_stack_pop(sqfs_stack *s) {
+	void *v;
+	
+	if (s->size == 0)
+		return 0;
+	
+	sqfs_stack_top(s, &v);
+	if (s->freer)
+		s->freer(v);
+	s->size--;
+	return 1;
+}
+
+size_t sqfs_stack_size(sqfs_stack *s) {
+	return s->size;
+}
+
+sqfs_err sqfs_stack_at(sqfs_stack *s, size_t i, void *vout) {
+	if (i >= s->size)
+		return SQFS_ERR;
+	
+	*(void**)vout = s->items + i * s->value_size;
+	return SQFS_OK;
+}
+
+sqfs_err sqfs_stack_top(sqfs_stack *s, void *vout) {
+	if (s->size == 0)
+		return SQFS_ERR;
+	
+	return sqfs_stack_at(s, s->size - 1, vout);
+}
diff -ruN ruby-2.4.1/squash_stat.c ruby/squash_stat.c
--- ruby-2.4.1/squash_stat.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_stat.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2017 Minqi Pan <pmq2001@gmail.com>
+ *                    Shengyuan Liu <sounder.liu@gmail.com>
+ *
+ * This file is part of libsquash, distributed under the MIT License
+ * For full terms see the included LICENSE file
+ */
+
+#include "squash.h"
+
+int squash_stat(sqfs *fs, const char *path, struct stat *buf)
+{
+	sqfs_err error;
+	sqfs_inode node;
+	short found;
+	
+	error = sqfs_inode_get(fs, &node, sqfs_inode_root(fs));
+	if (SQFS_OK != error) {
+		goto failure;
+	}
+	error = sqfs_lookup_path_inner(fs, &node, path, &found, 1);
+	if (SQFS_OK != error) {
+		goto failure;
+	}
+	if (!found) {
+		errno = ENOENT;
+		goto failure;
+	}
+	error = sqfs_stat(fs, &node, buf);
+	if (SQFS_OK != error) {
+		goto failure;
+	}
+
+	return 0;
+failure:
+	if (!errno) {
+		errno = ENOENT;
+	}
+	return -1;
+}
+
+int squash_lstat(sqfs *fs, const char *path, struct stat *buf)
+{
+	sqfs_err error;
+	sqfs_inode node;
+	short found;
+
+	error = sqfs_inode_get(fs, &node, sqfs_inode_root(fs));
+	if (SQFS_OK != error) {
+		goto failure;
+	}
+	error = sqfs_lookup_path(fs, &node, path, &found);
+	if (SQFS_OK != error) {
+		goto failure;
+	}
+	if (!found) {
+		errno = ENOENT;
+		goto failure;
+	}
+	error = sqfs_stat(fs, &node, buf);
+	if (SQFS_OK != error) {
+		goto failure;
+	}
+
+	return 0;
+failure:
+	if (!errno) {
+		errno = ENOENT;
+	}
+	return -1;
+}
+
+int squash_fstat(int vfd, struct stat *buf)
+{
+	if (!SQUASH_VALID_VFD(vfd))
+	{
+		errno = EBADF;
+		return -1;
+	}
+	*buf = SQUASH_VFD_FILE(vfd)->st;
+	return 0;
+}
diff -ruN ruby-2.4.1/squash_table.c ruby/squash_table.c
--- ruby-2.4.1/squash_table.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_table.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2012 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/table.h"
+
+#include "squash/fs.h"
+
+#include <string.h>
+
+sqfs_err sqfs_table_init(sqfs_table *table, sqfs_fd_t fd, sqfs_off_t start, size_t each,
+		size_t count) {
+	//size_t nblocks, bread;
+	
+	if (count == 0)
+		return SQFS_OK;
+	
+	//nblocks = sqfs_divceil(each * count, SQUASHFS_METADATA_SIZE);
+
+	//unused
+	//bread = nblocks * sizeof(uint64_t);
+
+	table->each = each;
+	table->blocks = (uint64_t *)(fd + start);
+	
+	return SQFS_OK;
+}
+
+void sqfs_table_destroy(sqfs_table *table) {
+	table->blocks = NULL;
+}
+
+sqfs_err sqfs_table_get(sqfs_table *table, sqfs *fs, size_t idx, void *buf) {
+	sqfs_block *block;
+	size_t pos = idx * table->each;
+	size_t bnum = pos / SQUASHFS_METADATA_SIZE,
+		off = pos % SQUASHFS_METADATA_SIZE;
+	
+	sqfs_off_t bpos = table->blocks[bnum];
+	if (sqfs_md_cache(fs, &bpos, &block))
+		return SQFS_ERR;
+	
+	memcpy(buf, (char*)(block->data) + off, table->each);
+	/* BLOCK CACHED, DON'T DISPOSE */
+	return SQFS_OK;
+}
diff -ruN ruby-2.4.1/squash_traverse.c ruby/squash_traverse.c
--- ruby-2.4.1/squash_traverse.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_traverse.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,322 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/traverse.h"
+
+#include "squash/fs.h"
+
+#include <stdlib.h>
+#include <string.h>
+
+
+#define TRAVERSE_PATH_SEPARATOR "/"
+
+/* Default initial capacity of trv.path */
+#define TRAVERSE_DEFAULT_PATH_CAP 32
+
+
+enum {
+	/* These states may be set on entry to sqfs_traverse_next(), with real
+	   work to do. */
+	TRAVERSE_DESCEND,		 	/* Descend into the current entry (a dir) */
+	TRAVERSE_NAME_REMOVE, /* Remove the name from the end of the stored path */
+	
+	/* End states */
+	TRAVERSE_ERROR,
+	TRAVERSE_FINISHED,
+	
+	/* Internal */
+	TRAVERSE_ASCEND,			/* Done with a directory, ascend a level */
+	TRAVERSE_NAME_ADD,		/* Add a name to the end of the stored path */
+	TRAVERSE_GET_ENTRY		/* Get the next entry at the same level */
+} sqfs_traverse_state;
+
+/* The struct stored in trv.stack */
+typedef struct {
+	sqfs_dir dir;
+	size_t name_size;
+} sqfs_traverse_level;
+
+
+/* Make our structure safe */
+static void sqfs_traverse_init(sqfs_traverse *trv);
+
+/* Path manipulation functions */
+static sqfs_err sqfs_traverse_path_init(sqfs_traverse *trv);
+static sqfs_err sqfs_traverse_path_add(sqfs_traverse *trv,
+	const char *str, size_t size);
+static sqfs_err sqfs_traverse_path_add_name(sqfs_traverse *trv);
+static sqfs_err sqfs_traverse_path_add_sep(sqfs_traverse *trv);
+static void sqfs_traverse_path_remove(sqfs_traverse *trv, size_t size);
+static void sqfs_traverse_path_remove_name(sqfs_traverse *trv);
+static void sqfs_traverse_path_remove_sep(sqfs_traverse *trv);
+/* Set the size of the last path component */
+static void sqfs_traverse_path_set_name_size(sqfs_traverse *trv, size_t size);
+/* Add nul-terminator */
+static void sqfs_traverse_path_terminate(sqfs_traverse *trv);
+
+/* Descend into new directories, and ascend back */
+static sqfs_err sqfs_traverse_descend_inode(sqfs_traverse *trv,
+	sqfs_inode *inode);
+static sqfs_err sqfs_traverse_descend(sqfs_traverse *trv, sqfs_inode_id iid);
+static sqfs_err sqfs_traverse_ascend(sqfs_traverse *trv);
+
+
+static void sqfs_traverse_init(sqfs_traverse *trv) {
+	sqfs_dentry_init(&trv->entry, trv->namebuf);
+	sqfs_stack_init(&trv->stack);
+	trv->state = TRAVERSE_ERROR;
+	trv->path = NULL;
+}
+
+sqfs_err sqfs_traverse_open_inode(sqfs_traverse *trv, sqfs *fs,
+		sqfs_inode *inode) {
+	sqfs_err err;
+	
+	sqfs_traverse_init(trv);	
+	if ((err = sqfs_traverse_path_init(trv)))
+		goto error;
+	err = sqfs_stack_create(&trv->stack, sizeof(sqfs_traverse_level), 0, NULL);
+	if (err)
+		goto error;
+	
+	trv->fs = fs;
+	if ((err = sqfs_traverse_descend_inode(trv, inode)))
+		goto error;
+	
+	sqfs_traverse_path_set_name_size(trv, 0); /* The root has no name */
+	trv->state = TRAVERSE_NAME_REMOVE;
+	return SQFS_OK;
+	
+error:
+	sqfs_traverse_close(trv);
+	return err;
+}
+
+sqfs_err sqfs_traverse_open(sqfs_traverse *trv, sqfs *fs, sqfs_inode_id iid) {
+	sqfs_err err;
+	sqfs_inode inode;
+	
+	if ((err = sqfs_inode_get(fs, &inode, iid)))
+		return err;
+	
+	return sqfs_traverse_open_inode(trv, fs, &inode);
+}
+
+void sqfs_traverse_close(sqfs_traverse *trv) {
+	sqfs_stack_destroy(&trv->stack);
+	free(trv->path);
+	sqfs_traverse_init(trv);
+}
+
+
+short sqfs_traverse_next(sqfs_traverse *trv, sqfs_err *err) {
+	sqfs_traverse_level *level;
+	short found;
+	
+	*err = SQFS_OK;
+	while (1) {
+		switch (trv->state) {
+			case TRAVERSE_GET_ENTRY:
+				if ((*err = sqfs_stack_top(&trv->stack, &level)))
+					goto error;
+				
+				found = sqfs_dir_next(trv->fs, &level->dir, &trv->entry, err);
+				if (*err)
+					goto error;
+				if (found)
+					trv->state = TRAVERSE_NAME_ADD;
+				else
+					trv->state = TRAVERSE_ASCEND;
+				break;
+			
+			case TRAVERSE_NAME_ADD:
+				if ((*err = sqfs_traverse_path_add_name(trv)))
+					goto error;
+				if (sqfs_dentry_is_dir(&trv->entry))
+					trv->state = TRAVERSE_DESCEND;
+				else
+					trv->state = TRAVERSE_NAME_REMOVE;
+				trv->dir_end = 0;
+				return 1;
+			
+			case TRAVERSE_NAME_REMOVE:
+				sqfs_traverse_path_remove_name(trv);
+				trv->state = TRAVERSE_GET_ENTRY;
+				break;
+			
+			case TRAVERSE_DESCEND:
+				*err = sqfs_traverse_descend(trv, sqfs_dentry_inode(&trv->entry));
+				if (*err)
+					goto error;
+				trv->state = TRAVERSE_GET_ENTRY;
+				break;
+			
+			case TRAVERSE_ASCEND:
+				if ((*err = sqfs_traverse_ascend(trv)))
+					goto error;
+				if (sqfs_stack_size(&trv->stack) > 0) {
+					trv->dir_end = 1;
+					trv->state = TRAVERSE_NAME_REMOVE;
+					return 1;
+				}
+				trv->state = TRAVERSE_FINISHED;
+				break;
+			
+			case TRAVERSE_FINISHED:
+				return 0;
+			
+			case TRAVERSE_ERROR:
+				*err = SQFS_ERR;
+				goto error;
+		}
+	}
+	
+error:
+	trv->state = TRAVERSE_ERROR;
+	return 0;
+}
+
+sqfs_err sqfs_traverse_prune(sqfs_traverse *trv) {
+	trv->state = TRAVERSE_NAME_REMOVE;
+	return SQFS_OK;
+}
+
+
+static sqfs_err sqfs_traverse_path_init(sqfs_traverse *trv) {
+	trv->path_cap = TRAVERSE_DEFAULT_PATH_CAP;
+	if (!(trv->path = malloc(trv->path_cap)))
+		return SQFS_ERR;
+	trv->path[0] = '\0';
+	trv->path_size = 1; /* includes nul-terminator */
+	return SQFS_OK;
+}
+
+static void sqfs_traverse_path_terminate(sqfs_traverse *trv) {
+	trv->path[trv->path_size - 1] = '\0';
+}
+
+static sqfs_err sqfs_traverse_path_add(sqfs_traverse *trv,
+		const char *str, size_t size) {
+	size_t need = trv->path_size + size;
+	if (need > trv->path_cap) {
+		char *next_path;
+		size_t next_cap = trv->path_cap;
+		while (need > next_cap)
+			next_cap *= 2;
+		
+		if (!(next_path = realloc(trv->path, next_cap)))
+			return SQFS_ERR;
+		
+		trv->path = next_path;
+		trv->path_cap = next_cap;
+	}
+	
+	memcpy(trv->path + trv->path_size - 1, str, size);
+	trv->path_size = need;
+	sqfs_traverse_path_terminate(trv);
+	return SQFS_OK;
+}
+
+static void sqfs_traverse_path_remove(sqfs_traverse *trv, size_t size) {
+	if (trv->path_size > size)
+		trv->path_size -= size;
+	else
+		trv->path_size = 1; /* only nul terminator left */
+	
+	sqfs_traverse_path_terminate(trv);
+}
+
+static sqfs_err sqfs_traverse_path_add_name(sqfs_traverse *trv) {
+	trv->path_last_size = sqfs_dentry_name_size(&trv->entry);
+	return sqfs_traverse_path_add(trv, sqfs_dentry_name(&trv->entry),
+		trv->path_last_size);
+}
+
+static sqfs_err sqfs_traverse_path_add_sep(sqfs_traverse *trv) {
+	return sqfs_traverse_path_add(trv, TRAVERSE_PATH_SEPARATOR,
+		strlen(TRAVERSE_PATH_SEPARATOR));
+}
+
+static void sqfs_traverse_path_remove_name(sqfs_traverse *trv) {
+	sqfs_traverse_path_remove(trv, trv->path_last_size);
+}
+
+static void sqfs_traverse_path_remove_sep(sqfs_traverse *trv) {
+	sqfs_traverse_path_remove(trv, strlen(TRAVERSE_PATH_SEPARATOR));
+}
+
+static void sqfs_traverse_path_set_name_size(sqfs_traverse *trv, size_t size) {
+	trv->path_last_size = size;
+}
+
+
+static sqfs_err sqfs_traverse_descend_inode(sqfs_traverse *trv,
+		sqfs_inode *inode) {
+	sqfs_err err;
+	sqfs_traverse_level *level;
+	short initial;
+	
+	initial = (sqfs_stack_size(&trv->stack) == 0);
+	
+	if ((err = sqfs_stack_push(&trv->stack, &level)))
+		return err;	
+	if ((err = sqfs_dir_open(trv->fs, inode, &level->dir, 0)))
+		return err;
+	
+	if (initial) {
+		/* Don't add the separator or store the size for the root directory */
+		level->name_size = 0;
+	} else {
+		level->name_size = sqfs_dentry_name_size(&trv->entry);
+		if ((err = sqfs_traverse_path_add_sep(trv)))
+			return err;
+	}
+	
+	return err;
+}
+
+static sqfs_err sqfs_traverse_descend(sqfs_traverse *trv, sqfs_inode_id iid) {
+	sqfs_err err;
+	sqfs_inode inode;
+	
+	if ((err = sqfs_inode_get(trv->fs, &inode, iid)))
+		return err;
+	
+	return sqfs_traverse_descend_inode(trv, &inode);
+}
+
+static sqfs_err sqfs_traverse_ascend(sqfs_traverse *trv) {
+	sqfs_err err;
+	sqfs_traverse_level *level;
+	
+	if ((err = sqfs_stack_top(&trv->stack, &level)))
+		return err;
+	
+	sqfs_traverse_path_remove_sep(trv); /* safe even if initial */
+	sqfs_traverse_path_set_name_size(trv, level->name_size);
+	
+	sqfs_stack_pop(&trv->stack);
+	return SQFS_OK;
+}
diff -ruN ruby-2.4.1/squash_util.c ruby/squash_util.c
--- ruby-2.4.1/squash_util.c	1970-01-01 02:00:00.000000000 +0200
+++ ruby/squash_util.c	2018-03-16 15:30:56.000000000 +0200
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2014 Dave Vasilevsky <dave@vasilevsky.ca>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "squash/util.h"
+
+#include "squash/fs.h"
+
+#include <stdio.h>
+
+sqfs_err sqfs_fd_open(const uint8_t *path, sqfs_fd_t *fd) {
+	*fd = path;
+	return SQFS_OK;
+}
+
+void sqfs_fd_close(sqfs_fd_t fd) {
+  // do nothing
+}
+
+
+/* TODO: WIN32 implementation of open/close */
+/* TODO: i18n of error messages */
+sqfs_err sqfs_open_image(sqfs *fs, const uint8_t *image, size_t offset) {
+	sqfs_err err;
+	sqfs_fd_t fd;
+
+	if ((err = sqfs_fd_open(image, &fd)))
+		return err;
+
+	err = sqfs_init(fs, fd, offset);
+	switch (err) {
+		case SQFS_OK:
+			break;
+		case SQFS_BADFORMAT:
+			fprintf(stderr, "This doesn't look like a squashfs image.\n");
+			break;
+		case SQFS_BADVERSION: {
+			int major, minor, mj1, mn1, mj2, mn2;
+			sqfs_version(fs, &major, &minor);
+			sqfs_version_supported(&mj1, &mn1, &mj2, &mn2);
+			fprintf(stderr, "Squashfs version %d.%d detected, only version",
+				major, minor);
+			if (mj1 == mj2 && mn1 == mn2)
+				fprintf(stderr, " %d.%d", mj1, mn1);
+			else
+				fprintf(stderr, "s %d.%d to %d.%d", mj1, mn1, mj2, mn2);
+			fprintf(stderr, " supported.\n");
+			break;
+		}
+		case SQFS_BADCOMP: {
+			fprintf(stderr, "Squashfs image uses ? compression");
+			fprintf(stderr, ".\n");
+			break;
+		}
+		default:
+			fprintf(stderr, "Something went wrong trying to read the squashfs "
+				"image.\n");
+	}
+
+	if (err)
+		sqfs_fd_close(fd);
+	return err;
+}
+
diff -ruN ruby-2.4.1/tool/mkconfig.rb ruby/tool/mkconfig.rb
--- ruby-2.4.1/tool/mkconfig.rb	2016-11-17 09:19:49.000000000 +0200
+++ ruby/tool/mkconfig.rb	2018-03-16 15:30:56.000000000 +0200
@@ -126,6 +126,22 @@
       val = '"$(SDKROOT)"'+val if /darwin/ =~ arch
     end
     v = "  CONFIG[\"#{name}\"] #{eq} #{val}\n"
+
+    if ENV['ENCLOSE_IO_RUBYC_2ND_PASS']
+      v_head_comp = "  CONFIG[\"prefix\"] #{eq} "
+      if v_head_comp == v[0...(v_head_comp.length)]
+        if win32
+          v = "#{v[0...(v_head_comp.length)]}CONFIG[\"RUBY_EXEC_PREFIX\"] = '/__enclose_io_memfs__'\n"
+        else
+          v = "#{v[0...(v_head_comp.length)]}'/__enclose_io_memfs__'\n"
+        end
+      end
+      v_head_comp = "  CONFIG[\"RUBY_EXEC_PREFIX\"] #{eq} "
+      if v_head_comp == v[0...(v_head_comp.length)]
+        v = "#{v[0...(v_head_comp.length)]}'/__enclose_io_memfs__'\n"
+      end
+    end
+
     if fast[name]
       v_fast << v
     else
diff -ruN ruby-2.4.1/util.c ruby/util.c
--- ruby-2.4.1/util.c	2017-03-12 18:22:05.000000000 +0200
+++ ruby/util.c	2018-03-16 15:30:56.000000000 +0200
@@ -30,6 +30,10 @@
 const char ruby_hexdigits[] = "0123456789abcdef0123456789ABCDEF";
 #define hexdigit ruby_hexdigits
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 unsigned long
 ruby_scan_oct(const char *start, size_t len, size_t *retlen)
 {
Binary files ruby-2.4.1/vendor/bundler-1.15.3.gem and ruby/vendor/bundler-1.15.3.gem differ
diff -ruN ruby-2.4.1/win32/Makefile.sub ruby/win32/Makefile.sub
--- ruby-2.4.1/win32/Makefile.sub	2016-09-16 13:47:54.000000000 +0300
+++ ruby/win32/Makefile.sub	2018-03-16 15:30:56.000000000 +0200
@@ -247,7 +247,7 @@
 EXTSOLIBS =
 !endif
 !if !defined(LIBS)
-LIBS = user32.lib advapi32.lib shell32.lib ws2_32.lib
+LIBS = user32.lib advapi32.lib shell32.lib ws2_32.lib Ole32.lib Shell32.lib
 !if $(MSC_VER) >= 1400
 LIBS = $(LIBS) iphlpapi.lib
 !endif
@@ -977,7 +977,9 @@
 miniruby$(EXEEXT):
 		@echo $(LIBS)
 		$(ECHO) linking $(@:\=/)
-		$(Q) $(PURIFY) $(CC) $(MAINOBJ) $(MINIOBJS) $(COMMONOBJS) $(LIBS) -Fe$@ -link $(LDFLAGS)
+		$(Q) $(PURIFY) $(CC) $(CFLAGS) $(MAINOBJ) $(MINIOBJS) $(COMMONOBJS) $(LIBS) -Fe$@ \
+			..\zlib\zlib.lib \
+			-link $(LDFLAGS)
 		@$(RM) miniruby.lib miniruby.exp
 		$(Q) miniruby.exe -v
 		$(Q) $(LDSHARED_1)
@@ -986,10 +988,42 @@
 miniruby.rc:
 		@exit > $@
 
+ruby_static.exe:	$(MAINOBJ) $(LIBRUBY_SO) $(RUBY_INSTALL_NAME).res
+		$(ECHO) linking $(@:\=/)
+		$(Q) $(PURIFY) $(CC) $(CFLAGS) $(MAINOBJ) $(RUBY_INSTALL_NAME).res \
+			$(OUTFLAG)$@ $(LIBRUBY_A) $(LIBS) enc\*.obj enc\*.lib ext\extinit.obj \
+			ext\bigdecimal\bigdecimal.lib \
+			ext\cgi\escape\escape.lib \
+			ext\continuation\continuation.lib \
+			ext\coverage\coverage.lib \
+			ext\date\date_core.lib \
+			ext\fcntl\fcntl.lib \
+			ext\fiber\fiber.lib \
+			ext\io\console\console.lib \
+			ext\io\nonblock\nonblock.lib \
+			ext\io\wait\wait.lib \
+			ext\json\generator\generator.lib \
+			ext\json\parser\parser.lib \
+			ext\nkf\nkf.lib \
+			ext\objspace\objspace.lib \
+			ext\pathname\pathname.lib \
+			ext\psych\psych.lib \
+			ext\racc\cparse\cparse.lib \
+			ext\rbconfig\sizeof\sizeof.lib \
+			ext\sdbm\sdbm.lib \
+			ext\stringio\stringio.lib \
+			ext\strscan\strscan.lib \
+			ext\zlib\zlib.lib \
+			..\zlib\zlib.lib \
+			-link $(LDFLAGS) $(XLDFLAGS)
+		$(Q) $(LDSHARED_0)
+		$(Q) $(LDSHARED_1)
+		$(Q) $(LDSHARED_2)
+
 !if "$(PROGRAM)" != ""
 $(PROGRAM):	$(MAINOBJ) $(LIBRUBY_SO) $(RUBY_INSTALL_NAME).res
 		$(ECHO) linking $(@:\=/)
-		$(Q) $(PURIFY) $(CC) $(MAINOBJ) $(RUBY_INSTALL_NAME).res \
+		$(Q) $(PURIFY) $(CC) $(CFLAGS) $(MAINOBJ) enclose_io_unix.obj enclose_io_memfs.obj squash_fd.obj Shell32.lib $(RUBY_INSTALL_NAME).res \
 			$(OUTFLAG)$@ $(LIBRUBYARG) -link $(LDFLAGS) $(XLDFLAGS)
 		$(Q) $(LDSHARED_0)
 		$(Q) $(LDSHARED_1)
@@ -999,7 +1033,7 @@
 !if "$(WPROGRAM)" != ""
 $(WPROGRAM):	$(MAINOBJ) $(WINMAINOBJ) $(LIBRUBY_SO) $(RUBYW_INSTALL_NAME).res
 		$(ECHO) linking $(@:\=/)
-		$(Q) $(PURIFY) $(CC) $(MAINOBJ) $(WINMAINOBJ) \
+		$(Q) $(PURIFY) $(CC) $(CFLAGS) $(MAINOBJ) enclose_io_unix.obj enclose_io_memfs.obj squash_fd.obj Shell32.lib $(WINMAINOBJ) \
 			$(RUBYW_INSTALL_NAME).res $(OUTFLAG)$@ $(LIBRUBYARG) \
 			-link $(LDFLAGS) $(XLDFLAGS) -subsystem:Windows
 		$(Q) $(LDSHARED_0)
@@ -1010,7 +1044,7 @@
 !if "$(STUBPROGRAM)" != ""
 $(STUBPROGRAM):	rubystub.$(OBJEXT) $(LIBRUBY) $(LIBRUBY_SO) $(RUBY_INSTALL_NAME).res
 		$(ECHO) linking $(@:\=/)
-		$(Q) $(PURIFY) $(CC) rubystub.$(OBJEXT) $(RUBY_INSTALL_NAME).res \
+		$(Q) $(PURIFY) $(CC) $(CFLAGS) rubystub.$(OBJEXT) $(RUBY_INSTALL_NAME).res \
 			$(OUTFLAG)$@ $(LIBRUBYARG) -link $(LDFLAGS) $(XLDFLAGS)
 		$(Q) $(LDSHARED_0)
 		$(Q) $(LDSHARED_1)
diff -ruN ruby-2.4.1/win32/file.c ruby/win32/file.c
--- ruby-2.4.1/win32/file.c	2016-12-07 04:03:40.000000000 +0200
+++ ruby/win32/file.c	2018-03-16 15:30:56.000000000 +0200
@@ -10,6 +10,10 @@
 #include <shlwapi.h>
 #include "win32/file.h"
 
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 #ifndef INVALID_FILE_ATTRIBUTES
 # define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
 #endif
diff -ruN ruby-2.4.1/win32/win32.c ruby/win32/win32.c
--- ruby-2.4.1/win32/win32.c	2017-03-12 19:23:03.000000000 +0200
+++ ruby/win32/win32.c	2018-03-16 15:30:56.000000000 +0200
@@ -53,6 +53,11 @@
 #include "win32/file.h"
 #include "internal.h"
 #include "encindex.h"
+
+// --------- [Enclose.io Hack start] ---------
+#include "enclose_io.h"
+// --------- [Enclose.io Hack end] ---------
+
 #define isdirsep(x) ((x) == '/' || (x) == '\\')
 
 #if defined _MSC_VER && _MSC_VER <= 1200
@@ -830,6 +835,11 @@
 void
 rb_w32_sysinit(int *argc, char ***argv)
 {
+    int new_argc;
+    char **new_argv;
+    UINT cp;
+    size_t i;
+
 #if RUBY_MSVCRT_VERSION >= 80
     static void set_pioinfo_extra(void);
 
@@ -847,6 +857,28 @@
     //
     *argc = w32_cmdvector(GetCommandLineW(), argv, CP_UTF8, &OnigEncodingUTF_8);
 
+    // --------- [Enclose.io Hack start] ---------
+    #ifdef ENCLOSE_IO_ENTRANCE
+    new_argc = *argc;
+    new_argv = *argv;
+    cp = CP_UTF8;
+    if (NULL == getenv("ENCLOSE_IO_USE_ORIGINAL_RUBY")) {
+        new_argv = (char **)malloc( (*argc + 1) * sizeof(char *));
+        assert(new_argv);
+        new_argv[0] = (*argv)[0];
+        new_argv[1] = ENCLOSE_IO_ENTRANCE;
+        for (i = 1; i < *argc; ++i) {
+               new_argv[2 + i - 1] = (*argv)[i];
+        }
+        new_argc = *argc + 1;
+
+        *argc = new_argc;
+        *argv = new_argv;
+    }
+    #endif
+    // --------- [Enclose.io Hack end] ---------
+
+
     //
     // Now set up the correct time stuff
     //
@@ -1810,6 +1842,9 @@
 	curr = (NtCmdLineElement *)calloc(sizeof(NtCmdLineElement), 1);
 	if (!curr) goto do_nothing;
 	curr->str = rb_w32_wstr_to_mbstr(cp, base, len, &curr->len);
+	if (curr->str && (curr->str = realloc(curr->str, curr->len + 1))) {
+	    curr->str[curr->len] = '\0';
+	}
 	curr->flags |= NTMALLOC;
 
 	if (globbing && (tail = cmdglob(curr, cmdtail, cp, enc))) {
@@ -6923,6 +6958,11 @@
 	return -1;
     }
 
+    if (SQUASH_VALID_VFD(fd)) {
+	// TODO how about Binary Mode File I/O?
+	return _read(fd, buf, size);
+    }
+
     if (_osfile(fd) & FTEXT) {
 	return _read(fd, buf, size);
     }
